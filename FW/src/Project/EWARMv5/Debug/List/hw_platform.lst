###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     12/Sep/2015  15:35:09 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\Drivers\hw_platform.c                    #
#    Command line =  E:\H520B\FW\src\Drivers\hw_platform.c -D DEBUG_VER -lcN  #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\hw_platform.l #
#                    st                                                       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\hw_platform.o  #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\Drivers\hw_platform.c
      1          /**
      2          * @file hw_platform.c
      3          * @brief H520B 硬件相关接口的实现
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "hw_platform.h"
     17          #include "stm32f10x_lib.h"
     18          #include "ucos_ii.h"
     19          #include "TimeBase.h"
     20          
     21          static unsigned int	charge_state_cnt;
     22          static unsigned int	last_charge_detect_io_cnt;
     23          
     24          unsigned int	charge_detect_io_cnt;
     25          
     26          //USB_CHK		PA1	  
     27          
     28          //LED_RED		PA4   
     29          //LED_GREEN		PA5   
     30          //LED_YELLOW	PA6   
     31          //MOTOR			PA7   
     32          
     33          //ADC_IN		PB0	  
     34          
     35          //BEEP			PB5   
     36          //CHARGE		PB6	  
     37          //RFU_IO1		PB7
     38          //RFU_IO2		PB8
     39          
     40          //TRIG			PB12
     41          
     42          /**
     43          * @brief	初始化用于电池电压检测的ADC模块
     44          * @param[in]  none
     45          * @param[out] none
     46          * @return     none
     47          * @note                    
     48          */
     49          static void ADC_Module_Init(void)
     50          {
     51          	ADC_InitTypeDef   adc_init;
     52          	GPIO_InitTypeDef  gpio_init;
     53          
     54          
     55          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
     56          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
     57          
     58          	//PB.0   ADC-IN
     59          	gpio_init.GPIO_Pin  = GPIO_Pin_0;
     60          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
     61          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
     62          	GPIO_Init(GPIOB, &gpio_init);
     63          
     64          	adc_init.ADC_Mode               = ADC_Mode_Independent;		//
     65          	adc_init.ADC_ScanConvMode       = DISABLE;
     66          	adc_init.ADC_ContinuousConvMode = ENABLE;
     67          	adc_init.ADC_ExternalTrigConv   = ADC_ExternalTrigConv_None;
     68          	adc_init.ADC_DataAlign          = ADC_DataAlign_Right;
     69          	adc_init.ADC_NbrOfChannel       = 1;
     70          	ADC_Init(ADC1, &adc_init);
     71          
     72          	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_13Cycles5);
     73          	ADC_Cmd(ADC1, ENABLE);
     74          
     75          	// 下面是ADC自动校准，开机后需执行一次，保证精度
     76          	// Enable ADC1 reset calibaration register 
     77          	ADC_ResetCalibration(ADC1);
     78          	// Check the end of ADC1 reset calibration register
     79          	while(ADC_GetResetCalibrationStatus(ADC1));
     80          
     81          	// Start ADC1 calibaration
     82          	ADC_StartCalibration(ADC1);
     83          	// Check the end of ADC1 calibration
     84          	while(ADC_GetCalibrationStatus(ADC1));
     85          	// ADC自动校准结束---------------
     86          
     87          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);			//开始转换
     88          }
     89          
     90          /**
     91          * @brief  Initialize the IO
     92          * @return   none
     93          */
     94          static void platform_misc_port_init(void)
     95          {
     96          	GPIO_InitTypeDef	GPIO_InitStructure;
     97          	EXTI_InitTypeDef	EXTI_InitStructure;
     98          	NVIC_InitTypeDef	NVIC_InitStructure;
     99          
    100          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);
    101          
    102          	//USB_CHK -- PA.1
    103          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1;
    104          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    105          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_10MHz;
    106          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    107          
    108          	//ChargeState detect -- PB.6
    109          	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6;
    110          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    111          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    112          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    113          
    114          	/* Connect EXTI Line6 to PB.6 */
    115          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource0);
    116          
    117          	EXTI_ClearITPendingBit(EXTI_Line6);
    118          	EXTI_InitStructure.EXTI_Line = EXTI_Line6;
    119          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    120          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
    121          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    122          	EXTI_Init(&EXTI_InitStructure); 
    123          	EXTI_GenerateSWInterrupt(EXTI_Line6);
    124          
    125          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);      
    126          	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel;
    127          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    128          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;
    129          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    130          	NVIC_Init(&NVIC_InitStructure);
    131          
    132          	charge_detect_io_cnt = 0;
    133          	last_charge_detect_io_cnt = 1;
    134          
    135          	//LED-Red -- PA.4	LED-Green -- PA.5	LED-Yellow -- PA.6		Motor -- PA.7
    136          	GPIO_InitStructure.GPIO_Pin	= GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
    137          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    138          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    139          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    140          	GPIO_SetBits(GPIOA, GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6);
    141          	GPIO_ResetBits(GPIOA, GPIO_Pin_7);
    142          
    143          	//Beep -- PB.5	Trig -- PB.12
    144          	GPIO_InitStructure.GPIO_Pin	= GPIO_Pin_5 | GPIO_Pin_12;
    145          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    146          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    147          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    148          	GPIO_SetBits(GPIOB,  GPIO_Pin_12);
    149          	GPIO_ResetBits(GPIOA, GPIO_Pin_5);
    150          
    151          	//RFU-IO1 -- PB.7	  RFU-IO2 -- PB.8		
    152          	GPIO_InitStructure.GPIO_Pin	= GPIO_Pin_7 | GPIO_Pin_8;
    153          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    154          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    155          }
    156          
    157          /**
    158          * @brief  Initialize the HW platform
    159          * @return   none
    160          */
    161          void hw_platform_init(void)
    162          {
    163          	platform_misc_port_init();
    164          	ADC_Module_Init();
    165          }
    166          
    167          
    168          /**
    169          * @brief	返回检测到的电压的级别
    170          * @param[in]  none
    171          * @param[out] none
    172          * @return     0:电池电量低		1：还有电
    173          * @note     暂定2级，当测定的电压低于3.15V时，表示系统的电压低了
    174          *			电池的工作电压范围是: 3.0 -- 4.0
    175          */
    176          
    177          #define  LOW_POWER_TH	1960		//	
    178          unsigned int hw_platform_get_PowerClass(void)
    179          { 
    180          	unsigned int  i,result = 0;
    181          	unsigned short  temp[20];
    182          	unsigned short	min,max;
    183          
    184          	for(i = 0;i < 20;i++)
    185          	{
    186          		temp[i] = ADC_GetConversionValue(ADC1);		//得到AD转换的结果
    187          		result += temp[i];
    188          		if (i == 0)
    189          		{
    190          			min = temp[i];
    191          			max = temp[i];
    192          		}
    193          
    194          		if (temp[i] < min)
    195          		{
    196          			min = temp[i];
    197          		}
    198          
    199          		if (temp[i] > max)
    200          		{
    201          			max = temp[i];
    202          		}
    203          	}
    204          
    205          	//取20次值之后,去掉最小值和最大周，再取平均值，简单的平滑滤波
    206          	result -= min;
    207          	result -= max;
    208          	result /= 18; 
    209          
    210          	if (result > LOW_POWER_TH) 
    211          	{
    212          		return 1;
    213          	}
    214          	else
    215          		return 0;
    216          }
    217          
    218          /**
    219          * @brief	检测充电状态
    220          * @param[in]  none
    221          * @param[out] none
    222          * @return     1:  充电完成    0: 正在充电
    223          * @note  正在充电时，充电检测IO输出脉冲，充满后输出低电平 
    224          *        需要注意的是：此函数只有在得知充电电源已经插入的前提下，再去检测才有意义。因为没有插入充电电源时，检测IO也是低电平的。
    225          *		利用IO的边沿中断来完成充电状态的检测，如果一直在进中断，那说明正在充电，否则表示充电完成
    226          */
    227          unsigned int  hw_platform_ChargeState_Detect(void)
    228          {
    229          	if (charge_detect_io_cnt != last_charge_detect_io_cnt)
    230          	{
    231          		charge_state_cnt = 50000;
    232          		last_charge_detect_io_cnt = charge_detect_io_cnt;
    233          		return 0;
    234          	}
    235          	else
    236          	{
    237          		if (charge_state_cnt--)
    238          		{
    239          			return 0;
    240          		}
    241          	}
    242          	return 1;
    243          }
    244          
    245          /**
    246          * @brief	检测USB是否插入
    247          * @param[in]  none
    248          * @param[out] none
    249          * @return     1:  插入    0: 没有插入
    250          * @note  如果需要在中断里面去实现，那么还需要在初始化时给此检测IO分配外部中断
    251          *		 如果在任务级查询，那么可以之际调用此函数来检测是否插入充电电源                 
    252          */
    253          unsigned int hw_platform_USBcable_Insert_Detect(void)
    254          {
    255          	unsigned int i;
    256          	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1))
    257          	{
    258          		for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
    259          		if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1))
    260          		{
    261          			return 1;
    262          		}
    263          		else
    264          		{
    265          			return 0;
    266          		}
    267          	}
    268          	else
    269          		return 0;
    270          }
    271          
    272          /**
    273          * @brief	LED控制接口
    274          * @param[in]  unsigned int led	 LED_RED or  LED_GREEN  or LED_YELLOW
    275          * @param[in]  unsigned int ctrl  0: close   1:open
    276          * @return   none                 
    277          */
    278          void hw_platform_led_ctrl(unsigned int led,unsigned int ctrl)
    279          {
    280          	if (led == LED_RED)
    281          	{
    282          		if (ctrl)
    283          		{
    284          			GPIO_ResetBits(GPIOA, GPIO_Pin_4);
    285          		}
    286          		else
    287          		{
    288          			GPIO_SetBits(GPIOA, GPIO_Pin_4);
    289          		}
    290          	}
    291          	else if (led == LED_GREEN)
    292          	{
    293          		if (ctrl)
    294          		{
    295          			GPIO_ResetBits(GPIOA, GPIO_Pin_5);
    296          		}
    297          		else
    298          		{
    299          			GPIO_SetBits(GPIOA, GPIO_Pin_5);
    300          		}
    301          	}
    302          	else if (led == LED_YELLOW)
    303          	{
    304          		if (ctrl)
    305          		{
    306          			GPIO_ResetBits(GPIOA, GPIO_Pin_6);
    307          		}
    308          		else
    309          		{
    310          			GPIO_SetBits(GPIOA, GPIO_Pin_6);
    311          		}
    312          	}
    313          }
    314          
    315          
    316          /**
    317          * @brief	Motor控制接口
    318          * @param[in]  unsigned int delay  延时一段时间,单位ms
    319          * @return   none                 
    320          */
    321          void hw_platform_motor_ctrl(unsigned short delay)
    322          {
    323          	GPIO_SetBits(GPIOA, GPIO_Pin_7);
    324          	if (delay < 5)
    325          	{
    326          		Delay(delay*2000);
    327          	}
    328          	else
    329          	{
    330          		OSTimeDlyHMSM(0,0,0,delay);
    331          	}
    332          	GPIO_ResetBits(GPIOA, GPIO_Pin_7);
    333          }
    334          
    335          /**
    336          * @brief	Trig控制接口
    337          * @param[in]  unsigned int delay  延时一段时间,单位ms
    338          * @return   none                 
    339          */
    340          void hw_platform_trig_ctrl(unsigned short delay)
    341          {
    342          	GPIO_ResetBits(GPIOB, GPIO_Pin_12);
    343          	if (delay < 5)
    344          	{
    345          		Delay(delay*2000);
    346          	}
    347          	else
    348          	{
    349          		OSTimeDlyHMSM(0,0,0,delay);
    350          	}
    351          	GPIO_SetBits(GPIOB, GPIO_Pin_12);
    352          }
    353          
    354          /**
    355          * @brief	蜂鸣器简单的控制接口
    356          * @param[in]  unsigned int delay  延时一段时间,单位ms
    357          * @return   none                 
    358          */
    359          void hw_platform_beep_ctrl(unsigned short delay)
    360          {
    361          	//@todo...
    362          }
    363          
    364          static unsigned char	current_blink_led;
    365          static unsigned char	current_led_state;
    366          static unsigned short   current_blink_frq;
    367          static unsigned int   current_timer_cnt;
    368          /**
    369           * @brief 利用时基模块提供的定时器接口实现LED闪烁
    370          */
    371          static void led_blink_timer_hook(void)
    372          {
    373          	current_timer_cnt++;
    374          	if (current_timer_cnt == current_blink_frq*2*10)
    375          	{
    376          		current_led_state ^= 0x01;
    377          		hw_platform_led_ctrl(current_blink_led,current_led_state);
    378          		current_timer_cnt = 0;
    379          	}
    380          }
    381          
    382          /**
    383           * @brief 开始LED闪烁指示
    384           * @param[in] unsigned int		led		
    385           * @param[in] unsigned short	delay	闪烁的时间间隔，也就是闪烁频率,单位10ms
    386           * @note 注意此接口只能让一个LED在闪烁，不能实现几个LED同时闪烁
    387          */
    388          void hw_platform_start_led_blink(unsigned int led,unsigned short delay)
    389          {
    390          	current_timer_cnt = 0;
    391          	current_blink_led = led;
    392          	current_blink_frq = delay;
    393          	current_led_state = 1;
    394          	hw_platform_led_ctrl(current_blink_led,current_led_state);
    395          	start_timer(led_blink_timer_hook);
    396          }
    397          
    398          /**
    399           * @brief 关闭正在闪烁的LED
    400          */
    401          void hw_platform_stop_led_blink(void)
    402          {
    403          	stop_timer();
    404          	hw_platform_led_ctrl(current_blink_led,0);
    405          }
    406          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     ADC_Module_Init                    32
     hw_platform_ChargeState_Detect      0
     hw_platform_USBcable_Insert_Detect
                                         8
     hw_platform_beep_ctrl               0
     hw_platform_get_PowerClass         64
     hw_platform_init                    8
     hw_platform_led_ctrl                8
     hw_platform_motor_ctrl              8
     hw_platform_start_led_blink         8
     hw_platform_stop_led_blink          8
     hw_platform_trig_ctrl               8
     led_blink_timer_hook                8
     platform_misc_port_init            24


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     charge_state_cnt                  4
     last_charge_detect_io_cnt         4
     charge_detect_io_cnt              4
     ADC_Module_Init                 152
     platform_misc_port_init         276
     hw_platform_init                 12
     hw_platform_get_PowerClass      118
     hw_platform_ChargeState_Detect   56
     hw_platform_USBcable_Insert_Detect
                                      48
     hw_platform_led_ctrl             86
     hw_platform_motor_ctrl           56
     hw_platform_trig_ctrl            60
     hw_platform_beep_ctrl             2
     current_blink_led                 1
     current_led_state                 1
     current_blink_frq                 2
     current_timer_cnt                 4
     led_blink_timer_hook             62
     hw_platform_start_led_blink      48
     hw_platform_stop_led_blink       18
     ??DataTable20                     4
     ??DataTable23                     4
     ??DataTable24                     4
     ??DataTable34                     4
     ??DataTable36                     4
     ??DataTable46                     4
     ??DataTable48                     4
     ??DataTable50                     4
     ??DataTable52                     4

 
    20 bytes in section .bss
 1 030 bytes in section .text
 
 1 030 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
