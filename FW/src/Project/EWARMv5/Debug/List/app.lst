###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     12/Sep/2015  15:36:03 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -D DEBUG_VER -lcN              #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record.h"
     28          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     29          #define BARCODE_CASH_NUM	10			//定义等待蓝牙模块线程发送的条码缓冲区为10个条码
     30          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     31          
     32          //define the stack size of each task
     33          #define STACK_SIZE_TASKEC			128	
     34          #define STACK_SIZE_TASKSM			256
     35          #define STACK_SIZE_TASKBT			128
     36          #define STACK_SIZE_TASKINI			64
     37          
     38          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     39          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     40          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     41          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     42          
     43          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     44          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     45          /*
     46          ------------------------------------------------------------
     47          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     48          ------------------------------------------------------------
     49          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     50          ------------------------------------------------------------
     51          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     52          ------------------------------------------------------------
     53          .........
     54          ------------------------------------------------------------
     55          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     56          ------------------------------------------------------------
     57          */
     58          //定义条码的静态缓冲区，以免动态分配内存
     59          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     60          
     61          
     62          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     63          //定义事件监测线程与主状态机之间通讯的IPC对象
     64          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     65          OS_EVENT	*pEvent_Queue;			//事件消息队列
     66          
     67          static OS_EVENT *pIOSem;				//IO信号量
     68          //
     69          
     70          unsigned int	device_current_state;		//设备主状态机
     71          
     72          void u_disk_proc(void);
     73          
     74          /**
     75          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
     76          * @param[in] unsigned char* barcode				需要缓存的条码
     77          * @param[in] unsigned char	ios_keypad_flag     是否需要唤取IOS softkeypad
     78          * @return   缓存的地址
     79          * @note 策略:只要找到一个空位置就放进去，每一列的最有一个字节为0表示该位置是空的
     80          *											     最后一个字节0x55表示该位置已经缓存了条码
     81          */
     82          unsigned char * push_barcode_into_cash(unsigned char* barcode,unsigned char	ios_keypad_flag)
     83          {
     84          	unsigned int	i;
     85          	for (i = 0; i < BARCODE_CASH_NUM;i++)
     86          	{
     87          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
     88          		{
     89          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
     90          			{
     91          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
     92          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
     93          			}
     94          			else
     95          			{
     96          				strcpy((char*)barcode_cash[i],(char const*)barcode);
     97          			}
     98          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
     99          			if (ios_keypad_flag)
    100          			{
    101          				barcode_cash[i][MAX_BARCODE_LEN+1] |= 0xF0;
    102          			}
    103          			return (void*)barcode_cash[i];
    104          		}
    105          	}
    106          
    107          	return (void*)0;
    108          }
    109          
    110          
    111          /**
    112          * @brief	将已经发送出去的缓存地址pull出来
    113          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    114          * @return   none
    115          */
    116          void pull_barcode_from_cash(unsigned char* barcode_addr)
    117          {
    118          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    119          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    120          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    121          
    122          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    123          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    124          	return;
    125          }
    126          
    127          
    128          
    129          /**
    130          * @brief	进入Memory模式时，需要进行的一些设置
    131          */
    132          static void enter_into_Memory_Mode(void)
    133          {
    134          	//@todo...
    135          }
    136          
    137          /**
    138          * @brief	退出Memory模式时，需要进行的一些设置
    139          */
    140          static void exit_from_Memory_Mode(void)
    141          {
    142          	//@todo...
    143          }
    144          
    145          /**
    146          * @brief	进入USB HID模式时，需要进行的一些设置
    147          */
    148          static void enter_into_USB_HID_Mode(void)
    149          {
    150          	//@todo...
    151          }
    152          
    153          /**
    154          * @brief	退出USB HID模式时，需要进行的一些设置
    155          */
    156          static void exit_from_USB_HID_Mode(void)
    157          {
    158          	//@todo...
    159          }
    160          
    161          /**
    162          * @brief	进入BT模式时，需要进行的一些设置
    163          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    164          */
    165          static void enter_into_BT_Mode(unsigned char child_state)
    166          {
    167          	//@todo...
    168          }
    169          
    170          /**
    171          * @brief	退出BT模式时，需要进行的一些设置
    172          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    173          */
    174          static void exit_from_BT_Mode(unsigned char child_state)
    175          {
    176          	//@todo...
    177          }
    178          
    179          
    180          /**
    181          * @brief	通过USB HID发送条码
    182          */
    183          static void barcode_hid_send(unsigned char* barcode)
    184          {
    185          	unsigned int	i,code_len;
    186          	unsigned char key_value_report[8];
    187          
    188                  code_len = strlen((char const*)barcode);
    189          	OSSchedLock();
    190          	for (i = 0; i < code_len; i++)
    191          	{
    192          		ascii_to_keyreport(barcode[i],key_value_report);
    193          
    194          		SendData_To_PC(key_value_report, 3);
    195          		SendData_To_PC("\x00\x00\x00", 3);
    196          	}
    197          
    198          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    199          
    200          	SendData_To_PC(key_value_report, 3);
    201          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    202          	OSSchedUnlock();
    203          }
    204          
    205          /**
    206          * @brief	应用的初始化
    207          */
    208          void app_init(void)
    209          {
    210          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    211          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    212          	assert(pEvent_Queue != (OS_EVENT*)0);
    213          
    214          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    215          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    216          	assert(pBarcode_Queue != (OS_EVENT*)0);
    217          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    218          
    219          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    220          	pIOSem = OSSemCreate(0);
    221          	assert(pIOSem != (OS_EVENT*)0);
    222          	device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
    223          }
    224          
    225          /**
    226          * @brief	维护主状态机的线程
    227          */
    228          void State_Machine_thread(void *p)
    229          {
    230          	unsigned int	i,cnt,event;
    231          	unsigned char	err;
    232          	unsigned char	barcode[MAX_BARCODE_LEN+1];
    233          	unsigned char   codetype[20];
    234          	unsigned int    codelen;
    235          	int				ret,index;
    236          	unsigned int	last_state;
    237          	unsigned char	*rec;
    238          
    239          	while(1)
    240          	{
    241          		event = (unsigned int)OSQPend(pEvent_Queue,0,&err);
    242          		assert(err == OS_ERR_NONE);
    243          #ifdef DEBUG_VER
    244          		printf("current state:%d\r\n",device_current_state);
    245          		printf("event:%d\r\n",event);
    246          #endif
    247          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    248          		{
    249          			switch(event)
    250          			{
    251          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    252          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    253          				scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    254          				hw_platform_stop_led_blink();
    255          				//只是扫描到条码而已，什么都不做
    256          				break;
    257          			case EVENT_SCAN_KEY_LONG_PRESS:
    258          				//切换到Memory Mode
    259          				hw_platform_stop_led_blink();
    260          				exit_from_BT_Mode(0);
    261          				device_current_state = STATE_Memory_Mode;
    262          				enter_into_Memory_Mode();
    263          				break;
    264          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    265          				break;
    266          			case EVENT_ERASE_KEY_LONG_PRESS:
    267          				//切换到配对模式
    268          				exit_from_BT_Mode(0);
    269          				device_current_state = STATE_BT_Mode_WaitPair;
    270          				enter_into_BT_Mode(2);
    271          				break;
    272          			case EVENT_RESET_KEY_PRESS:
    273          				break;
    274          			case EVENT_BT_CONNECTED:
    275          				//切换到蓝牙连接模式
    276          				exit_from_BT_Mode(0);
    277          				device_current_state = STATE_BT_Mode_Connect;
    278          				enter_into_BT_Mode(1);
    279          				break;
    280          			case EVENT_BT_DISCONNECTED:
    281          				break;
    282          			case EVENT_USB_CABLE_INSERT:
    283          				//切换到USB HID模式
    284          				exit_from_BT_Mode(0);
    285          				last_state = STATE_BT_Mode_Disconnect;
    286          				device_current_state = STATE_HID_Mode;
    287          				enter_into_USB_HID_Mode();
    288          				break;
    289          			case EVENT_USB_CABLE_REMOVE:
    290          				break;
    291          			case EVENT_LOW_POWER:
    292          				//@todo...
    293          				break;
    294          			default:
    295          				break;
    296          			}
    297          		}
    298          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    299          		{
    300          			switch(event)
    301          			{
    302          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    303          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    304          				//扫描条码
    305          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    306          				hw_platform_stop_led_blink();
    307          				if (ret != 0)
    308          				{
    309          					break;
    310          				}
    311          
    312          				//扫描到条码了
    313          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    314          				//Queue，由蓝牙模块线程负责去发送到主机
    315          repost:
    316          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode,(event == EVENT_SCAN_KEY_SINGLE_CLICK)?0:1));
    317          				if(ret != OS_ERR_NONE)
    318          				{
    319          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    320          					{
    321          						//如果队列满了或者空事件时，那么需要延时重试
    322          						OSTimeDlyHMSM(0,0,0,100);
    323          						goto repost;
    324          					}
    325          					else
    326          					{
    327          						assert(0);	//系统错误
    328          					}
    329          				}
    330          				break;
    331          			case EVENT_SCAN_KEY_LONG_PRESS:
    332          				hw_platform_stop_led_blink();
    333          				//切换到Memory mode
    334          				exit_from_BT_Mode(1);
    335          				device_current_state = STATE_Memory_Mode;
    336          				enter_into_Memory_Mode();
    337          				break;
    338          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    339          				break;
    340          			case EVENT_ERASE_KEY_LONG_PRESS:
    341          				//进入配对模式
    342          				exit_from_BT_Mode(1);
    343          				device_current_state = STATE_BT_Mode_WaitPair;
    344          				enter_into_BT_Mode(2);
    345          				break;
    346          			case EVENT_RESET_KEY_PRESS:
    347          				//@todo...
    348          				break;
    349          			case EVENT_BT_CONNECTED:
    350          				break;
    351          			case EVENT_BT_DISCONNECTED:
    352          				//切换到蓝牙断开状态
    353          				exit_from_BT_Mode(1);
    354          				device_current_state = STATE_BT_Mode_Disconnect;
    355          				enter_into_BT_Mode(0);
    356          				break;
    357          			case EVENT_USB_CABLE_INSERT:
    358          				//切换到USB HID模式
    359          				exit_from_BT_Mode(1);
    360          				last_state = STATE_BT_Mode_Disconnect;
    361          				device_current_state = STATE_HID_Mode;
    362          				enter_into_USB_HID_Mode();
    363          				break;
    364          			case EVENT_USB_CABLE_REMOVE:
    365          				break;
    366          			case EVENT_LOW_POWER:
    367          				//@todo...
    368          				break;
    369          			default:
    370          				break;
    371          			}
    372          		}
    373          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    374          		{
    375          			switch(event)
    376          			{
    377          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    378          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    379          				scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    380          				hw_platform_stop_led_blink();
    381          				//只是扫描到条码而已，什么都不做
    382          				break;
    383          			case EVENT_SCAN_KEY_LONG_PRESS:
    384          				hw_platform_stop_led_blink();
    385          				//切换到Memory Mode
    386          				exit_from_BT_Mode(2);
    387          				device_current_state = STATE_Memory_Mode;
    388          				enter_into_Memory_Mode();
    389          				break;
    390          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    391          				break;
    392          			case EVENT_ERASE_KEY_LONG_PRESS:
    393          				//已经是配对模式，什么都不做
    394          				break;
    395          			case EVENT_RESET_KEY_PRESS:
    396          				//@todo...
    397          				break;
    398          			case EVENT_BT_CONNECTED:
    399          				//切换到蓝牙连接状态
    400          				exit_from_BT_Mode(2);
    401          				device_current_state = STATE_BT_Mode_Connect;
    402          				enter_into_BT_Mode(1);
    403          				break;
    404          			case EVENT_BT_DISCONNECTED:
    405          				break;
    406          			case EVENT_USB_CABLE_INSERT:
    407          				//切换到USB HID模式
    408          				exit_from_BT_Mode(2);
    409          				last_state = STATE_BT_Mode_WaitPair;
    410          				device_current_state = STATE_HID_Mode;
    411          				enter_into_USB_HID_Mode();
    412          				break;
    413          			case EVENT_USB_CABLE_REMOVE:
    414          				break;
    415          			case EVENT_LOW_POWER:
    416          				//@todo...
    417          				break;
    418          			default:
    419          				break;
    420          			}
    421          		}
    422          		else if(device_current_state ==  STATE_Memory_Mode)
    423          		{
    424          			switch(event)
    425          			{
    426          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    427          				//扫描条码
    428          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    429          				hw_platform_stop_led_blink();
    430          				if (ret != 0)
    431          				{
    432          					break;
    433          				}
    434          
    435          				//扫描到条码了
    436          				//将获取到的条码保存到memory
    437          				ret = record_add(barcode);
    438          				if (ret)
    439          				{
    440          					//记录保存失败，给出提示给用户
    441          					//@todo...
    442          
    443          				}
    444          				break;
    445          			case EVENT_SCAN_KEY_LONG_PRESS:
    446          				hw_platform_stop_led_blink();
    447          				//切换至蓝牙模式
    448          				exit_from_Memory_Mode();
    449          				device_current_state = STATE_BT_Mode_Disconnect;
    450          				enter_into_BT_Mode(0);
    451          				break;
    452          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    453          				//删除扫到的条码对应的最后一笔资料
    454          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    455          				if (ret != 0)
    456          				{
    457          					break;
    458          				}
    459          				rec = rec_searchby_tag(barcode,&index);
    460          				if (rec)
    461          				{
    462          					ret = delete_one_node(index);
    463          					if (ret)
    464          					{
    465          						//提示用户，删除失败
    466          						//@todo...
    467          					}
    468          				}
    469          				break;
    470          			case EVENT_ERASE_KEY_LONG_PRESS:
    471          				//删除所有的条码记录
    472          				ret = record_clear();
    473          				if (ret)
    474          				{
    475          					//提示用户，删除失败
    476          					//@todo...
    477          				}
    478          				break;
    479          			case EVENT_RESET_KEY_PRESS:
    480          				//@todo...
    481          				break;
    482          			case EVENT_BT_CONNECTED:
    483          				break;
    484          			case EVENT_BT_DISCONNECTED:
    485          				break;
    486          			case EVENT_USB_CABLE_INSERT:
    487          				//切换到USB HID模式
    488          				exit_from_Memory_Mode();
    489          				last_state = STATE_Memory_Mode;
    490          				device_current_state = STATE_HID_Mode;
    491          				enter_into_USB_HID_Mode();
    492          				break;
    493          			case EVENT_USB_CABLE_REMOVE:
    494          				break;
    495          			case EVENT_LOW_POWER:
    496          				//@todo...
    497          				break;
    498          			default:
    499          				break;
    500          			}
    501          		}
    502          		else if(device_current_state ==  STATE_HID_Mode)
    503          		{
    504          			switch(event)
    505          			{
    506          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    507          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    508          				hw_platform_stop_led_blink();
    509          				if(ret !=0)	//扫描条码
    510          				{
    511          					break;
    512          				}
    513          
    514          				//将扫描到的条码通过HID 接口发送出去
    515          				barcode_hid_send(barcode);
    516          				break;
    517          			case EVENT_SCAN_KEY_LONG_PRESS:
    518          				hw_platform_stop_led_blink();
    519          				break;
    520          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    521          				break;
    522          			case EVENT_ERASE_KEY_LONG_PRESS:
    523          				//将所有保存在Memory中的条码，全部上传到PC
    524          				cnt = record_module_count();
    525          				for (i = 0; i < cnt;i++)
    526          				{
    527          					if (get_node((i==0)?0:2,0) == 0)
    528          					{
    529          						barcode_hid_send(barcode);
    530          					}
    531          					else
    532          					{
    533          						//提示用户读取失败一次
    534          						//@todo...
    535          					}
    536          				}
    537          				break;
    538          			case EVENT_RESET_KEY_PRESS:
    539          				//@todo...
    540          				break;
    541          			case EVENT_BT_CONNECTED:
    542          				break;
    543          			case EVENT_BT_DISCONNECTED:
    544          				break;
    545          			case EVENT_USB_CABLE_INSERT:
    546          				break;
    547          			case EVENT_USB_CABLE_REMOVE:
    548          				//切换到之前的状态
    549          				exit_from_USB_HID_Mode();
    550          				device_current_state = last_state;
    551          				if (device_current_state == STATE_Memory_Mode)
    552          				{
    553          					enter_into_Memory_Mode();
    554          				}
    555          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    556          				{
    557          					enter_into_BT_Mode(2);
    558          				}
    559          				else
    560          				{
    561          					enter_into_BT_Mode(0);
    562          				}
    563          				break;
    564          			case EVENT_LOW_POWER:
    565          				break;
    566          			default:
    567          				break;
    568          			}
    569          		}
    570          	}
    571          }
    572          
    573          /**
    574          * @brief	获取部分异步事件的线程
    575          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    576          *			比如：按键事件会在定时器中断的服务程序post出来
    577          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    578          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    579          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    580          */
    581          void Event_capture_thread(void *p)
    582          {
    583          #ifdef DEBUG_VER
    584          	printf("Enter into Event_capture_thread!\r\n");
    585          #endif
    586          	while (1)
    587          	{
    588          		if (device_current_state == STATE_HID_Mode)
    589          		{
    590          			//判断USB线的拔出
    591          			if (hw_platform_USBcable_Insert_Detect() == 0)
    592          			{
    593          #ifdef DEBUG_VER
    594          				printf("usb cable remove detected!\r\n");
    595          #endif
    596          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    597          			}
    598          
    599          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    600          		}
    601          		else
    602          		{
    603          			//判断电池电量低
    604          			if (hw_platform_get_PowerClass() == 0)
    605          			{
    606          #ifdef DEBUG_VER
    607          				printf("low power detected!\r\n");
    608          #endif
    609          				OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    610          			}
    611          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    612          		}
    613          	}
    614          }
    615          
    616          
    617          /*
    618           * @brief 蓝牙模块维护线程
    619           * @note  此线程需要完成两个任务：
    620           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    621           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    622          */
    623          void BT_Daemon_thread(void *p)
    624          {
    625          	int ret;
    626                  unsigned int len;
    627          	unsigned char	err;
    628          	unsigned char	*pbarcode;
    629          
    630          	ret = WBTD_init();
    631          	if (ret)
    632          	{
    633          		WBTD_Reset();
    634          		ret = WBTD_init();
    635          		assert(ret == 0);
    636          	}
    637          
    638          #ifdef DEBUG_VER
    639          	printf("WBTD init Success!\r\n");
    640          #endif
    641          
    642          	while (1)
    643          	{
    644          		ret = WBTD_got_notify_type();
    645          		if ((ret == 1) || (ret == 2))
    646          		{
    647          #ifdef DEBUG_VER
    648          			printf("WBTD got notify = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    649          #endif
    650          			OSQPost(pEvent_Queue,(void*)((ret == 1)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    651          		}
    652          
    653          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    654          		if (pbarcode)
    655          		{
    656          #ifdef DEBUG_VER
    657          			printf("WBTD got data(%s) to send!\r\n",pbarcode);
    658          #endif
    659          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    660          			{
    661          				//发送失败应该怎么处理，什么都不做了么????!!!!
    662          				//@todo...
    663          #ifdef DEBUG_VER
    664          				printf("WBTD send data Fail!\r\n");
    665          #endif
    666          			}
    667          
    668          #ifdef DEBUG_VER
    669          			printf("WBTD send data Success!\r\n");
    670          #endif
    671          		}
    672          	}
    673          }
    674          
    675          
    676          //进入U盘模式
    677          void u_disk_proc(void)
    678          {
    679          	OSSchedLock();
    680          
    681          	while(hw_platform_USBcable_Insert_Detect() == 1)
    682          	{	
    683          		if(bDeviceState != CONFIGURED)
    684          		{
    685          			break;
    686          		}
    687          
    688          		Delay(2000);
    689          	}
    690          
    691          	OSSchedUnlock();
    692          }
    693          
    694          
    695          
    696          // Cortex System Control register address
    697          #define SCB_SysCtrl					((u32)0xE000ED10)
    698          // SLEEPDEEP bit mask
    699          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
    700          
    701          /*
    702           * @brief 初始化线程
    703           */
    704          void app_init_thread(void *p)
    705          {
    706          #ifdef DEBUG_VER
    707          	printf("app init thread startup...\r\n");
    708          #endif
    709          
    710          	OS_CPU_SysTickInit();
    711          
    712          	app_init();
    713          
    714          	OSTaskCreateExt(State_Machine_thread,
    715          		(void *)0,
    716          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
    717          		8,
    718          		8,
    719          		&thread_statemachine_stk[0],
    720          		STACK_SIZE_TASKSM,
    721          		(void *)0,
    722          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    723          
    724          	OSTaskCreateExt(Event_capture_thread,
    725          		(void *)0,
    726          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
    727          		7,
    728          		7,
    729          		&thread_eventcapture_stk[0],
    730          		STACK_SIZE_TASKEC,
    731          		(void *)0,
    732          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    733          
    734          	OSTaskCreateExt(BT_Daemon_thread,
    735          		(void *)0,
    736          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
    737          		6,
    738          		6,
    739          		&thread_bt_stk[0],
    740          		STACK_SIZE_TASKBT,
    741          		(void *)0,
    742          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    743          
    744          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    745          }
    746          
    747          /*
    748           * @brief 启动应用
    749           */
    750          void app_startup(void)
    751          {
    752          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
    753          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
    754          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
    755          
    756          	OSInit();
    757          
    758          	OSDebugInit();
    759          
    760          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI);
    761          	assert(p_init_thread_stk != 0);
    762          	memset((void*)p_init_thread_stk,0xDD,STACK_SIZE_TASKINI);
    763          
    764          	OSTaskCreateExt(app_init_thread,
    765          		(void *)0,
    766          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
    767          		5,
    768          		5,
    769          		&p_init_thread_stk[0],
    770          		STACK_SIZE_TASKINI,
    771          		(void *)0,
    772          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    773          
    774          	OSStart();
    775          }
    776          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            16
     Event_capture_thread         8
     State_Machine_thread       136
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           0
     enter_into_Memory_Mode       0
     enter_into_USB_HID_Mode      0
     exit_from_BT_Mode            0
     exit_from_Memory_Mode        0
     exit_from_USB_HID_Mode       0
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1024
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  40
     barcode_cash                                 820
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     push_barcode_into_cash                       150
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                         2
     exit_from_Memory_Mode                          2
     enter_into_USB_HID_Mode                        2
     exit_from_USB_HID_Mode                         2
     enter_into_BT_Mode                             2
     exit_from_BT_Mode                              2
     barcode_hid_send                              92
     app_init                                     164
     State_Machine_thread                        1012
     Event_capture_thread                         104
     BT_Daemon_thread                             188
     u_disk_proc                                   44
     app_init_thread                              148
     app_startup                                  144
     ??DataTable19                                  4
     ??DataTable49                                  4
     ??DataTable52                                  4
     ??DataTable53                                  4
     ??DataTable58                                  4
     ??DataTable59                                  4
     ??DataTable60                                  4
     ??DataTable63                                  4
     ??DataTable66                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "err == OS_ERR_NONE">              20
     ?<Constant "current state:%d\r\n">            20
     ?<Constant "event:%d\r\n">                    12
     ?<Constant "0">                                2
     ?<Constant "Enter into Event_capt...">        36
     ?<Constant "usb cable remove dete...">        32
     ?<Constant "low power detected!\r\n">         24
     ?<Constant "ret == 0">                        12
     ?<Constant "WBTD init Success!\r\n">          24
     ?<Constant "WBTD got notify = %s!\r\n">       24
     ?<Constant "Connected">                       12
     ?<Constant "Disconnect">                      12
     ?<Constant "WBTD got data(%s) to ...">        32
     ?<Constant "WBTD send data Fail!\r\n">        24
     ?<Constant "WBTD send data Succes...">        28
     ?<Constant "app init thread start...">        32
     ?<Constant "p_init_thread_stk != 0">          24

 
 2 960 bytes in section .bss
   666 bytes in section .rodata
 2 236 bytes in section .text
 
 2 202 bytes of CODE  memory (+ 34 bytes shared)
   666 bytes of CONST memory
 2 960 bytes of DATA  memory

Errors: none
Warnings: none
