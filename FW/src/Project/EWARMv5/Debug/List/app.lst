###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     28/Sep/2015  18:18:39 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -lcN                           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record_m.h"
     28          #include "Terminal_Para.h"
     29          #include "usb_lib.h"
     30          #include "PCUsart.h"
     31          
     32          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     33          #define BARCODE_CASH_NUM	15			//定义等待蓝牙模块线程发送的条码缓冲区为15个条码
     34          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     35          
     36          //define the stack size of each task
     37          #define STACK_SIZE_TASKEC			128	
     38          #define STACK_SIZE_TASKSM			356
     39          #define STACK_SIZE_TASKBT			128
     40          #define STACK_SIZE_TASKINI			224
     41          
     42          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     43          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     44          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     45          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     46          
     47          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     48          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     49          static	unsigned char	lowpower_state;
     50          static	unsigned char	lowpower_cnt;
     51          static  TBATCH_NODE		batch_node;
     52          /*
     53          ------------------------------------------------------------
     54          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     55          ------------------------------------------------------------
     56          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     57          ------------------------------------------------------------
     58          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     59          ------------------------------------------------------------
     60          .........
     61          ------------------------------------------------------------
     62          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     63          ------------------------------------------------------------
     64          */
     65          //定义条码的静态缓冲区，以免动态分配内存
     66          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     67          
     68          
     69          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     70          //定义事件监测线程与主状态机之间通讯的IPC对象
     71          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     72          OS_EVENT	*pEvent_Queue;			//事件消息队列
     73          
     74          static OS_EVENT *pIOSem;				//IO信号量
     75          //
     76          
     77          unsigned int	device_current_state;		//设备主状态机
     78          
     79          unsigned int	keypress_timeout;
     80          
     81          
     82          void u_disk_proc(void);
     83          int lowpower_tip(void);
     84          void system_err_tip(void);
     85          
     86          extern void EnterLowPowerMode(void);
     87          extern void ExitLowPowerMode(void);
     88          
     89          
     90          /**
     91          * @brief	扫描条码成功的提示
     92          */
     93          static inline void scan_barcode_ok_tip(void)
     94          {
     95          	hw_platform_led_ctrl(LED_YELLOW,1);
     96          	hw_platform_beep_motor_ctrl(100,4000);
     97          	OSTimeDlyHMSM(0,0,0,10);
     98          	hw_platform_led_ctrl(LED_YELLOW,0);
     99          }
    100          
    101          /**
    102          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
    103          * @param[in] unsigned char* barcode				需要缓存的条码
    104          * @return   缓存的地址
    105          * @note 策略:只要找到一个空位置就放进去，每一列的最后一个字节为0表示该位置是空的
    106          *											     最后一个字节0x55表示该位置已经缓存了条码
    107          */
    108          unsigned char * push_barcode_into_cash(unsigned char* barcode)
    109          {
    110          	unsigned int	i;
    111          	for (i = 0; i < BARCODE_CASH_NUM;i++)
    112          	{
    113          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
    114          		{
    115          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
    116          			{
    117          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
    118          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
    119          			}
    120          			else
    121          			{
    122          				strcpy((char*)barcode_cash[i],(char const*)barcode);
    123          			}
    124          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
    125          			return (void*)barcode_cash[i];
    126          		}
    127          	}
    128          
    129          	return (void*)0;
    130          }
    131          
    132          
    133          /**
    134          * @brief	将已经发送出去的缓存地址pull出来
    135          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    136          * @return   none
    137          */
    138          void pull_barcode_from_cash(unsigned char* barcode_addr)
    139          {
    140          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    141          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    142          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    143          
    144          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    145          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    146          	return;
    147          }
    148          
    149          
    150          
    151          /**
    152          * @brief	进入Memory模式时，需要进行的一些设置
    153          */
    154          static inline void enter_into_Memory_Mode(void)
    155          {
    156          #ifdef DEBUG_VER
    157          	printf("enter into Memory Mode\r\n");
    158          #endif
    159          	g_param.last_state = 1;
    160          	SaveTerminalPara();
    161          }
    162          
    163          /**
    164          * @brief	退出Memory模式时，需要进行的一些设置
    165          */
    166          static inline void exit_from_Memory_Mode(void)
    167          {
    168          #ifdef DEBUG_VER
    169          	printf("exit from Memory Mode\r\n");
    170          #endif
    171          	//@todo...
    172          }
    173          
    174          /**
    175          * @brief	进入USB HID模式时，需要进行的一些设置
    176          */
    177          static inline void enter_into_USB_HID_Mode(void)
    178          {
    179          #ifdef DEBUG_VER
    180          	printf("enter into USB HID Mode\r\n");
    181          #endif
    182          	hw_platform_led_ctrl(LED_RED,1);
    183          	//hw_platform_beep_ctrl(100,1045);
    184          	//hw_platform_beep_ctrl(100,1171);
    185          	//hw_platform_beep_ctrl(100,1316);
    186          	//hw_platform_beep_ctrl(100,1393);
    187          	//hw_platform_beep_ctrl(100,1563);
    188          	//hw_platform_beep_ctrl(100,1755);
    189          	//hw_platform_beep_ctrl(100,1971);
    190          
    191          	hw_platform_beep_ctrl(100,1316);
    192          	hw_platform_beep_ctrl(100,1316);
    193          	hw_platform_beep_ctrl(100,1393);
    194          	hw_platform_beep_ctrl(100,1563);
    195          	hw_platform_beep_ctrl(100,1563);
    196          	hw_platform_beep_ctrl(100,1393);
    197          	hw_platform_beep_ctrl(100,1316);
    198          	hw_platform_beep_ctrl(100,1171);
    199          }
    200          
    201          /**
    202          * @brief	退出USB HID模式时，需要进行的一些设置
    203          */
    204          static inline void exit_from_USB_HID_Mode(void)
    205          {
    206          #ifdef DEBUG_VER
    207          	printf("exit from USB HID Mode\r\n");
    208          #endif
    209          	hw_platform_led_ctrl(LED_RED,0);
    210          }
    211          
    212          /**
    213          * @brief	进入BT模式时，需要进行的一些设置
    214          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    215          */
    216          static inline void enter_into_BT_Mode(unsigned char child_state)
    217          {
    218          #ifdef DEBUG_VER
    219          	printf("enter into BT Mode:%d\r\n",child_state);
    220          #endif
    221          	if (child_state == 2)
    222          	{
    223          		WBTD_Reset();
    224          		hw_platform_beep_ctrl(300,3000);
    225          		hw_platform_start_led_blink(LED_BLUE,10);
    226          		WBTD_set_autocon(0);
    227          	}
    228          	else if (child_state == 0)
    229          	{
    230          		hw_platform_start_led_blink(LED_BLUE,300);
    231          	}
    232          	else
    233          	{
    234          		hw_platform_led_ctrl(LED_BLUE,1);
    235          	}
    236          	g_param.last_state = 0;
    237          	SaveTerminalPara();
    238          }
    239          
    240          /**
    241          * @brief	退出BT模式时，需要进行的一些设置
    242          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    243          */
    244          static inline void exit_from_BT_Mode(unsigned char child_state)
    245          {
    246          #ifdef DEBUG_VER
    247          	printf("exit from BT Mode:%d\r\n",child_state);
    248          #endif
    249          	if (child_state == 1)
    250          	{
    251          		WBTD_set_autocon(1);
    252          		//delay_ms(1);
    253          		hw_platform_beep_ctrl(300,3000);
    254          		hw_platform_led_ctrl(LED_BLUE,0);
    255          		WBTD_Reset();//主动断开与蓝牙主机的连接
    256          		
    257          	}
    258          	else
    259          	{
    260          		hw_platform_stop_led_blink(LED_BLUE);
    261          	}
    262          }
    263          
    264          
    265          /**
    266          * @brief	通过USB HID发送条码
    267          */
    268          static void barcode_hid_send(unsigned char* barcode)
    269          {
    270          	unsigned int	i,code_len;
    271          	unsigned char key_value_report[8];
    272          
    273              code_len = strlen((char const*)barcode);
    274          	OSSchedLock();
    275          	for (i = 0; i < code_len; i++)
    276          	{
    277          		ascii_to_keyreport(barcode[i],key_value_report);
    278          
    279          		SendData_To_PC(key_value_report, 3);
    280          		SendData_To_PC("\x00\x00\x00", 3);
    281          	}
    282          
    283          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    284          
    285          	SendData_To_PC(key_value_report, 3);
    286          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    287          	OSSchedUnlock();
    288          }
    289          
    290          /**
    291          * @brief	应用的初始化
    292          */
    293          void app_init(void)
    294          {
    295          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    296          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    297          	assert(pEvent_Queue != (OS_EVENT*)0);
    298          
    299          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    300          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    301          	assert(pBarcode_Queue != (OS_EVENT*)0);
    302          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    303          
    304          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    305          	pIOSem = OSSemCreate(0);
    306          	assert(pIOSem != (OS_EVENT*)0);
    307          
    308          	lowpower_state = 0;
    309          	lowpower_cnt = 0;
    310          }
    311          
    312          /**
    313          * @brief	维护主状态机的线程
    314          */
    315          void State_Machine_thread(void *p)
    316          {
    317          	unsigned int	i,cnt,event;
    318          	unsigned char	err;
    319          	unsigned char	barcode[MAX_BARCODE_LEN+1];
    320          	unsigned char   codetype[20];
    321          	unsigned int    codelen;
    322          	int				ret,index;
    323          	unsigned int	last_state;
    324          	unsigned char	*rec;
    325          
    326          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    327          
    328          	//hw_platform_led_blink_test();		//for test
    329          	//lowpower_tip();					//for test
    330          	//record_m_test();					//for test
    331          	
    332          	while(1)
    333          	{
    334          		event = (unsigned int)OSQPend(pEvent_Queue,25,&err);
    335          		if (event == 0)
    336          		{
    337          			if ((g_param.lower_power_timeout)&&(device_current_state != STATE_HID_Mode))
    338          			{
    339          				keypress_timeout++;
    340          				if (keypress_timeout == g_param.lower_power_timeout*4*60)
    341          				{
    342          					hw_platform_beep_ctrl(500,3000);
    343          					EnterLowPowerMode();
    344          					ExitLowPowerMode();
    345          				}
    346          			}
    347          			continue;
    348          		}
    349          #ifdef DEBUG_VER
    350          		printf("current state:%d\r\n",device_current_state);
    351          		printf("event:%d\r\n",event);
    352          #endif
    353          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    354          		{
    355          			switch(event)
    356          			{
    357          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    358          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    359          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    360          				hw_platform_stop_led_blink(LED_GREEN);
    361          				if (ret == 0)
    362          				{
    363          					scan_barcode_ok_tip();
    364          				}
    365          
    366          				if (lowpower_state)
    367          				{
    368          					lowpower_tip();
    369          				}
    370          				//只是扫描到条码而已，什么都不做
    371          				break;
    372          			case EVENT_SCAN_KEY_LONG_PRESS:
    373          				//切换到Memory Mode
    374          				hw_platform_stop_led_blink(LED_GREEN);
    375          				exit_from_BT_Mode(0);
    376          				device_current_state = STATE_Memory_Mode;
    377          				hw_platform_beep_ctrl(300,3000);
    378          				enter_into_Memory_Mode();
    379          				break;
    380          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    381          				break;
    382          			case EVENT_ERASE_KEY_LONG_PRESS:
    383          				//切换到配对模式
    384          				exit_from_BT_Mode(0);
    385          				device_current_state = STATE_BT_Mode_WaitPair;
    386          				enter_into_BT_Mode(2);
    387          				break;
    388          			case EVENT_RESET_KEY_PRESS:
    389          				break;
    390          			case EVENT_BT_CONNECTED:
    391          				//切换到蓝牙连接模式
    392          				exit_from_BT_Mode(0);
    393          				device_current_state = STATE_BT_Mode_Connect;
    394          				enter_into_BT_Mode(1);
    395          				break;
    396          			case EVENT_BT_DISCONNECTED:
    397          				break;
    398          			case EVENT_USB_CABLE_INSERT:
    399          				//切换到USB HID模式
    400          				exit_from_BT_Mode(0);
    401          				last_state = STATE_BT_Mode_Disconnect;
    402          				device_current_state = STATE_HID_Mode;
    403          				enter_into_USB_HID_Mode();
    404          				break;
    405          			case EVENT_USB_CABLE_REMOVE:
    406          				break;
    407          			case EVENT_LOW_POWER:
    408          				lowpower_tip();
    409          				break;
    410          			default:
    411          				break;
    412          			}
    413          		}
    414          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    415          		{
    416          			switch(event)
    417          			{
    418          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    419          				//扫描条码
    420          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    421          				hw_platform_stop_led_blink(LED_GREEN);
    422          				if (ret != 0)
    423          				{
    424          					break;
    425          				}
    426          
    427          				scan_barcode_ok_tip();
    428          				if (lowpower_state)
    429          				{
    430          					lowpower_tip();
    431          				}
    432          				//扫描到条码了
    433          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    434          				//Queue，由蓝牙模块线程负责去发送到主机
    435          repost:
    436          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode));
    437          				if(ret != OS_ERR_NONE)
    438          				{
    439          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    440          					{
    441          						//如果队列满了或者空事件时，那么需要延时重试
    442          						OSTimeDlyHMSM(0,0,0,100);
    443          						goto repost;
    444          					}
    445          					else
    446          					{
    447          						assert(0);	//系统错误
    448          					}
    449          				}
    450          				break;
    451          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    452          				if (g_param.ios_softkeypad_enable)
    453          				{
    454          					WBTD_set_ioskeypad(1);
    455          				}
    456          				break;
    457          			case EVENT_SCAN_KEY_LONG_PRESS:
    458          				hw_platform_stop_led_blink(LED_GREEN);
    459          				//切换到Memory mode
    460          				exit_from_BT_Mode(1);
    461          				device_current_state = STATE_Memory_Mode;
    462          				hw_platform_beep_ctrl(300,3000);
    463          				enter_into_Memory_Mode();
    464          				break;
    465          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    466          				//WBTD_hid_send_test();
    467          				break;
    468          			case EVENT_ERASE_KEY_LONG_PRESS:
    469          				//进入配对模式
    470          				exit_from_BT_Mode(1);
    471          				device_current_state = STATE_BT_Mode_WaitPair;
    472          				enter_into_BT_Mode(2);
    473          				break;
    474          			case EVENT_RESET_KEY_PRESS:
    475          				//@todo...
    476          				break;
    477          			case EVENT_BT_CONNECTED:
    478          				break;
    479          			case EVENT_BT_DISCONNECTED:
    480          				//切换到蓝牙断开状态
    481          				exit_from_BT_Mode(1);
    482          				device_current_state = STATE_BT_Mode_Disconnect;
    483          				enter_into_BT_Mode(0);
    484          				break;
    485          			case EVENT_USB_CABLE_INSERT:
    486          				//切换到USB HID模式
    487          				exit_from_BT_Mode(1);
    488          				last_state = STATE_BT_Mode_Disconnect;
    489          				device_current_state = STATE_HID_Mode;
    490          				enter_into_USB_HID_Mode();
    491          				break;
    492          			case EVENT_USB_CABLE_REMOVE:
    493          				break;
    494          			case EVENT_LOW_POWER:
    495          				lowpower_tip();
    496          				break;
    497          			default:
    498          				break;
    499          			}
    500          		}
    501          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    502          		{
    503          			switch(event)
    504          			{
    505          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    506          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    507          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    508          				hw_platform_stop_led_blink(LED_GREEN);
    509          				if (ret == 0)
    510          				{
    511          					scan_barcode_ok_tip();
    512          				}
    513          				if (lowpower_state)
    514          				{
    515          					lowpower_tip();
    516          				}
    517          				//只是扫描到条码而已，什么都不做
    518          				break;
    519          			case EVENT_SCAN_KEY_LONG_PRESS:
    520          				hw_platform_stop_led_blink(LED_GREEN);
    521          				//切换到Memory Mode
    522          				exit_from_BT_Mode(2);
    523          				device_current_state = STATE_Memory_Mode;
    524          				hw_platform_beep_ctrl(300,3000);
    525          				enter_into_Memory_Mode();
    526          				break;
    527          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    528          				break;
    529          			case EVENT_ERASE_KEY_LONG_PRESS:
    530          				//已经是配对模式，什么都不做
    531          				break;
    532          			case EVENT_RESET_KEY_PRESS:
    533          				//@todo...
    534          				break;
    535          			case EVENT_BT_CONNECTED:
    536          				//切换到蓝牙连接状态
    537          				exit_from_BT_Mode(2);
    538          				device_current_state = STATE_BT_Mode_Connect;
    539          				enter_into_BT_Mode(1);
    540          				break;
    541          			case EVENT_BT_DISCONNECTED:
    542          				break;
    543          			case EVENT_USB_CABLE_INSERT:
    544          				//切换到USB HID模式
    545          				exit_from_BT_Mode(2);
    546          				last_state = STATE_BT_Mode_WaitPair;
    547          				device_current_state = STATE_HID_Mode;
    548          				enter_into_USB_HID_Mode();
    549          				break;
    550          			case EVENT_USB_CABLE_REMOVE:
    551          				break;
    552          			case EVENT_LOW_POWER:
    553          				lowpower_tip();
    554          				break;
    555          			default:
    556          				break;
    557          			}
    558          		}
    559          		else if(device_current_state ==  STATE_Memory_Mode)
    560          		{
    561          			switch(event)
    562          			{
    563          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    564          				//扫描条码
    565          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    566          				hw_platform_stop_led_blink(LED_GREEN);
    567          				if (ret != 0)
    568          				{
    569          					break;
    570          				}
    571          
    572          				scan_barcode_ok_tip();
    573          				if (lowpower_state)
    574          				{
    575          					lowpower_tip();
    576          				}
    577          				//扫描到条码了
    578          				//将获取到的条码保存到memory
    579          				memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    580          				strcpy((char*)batch_node.barcode,(char const*)barcode);
    581          				ret = record_add((unsigned char*)&batch_node);
    582          				if (ret)
    583          				{
    584          					//记录保存失败，给出提示给用户
    585          					//@todo...
    586          
    587          				}
    588          				break;
    589          			case EVENT_SCAN_KEY_LONG_PRESS:
    590          				hw_platform_stop_led_blink(LED_GREEN);
    591          				//切换至蓝牙模式
    592          				exit_from_Memory_Mode();
    593          				device_current_state = STATE_BT_Mode_Disconnect;
    594          				enter_into_BT_Mode(0);
    595          				break;
    596          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    597          				//删除扫到的条码对应的最后一笔资料
    598          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    599          				if (ret != 0)
    600          				{
    601          					break;
    602          				}
    603          				scan_barcode_ok_tip();
    604          				if (lowpower_state)
    605          				{
    606          					lowpower_tip();
    607          				}
    608          				rec = rec_searchby_tag(barcode,&index);
    609          				if (rec)
    610          				{
    611          					ret = delete_one_node(index);
    612          					if (ret)
    613          					{
    614          						//提示用户，删除失败
    615          						//@todo...
    616          					}
    617          				}
    618          				break;
    619          			case EVENT_ERASE_KEY_LONG_PRESS:
    620          				//删除所有的条码记录
    621          				ret = record_clear();
    622          				if (ret)
    623          				{
    624          					//提示用户，删除失败
    625          					//@todo...
    626          				}
    627          				hw_platform_beep_ctrl(300,3000);
    628          				break;
    629          			case EVENT_RESET_KEY_PRESS:
    630          				//@todo...
    631          				break;
    632          			case EVENT_BT_CONNECTED:
    633          				break;
    634          			case EVENT_BT_DISCONNECTED:
    635          				break;
    636          			case EVENT_USB_CABLE_INSERT:
    637          				//切换到USB HID模式
    638          				exit_from_Memory_Mode();
    639          				last_state = STATE_Memory_Mode;
    640          				device_current_state = STATE_HID_Mode;
    641          				enter_into_USB_HID_Mode();
    642          				break;
    643          			case EVENT_USB_CABLE_REMOVE:
    644          				break;
    645          			case EVENT_LOW_POWER:
    646          				lowpower_tip();
    647          				break;
    648          			default:
    649          				break;
    650          			}
    651          		}
    652          		else if(device_current_state ==  STATE_HID_Mode)
    653          		{
    654          			switch(event)
    655          			{
    656          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    657          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    658          				hw_platform_stop_led_blink(LED_GREEN);
    659          				if(ret !=0)	//扫描条码
    660          				{
    661          					break;
    662          				}
    663          
    664          				scan_barcode_ok_tip();
    665          				//将扫描到的条码通过HID 接口发送出去
    666          				barcode_hid_send(barcode);
    667          				break;
    668          			case EVENT_SCAN_KEY_LONG_PRESS:
    669          				hw_platform_stop_led_blink(LED_GREEN);
    670          				break;
    671          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    672          				break;
    673          			case EVENT_ERASE_KEY_LONG_PRESS:
    674          				//将所有保存在Memory中的条码，全部上传到PC
    675          				hw_platform_beep_ctrl(300,3000);
    676          				cnt = record_module_count();
    677          				for (i = 0; i < cnt;i++)
    678          				{
    679          					rec = get_node((i==0)?0:2,0);
    680          					if (rec)
    681          					{
    682          						barcode_hid_send(((TBATCH_NODE*)rec)->barcode);
    683          					}
    684          					else
    685          					{
    686          						//提示用户读取失败一次
    687          						//@todo...
    688          					}
    689          				}
    690          				hw_platform_beep_ctrl(300,3000);
    691          				break;
    692          			case EVENT_RESET_KEY_PRESS:
    693          				//@todo...
    694          				break;
    695          			case EVENT_BT_CONNECTED:
    696          				break;
    697          			case EVENT_BT_DISCONNECTED:
    698          				break;
    699          			case EVENT_USB_CABLE_INSERT:
    700          				break;
    701          			case EVENT_USB_CABLE_REMOVE:
    702          				//切换到之前的状态
    703          				exit_from_USB_HID_Mode();
    704          				device_current_state = last_state;
    705          				if (device_current_state == STATE_Memory_Mode)
    706          				{
    707          					enter_into_Memory_Mode();
    708          				}
    709          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    710          				{
    711          					enter_into_BT_Mode(2);
    712          				}
    713          				else
    714          				{
    715          					enter_into_BT_Mode(0);
    716          				}
    717          				break;
    718          			case EVENT_LOW_POWER:
    719          				break;
    720          			default:
    721          				break;
    722          			}
    723          		}
    724          	}
    725          }
    726          
    727          /**
    728          * @brief	获取部分异步事件的线程
    729          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    730          *			比如：按键事件会在定时器中断的服务程序post出来
    731          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    732          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    733          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    734          */
    735          void Event_capture_thread(void *p)
    736          {
    737          #ifdef DEBUG_VER
    738          	printf("Enter into Event_capture_thread!\r\n");
    739          #endif
    740          	while (1)
    741          	{
    742          		if (device_current_state == STATE_HID_Mode)
    743          		{
    744          			lowpower_state = 0;
    745          			lowpower_cnt = 0;
    746          			//判断USB线的拔出
    747          			if (bDeviceState == UNCONNECTED)
    748          			{
    749          #ifdef DEBUG_VER
    750          				printf("usb cable remove detected!\r\n");
    751          #endif
    752          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    753          			}
    754          
    755          			if (hw_platform_ChargeState_Detect())
    756          			{
    757          				//充电完成
    758          				hw_platform_led_ctrl(LED_RED,0);
    759          			}
    760          
    761          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    762          		}
    763          		else
    764          		{
    765          			//判断电池电量低
    766          			if (hw_platform_get_PowerClass() == 0)
    767          			{
    768          				lowpower_cnt++;
    769          				if (lowpower_cnt>10)
    770          				{
    771          #ifdef DEBUG_VER
    772          					printf("low power detected!\r\n");
    773          #endif
    774          					if (lowpower_state == 0)
    775          					{
    776          						OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    777          						lowpower_state = 1;
    778          					}
    779          					
    780          				}
    781          			}
    782          			else
    783          			{
    784          				lowpower_cnt = 0;
    785          			}
    786          
    787          			if (bDeviceState == CONFIGURED)
    788          			{
    789          #ifdef DEBUG_VER
    790          				printf("USB HID Enum OK detected!\r\n");
    791          #endif
    792          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_INSERT);
    793          			}
    794          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    795          		}
    796          	}
    797          }
    798          
    799          
    800          /*
    801           * @brief 蓝牙模块维护线程
    802           * @note  此线程需要完成两个任务：
    803           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    804           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    805          */
    806          void BT_Daemon_thread(void *p)
    807          {
    808          	int ret;
    809                  unsigned int len;
    810          	unsigned char	err;
    811          	unsigned char	*pbarcode;
    812          
    813          	ret = WBTD_init();
    814          	if (ret)
    815          	{
    816          		WBTD_Reset();
    817          		ret = WBTD_init();
    818          		assert(ret == 0);
    819          	}
    820          
    821          #ifdef DEBUG_VER
    822          	printf("WBTD init Success!\r\n");
    823          #endif
    824          
    825          	while (1)
    826          	{
    827          		ret = WBTD_got_notify_type();
    828          		if ((ret == 1) || (ret == 2))
    829          		{
    830          #ifdef DEBUG_VER
    831          			printf("WBTD got notify = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    832          #endif
    833          			OSQPost(pEvent_Queue,(void*)((ret == 1)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    834          		}
    835          
    836          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    837          		if (pbarcode)
    838          		{
    839          #ifdef DEBUG_VER
    840          			printf("WBTD got data(%s) to send!\r\n",pbarcode);
    841          #endif
    842          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    843          			{
    844          				//发送失败应该怎么处理，什么都不做了么????!!!!
    845          				//@todo...
    846          #ifdef DEBUG_VER
    847          				printf("WBTD send data Fail!\r\n");
    848          #endif
    849          			}
    850          
    851          			pull_barcode_from_cash(pbarcode);
    852          			//OSTimeDlyHMSM(0,0,0,50);
    853          
    854          #ifdef DEBUG_VER
    855          			printf("WBTD send data Success!\r\n");
    856          #endif
    857          		}
    858          	}
    859          }
    860          
    861          
    862          /*
    863           * @brief进入U盘模式
    864          */
    865          void u_disk_proc(void)
    866          {
    867          	//g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
    868          	//usb_device_init(USB_MASSSTORAGE);
    869          
    870          	OSSchedLock();
    871          
    872          	while(hw_platform_USBcable_Insert_Detect() == 1)
    873          	{	
    874          		if(bDeviceState != CONFIGURED)
    875          		{
    876          			break;
    877          		}
    878          
    879          		delay_ms(1);
    880          	}
    881          
    882          	OSSchedUnlock();
    883          }
    884          
    885          /*
    886           * @brief 低电量提示,红灯持续5S的闪烁
    887           * @return 0:提示期间没有USB线的插入		1:提示期间有USB线的插入
    888          */
    889          int lowpower_tip(void)
    890          {
    891          	int i;
    892          	OSSchedLock();
    893          	hw_platform_start_led_blink(LED_RED,5);
    894          	for (i = 0; i<20;i++)
    895          	{
    896          		hw_platform_beep_ctrl(50,1000);
    897          		if (hw_platform_USBcable_Insert_Detect())
    898          		{
    899          			hw_platform_stop_led_blink(LED_RED);
    900          			OSSchedUnlock();
    901          			return 1;
    902          		}
    903          	}
    904          	hw_platform_stop_led_blink(LED_RED);
    905          	OSSchedUnlock();
    906          	return 0;
    907          }
    908          
    909          /*
    910           * @brief 系统错误的提示
    911          */
    912          void system_err_tip(void)
    913          {
    914          	while(1)
    915          	{
    916          		//@todo...
    917          	}
    918          }
    919          
    920          
    921          // Cortex System Control register address
    922          #define SCB_SysCtrl					((u32)0xE000ED10)
    923          // SLEEPDEEP bit mask
    924          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
    925          
    926          /*
    927           * @brief 初始化线程
    928           */
    929          void app_init_thread(void *p)
    930          {
    931          	int ret;
    932          #ifdef DEBUG_VER
    933          	printf("app init thread startup...\r\n");
    934          #endif
    935          
    936          	OS_CPU_SysTickInit();
    937          
    938          	app_init();
    939          
    940          	Keypad_Init();
    941          
    942          	ret = record_module_init();
    943          	if (ret != 0)
    944          	{
    945          		system_err_tip();
    946          	}
    947          
    948          	if (recover_record_by_logfile())
    949          	{
    950          		system_err_tip();
    951          	}
    952          
    953          	if (ReadTerminalPara())
    954          	{
    955          		if (DefaultTerminalPara())
    956          		{
    957          			system_err_tip();
    958          		}
    959          	}
    960          
    961          	if (g_param.last_state == 1)
    962          	{
    963          		device_current_state = STATE_Memory_Mode;	//脱机状态
    964          		enter_into_Memory_Mode();
    965          	}
    966          	else
    967          	{
    968          		device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
    969          		enter_into_BT_Mode(0);
    970          	}
    971          
    972          	scanner_mod_init();
    973          
    974          	usb_device_init(USB_KEYBOARD);
    975          
    976          	OSTaskCreateExt(State_Machine_thread,
    977          		(void *)0,
    978          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
    979          		8,
    980          		8,
    981          		&thread_statemachine_stk[0],
    982          		STACK_SIZE_TASKSM,
    983          		(void *)0,
    984          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    985          
    986          	OSTaskCreateExt(Event_capture_thread,
    987          		(void *)0,
    988          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
    989          		7,
    990          		7,
    991          		&thread_eventcapture_stk[0],
    992          		STACK_SIZE_TASKEC,
    993          		(void *)0,
    994          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    995          
    996          	OSTaskCreateExt(BT_Daemon_thread,
    997          		(void *)0,
    998          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
    999          		6,
   1000          		6,
   1001          		&thread_bt_stk[0],
   1002          		STACK_SIZE_TASKBT,
   1003          		(void *)0,
   1004          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1005          
   1006          	OSTimeDlyHMSM(0,0,0,10);
   1007          	OSTaskDel(OS_PRIO_SELF);
   1008          }
   1009          
   1010          /*
   1011           * @brief 启动应用
   1012           */
   1013          void app_startup(void)
   1014          {
   1015          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
   1016          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
   1017          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
   1018          
   1019          	OSInit();
   1020          
   1021          	OSDebugInit();
   1022          
   1023          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI*sizeof(OS_STK));
   1024          	assert(p_init_thread_stk != 0);
   1025          
   1026          	OSTaskCreateExt(app_init_thread,
   1027          		(void *)0,
   1028          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
   1029          		5,
   1030          		5,
   1031          		&p_init_thread_stk[0],
   1032          		STACK_SIZE_TASKINI,
   1033          		(void *)0,
   1034          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1035          
   1036          	OSStart();
   1037          }
   1038          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            24
     Event_capture_thread         8
     State_Machine_thread       136
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           8
     enter_into_Memory_Mode       8
     enter_into_USB_HID_Mode      8
     exit_from_BT_Mode            8
     exit_from_Memory_Mode        0
     exit_from_USB_HID_Mode       8
     lowpower_tip                 8
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     scan_barcode_ok_tip          8
     system_err_tip               0
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1424
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  60
     barcode_cash                                1232
     lowpower_state                                 1
     lowpower_cnt                                   1
     batch_node                                    84
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     keypress_timeout                               4
     scan_barcode_ok_tip                           42
     push_barcode_into_cash                       114
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                        16
     exit_from_Memory_Mode                          2
     enter_into_USB_HID_Mode                       92
     exit_from_USB_HID_Mode                        12
     enter_into_BT_Mode                            80
     exit_from_BT_Mode                             48
     barcode_hid_send                              92
     app_init                                     176
     State_Machine_thread                        1312
     Event_capture_thread                         160
     BT_Daemon_thread                             120
     u_disk_proc                                   38
     lowpower_tip                                  70
     system_err_tip                                 2
     app_init_thread                              236
     app_startup                                  136
     ??DataTable19                                  4
     ??DataTable67                                  4
     ??DataTable70                                  4
     ??DataTable72                                  4
     ??DataTable73                                  4
     ??DataTable74                                  4
     ??DataTable75                                  4
     ??DataTable77                                  4
     ??DataTable81                                  4
     ??DataTable82                                  4
     ??DataTable83                                  4
     ??DataTable86                                  4
     ??DataTable88                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "0">                                2
     ?<Constant "ret == 0">                        12
     ?<Constant "p_init_thread_stk != 0">          24

 
 3 882 bytes in section .bss
   334 bytes in section .rodata
 2 942 bytes in section .text
 
 2 908 bytes of CODE  memory (+ 34 bytes shared)
   334 bytes of CONST memory
 3 882 bytes of DATA  memory

Errors: none
Warnings: none
