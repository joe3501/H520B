###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     23/Sep/2015  16:12:46 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -D DEBUG_VER -lcN              #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record.h"
     28          #include "Terminal_Para.h"
     29          #include "usb_lib.h"
     30          #include "PCUsart.h"
     31          
     32          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     33          #define BARCODE_CASH_NUM	15			//定义等待蓝牙模块线程发送的条码缓冲区为15个条码
     34          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     35          
     36          //define the stack size of each task
     37          #define STACK_SIZE_TASKEC			128	
     38          #define STACK_SIZE_TASKSM			256
     39          #define STACK_SIZE_TASKBT			128
     40          #define STACK_SIZE_TASKINI			64
     41          
     42          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     43          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     44          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     45          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     46          
     47          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     48          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     49          /*
     50          ------------------------------------------------------------
     51          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     52          ------------------------------------------------------------
     53          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     54          ------------------------------------------------------------
     55          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     56          ------------------------------------------------------------
     57          .........
     58          ------------------------------------------------------------
     59          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     60          ------------------------------------------------------------
     61          */
     62          //定义条码的静态缓冲区，以免动态分配内存
     63          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     64          
     65          
     66          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     67          //定义事件监测线程与主状态机之间通讯的IPC对象
     68          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     69          OS_EVENT	*pEvent_Queue;			//事件消息队列
     70          
     71          static OS_EVENT *pIOSem;				//IO信号量
     72          //
     73          
     74          unsigned int	device_current_state;		//设备主状态机
     75          
     76          unsigned int	keypress_timeout;
     77          
     78          
     79          void u_disk_proc(void);
     80          int lowpower_tip(void);
     81          void system_err_tip(void);
     82          
     83          extern void EnterLowPowerMode(void);
     84          extern void ExitLowPowerMode(void);
     85          /**
     86          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
     87          * @param[in] unsigned char* barcode				需要缓存的条码
     88          * @param[in] unsigned char	ios_keypad_flag     是否需要唤取IOS softkeypad
     89          * @return   缓存的地址
     90          * @note 策略:只要找到一个空位置就放进去，每一列的最有一个字节为0表示该位置是空的
     91          *											     最后一个字节0x55表示该位置已经缓存了条码
     92          */
     93          unsigned char * push_barcode_into_cash(unsigned char* barcode,unsigned char	ios_keypad_flag)
     94          {
     95          	unsigned int	i;
     96          	for (i = 0; i < BARCODE_CASH_NUM;i++)
     97          	{
     98          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
     99          		{
    100          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
    101          			{
    102          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
    103          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
    104          			}
    105          			else
    106          			{
    107          				strcpy((char*)barcode_cash[i],(char const*)barcode);
    108          			}
    109          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
    110          			if (ios_keypad_flag)
    111          			{
    112          				barcode_cash[i][MAX_BARCODE_LEN+1] |= 0xF0;
    113          			}
    114          			return (void*)barcode_cash[i];
    115          		}
    116          	}
    117          
    118          	return (void*)0;
    119          }
    120          
    121          
    122          /**
    123          * @brief	将已经发送出去的缓存地址pull出来
    124          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    125          * @return   none
    126          */
    127          void pull_barcode_from_cash(unsigned char* barcode_addr)
    128          {
    129          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    130          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    131          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    132          
    133          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    134          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    135          	return;
    136          }
    137          
    138          
    139          
    140          /**
    141          * @brief	进入Memory模式时，需要进行的一些设置
    142          */
    143          static inline void enter_into_Memory_Mode(void)
    144          {
    145          #ifdef DEBUG_VER
    146          	printf("enter into Memory Mode\r\n");
    147          #endif
    148          	//@todo...
    149          }
    150          
    151          /**
    152          * @brief	退出Memory模式时，需要进行的一些设置
    153          */
    154          static inline void exit_from_Memory_Mode(void)
    155          {
    156          #ifdef DEBUG_VER
    157          	printf("exit from Memory Mode\r\n");
    158          #endif
    159          	//@todo...
    160          }
    161          
    162          /**
    163          * @brief	进入USB HID模式时，需要进行的一些设置
    164          */
    165          static inline void enter_into_USB_HID_Mode(void)
    166          {
    167          #ifdef DEBUG_VER
    168          	printf("enter into USB HID Mode\r\n");
    169          #endif
    170          	hw_platform_led_ctrl(LED_RED,1);
    171          }
    172          
    173          /**
    174          * @brief	退出USB HID模式时，需要进行的一些设置
    175          */
    176          static inline void exit_from_USB_HID_Mode(void)
    177          {
    178          #ifdef DEBUG_VER
    179          	printf("exit from USB HID Mode\r\n");
    180          #endif
    181          	hw_platform_led_ctrl(LED_RED,0);
    182          }
    183          
    184          /**
    185          * @brief	进入BT模式时，需要进行的一些设置
    186          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    187          */
    188          static inline void enter_into_BT_Mode(unsigned char child_state)
    189          {
    190          #ifdef DEBUG_VER
    191          	printf("enter into BT Mode:%d\r\n",child_state);
    192          #endif
    193          	if (child_state == 2)
    194          	{
    195          		WBTD_Reset();
    196          		WBTD_set_autocon(0);
    197          	}
    198          }
    199          
    200          /**
    201          * @brief	退出BT模式时，需要进行的一些设置
    202          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    203          */
    204          static inline void exit_from_BT_Mode(unsigned char child_state)
    205          {
    206          #ifdef DEBUG_VER
    207          	printf("exit from BT Mode:%d\r\n",child_state);
    208          #endif
    209          	if (child_state == 1)
    210          	{
    211          		WBTD_set_autocon(1);
    212          		Delay(2000);
    213          		WBTD_Reset();//主动断开与蓝牙主机的连接
    214          	}
    215          }
    216          
    217          
    218          /**
    219          * @brief	通过USB HID发送条码
    220          */
    221          static void barcode_hid_send(unsigned char* barcode)
    222          {
    223          	unsigned int	i,code_len;
    224          	unsigned char key_value_report[8];
    225          
    226                  code_len = strlen((char const*)barcode);
    227          	OSSchedLock();
    228          	for (i = 0; i < code_len; i++)
    229          	{
    230          		ascii_to_keyreport(barcode[i],key_value_report);
    231          
    232          		SendData_To_PC(key_value_report, 3);
    233          		SendData_To_PC("\x00\x00\x00", 3);
    234          	}
    235          
    236          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    237          
    238          	SendData_To_PC(key_value_report, 3);
    239          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    240          	OSSchedUnlock();
    241          }
    242          
    243          /**
    244          * @brief	应用的初始化
    245          */
    246          void app_init(void)
    247          {
    248          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    249          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    250          	assert(pEvent_Queue != (OS_EVENT*)0);
    251          
    252          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    253          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    254          	assert(pBarcode_Queue != (OS_EVENT*)0);
    255          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    256          
    257          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    258          	pIOSem = OSSemCreate(0);
    259          	assert(pIOSem != (OS_EVENT*)0);
    260          	device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
    261          }
    262          
    263          /**
    264          * @brief	维护主状态机的线程
    265          */
    266          void State_Machine_thread(void *p)
    267          {
    268          	unsigned int	i,cnt,event;
    269          	unsigned char	err;
    270          	unsigned char	barcode[MAX_BARCODE_LEN+1];
    271          	unsigned char   codetype[20];
    272          	unsigned int    codelen;
    273          	int				ret,index;
    274          	unsigned int	last_state;
    275          	unsigned char	*rec;
    276          
    277          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    278          
    279          	while(1)
    280          	{
    281          		event = (unsigned int)OSQPend(pEvent_Queue,25,&err);
    282          		if (event == 0)
    283          		{
    284          			if ((g_param.lower_power_timeout)&&(device_current_state != STATE_HID_Mode))
    285          			{
    286          				keypress_timeout++;
    287          				if (keypress_timeout == g_param.lower_power_timeout*40)
    288          				{
    289          					hw_platform_beep_ctrl(500,3000);
    290          					EnterLowPowerMode();
    291          					ExitLowPowerMode();
    292          				}
    293          			}
    294          			continue;
    295          		}
    296          #ifdef DEBUG_VER
    297          		printf("current state:%d\r\n",device_current_state);
    298          		printf("event:%d\r\n",event);
    299          #endif
    300          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    301          		{
    302          			switch(event)
    303          			{
    304          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    305          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    306          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    307          				hw_platform_stop_led_blink();
    308          				if (ret == 0)
    309          				{
    310          					hw_platform_led_ctrl(LED_YELLOW,1);
    311          					OSTimeDlyHMSM(0,0,0,50);
    312          					hw_platform_led_ctrl(LED_YELLOW,0);
    313          				}
    314          
    315          				//只是扫描到条码而已，什么都不做
    316          				break;
    317          			case EVENT_SCAN_KEY_LONG_PRESS:
    318          				//切换到Memory Mode
    319          				hw_platform_stop_led_blink();
    320          				exit_from_BT_Mode(0);
    321          				device_current_state = STATE_Memory_Mode;
    322          				enter_into_Memory_Mode();
    323          				break;
    324          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    325          				break;
    326          			case EVENT_ERASE_KEY_LONG_PRESS:
    327          				//切换到配对模式
    328          				exit_from_BT_Mode(0);
    329          				device_current_state = STATE_BT_Mode_WaitPair;
    330          				enter_into_BT_Mode(2);
    331          				break;
    332          			case EVENT_RESET_KEY_PRESS:
    333          				break;
    334          			case EVENT_BT_CONNECTED:
    335          				//切换到蓝牙连接模式
    336          				exit_from_BT_Mode(0);
    337          				device_current_state = STATE_BT_Mode_Connect;
    338          				enter_into_BT_Mode(1);
    339          				break;
    340          			case EVENT_BT_DISCONNECTED:
    341          				break;
    342          			case EVENT_USB_CABLE_INSERT:
    343          				//切换到USB HID模式
    344          				exit_from_BT_Mode(0);
    345          				last_state = STATE_BT_Mode_Disconnect;
    346          				device_current_state = STATE_HID_Mode;
    347          				enter_into_USB_HID_Mode();
    348          				break;
    349          			case EVENT_USB_CABLE_REMOVE:
    350          				break;
    351          			case EVENT_LOW_POWER:
    352          				//@todo...
    353          				break;
    354          			default:
    355          				break;
    356          			}
    357          		}
    358          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    359          		{
    360          			switch(event)
    361          			{
    362          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    363          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    364          				//扫描条码
    365          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    366          				hw_platform_stop_led_blink();
    367          				if (ret != 0)
    368          				{
    369          					break;
    370          				}
    371          
    372          				hw_platform_led_ctrl(LED_YELLOW,1);
    373          				OSTimeDlyHMSM(0,0,0,50);
    374          				hw_platform_led_ctrl(LED_YELLOW,0);
    375          				//扫描到条码了
    376          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    377          				//Queue，由蓝牙模块线程负责去发送到主机
    378          repost:
    379          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode,(event == EVENT_SCAN_KEY_SINGLE_CLICK)?0:1));
    380          				if(ret != OS_ERR_NONE)
    381          				{
    382          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    383          					{
    384          						//如果队列满了或者空事件时，那么需要延时重试
    385          						OSTimeDlyHMSM(0,0,0,100);
    386          						goto repost;
    387          					}
    388          					else
    389          					{
    390          						assert(0);	//系统错误
    391          					}
    392          				}
    393          				break;
    394          			case EVENT_SCAN_KEY_LONG_PRESS:
    395          				hw_platform_stop_led_blink();
    396          				//切换到Memory mode
    397          				exit_from_BT_Mode(1);
    398          				device_current_state = STATE_Memory_Mode;
    399          				enter_into_Memory_Mode();
    400          				break;
    401          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    402          				break;
    403          			case EVENT_ERASE_KEY_LONG_PRESS:
    404          				//进入配对模式
    405          				exit_from_BT_Mode(1);
    406          				device_current_state = STATE_BT_Mode_WaitPair;
    407          				enter_into_BT_Mode(2);
    408          				break;
    409          			case EVENT_RESET_KEY_PRESS:
    410          				//@todo...
    411          				break;
    412          			case EVENT_BT_CONNECTED:
    413          				break;
    414          			case EVENT_BT_DISCONNECTED:
    415          				//切换到蓝牙断开状态
    416          				exit_from_BT_Mode(1);
    417          				device_current_state = STATE_BT_Mode_Disconnect;
    418          				enter_into_BT_Mode(0);
    419          				break;
    420          			case EVENT_USB_CABLE_INSERT:
    421          				//切换到USB HID模式
    422          				exit_from_BT_Mode(1);
    423          				last_state = STATE_BT_Mode_Disconnect;
    424          				device_current_state = STATE_HID_Mode;
    425          				enter_into_USB_HID_Mode();
    426          				break;
    427          			case EVENT_USB_CABLE_REMOVE:
    428          				break;
    429          			case EVENT_LOW_POWER:
    430          				//@todo...
    431          				break;
    432          			default:
    433          				break;
    434          			}
    435          		}
    436          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    437          		{
    438          			switch(event)
    439          			{
    440          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    441          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    442          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    443          				hw_platform_stop_led_blink();
    444          				if (ret == 0)
    445          				{
    446          					hw_platform_led_ctrl(LED_YELLOW,1);
    447          					OSTimeDlyHMSM(0,0,0,50);
    448          					hw_platform_led_ctrl(LED_YELLOW,0);
    449          				}
    450          				//只是扫描到条码而已，什么都不做
    451          				break;
    452          			case EVENT_SCAN_KEY_LONG_PRESS:
    453          				hw_platform_stop_led_blink();
    454          				//切换到Memory Mode
    455          				exit_from_BT_Mode(2);
    456          				device_current_state = STATE_Memory_Mode;
    457          				enter_into_Memory_Mode();
    458          				break;
    459          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    460          				break;
    461          			case EVENT_ERASE_KEY_LONG_PRESS:
    462          				//已经是配对模式，什么都不做
    463          				break;
    464          			case EVENT_RESET_KEY_PRESS:
    465          				//@todo...
    466          				break;
    467          			case EVENT_BT_CONNECTED:
    468          				//切换到蓝牙连接状态
    469          				exit_from_BT_Mode(2);
    470          				device_current_state = STATE_BT_Mode_Connect;
    471          				enter_into_BT_Mode(1);
    472          				break;
    473          			case EVENT_BT_DISCONNECTED:
    474          				break;
    475          			case EVENT_USB_CABLE_INSERT:
    476          				//切换到USB HID模式
    477          				exit_from_BT_Mode(2);
    478          				last_state = STATE_BT_Mode_WaitPair;
    479          				device_current_state = STATE_HID_Mode;
    480          				enter_into_USB_HID_Mode();
    481          				break;
    482          			case EVENT_USB_CABLE_REMOVE:
    483          				break;
    484          			case EVENT_LOW_POWER:
    485          				//@todo...
    486          				break;
    487          			default:
    488          				break;
    489          			}
    490          		}
    491          		else if(device_current_state ==  STATE_Memory_Mode)
    492          		{
    493          			switch(event)
    494          			{
    495          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    496          				//扫描条码
    497          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    498          				hw_platform_stop_led_blink();
    499          				if (ret != 0)
    500          				{
    501          					break;
    502          				}
    503          
    504          				hw_platform_led_ctrl(LED_YELLOW,1);
    505          				OSTimeDlyHMSM(0,0,0,50);
    506          				hw_platform_led_ctrl(LED_YELLOW,0);
    507          				//扫描到条码了
    508          				//将获取到的条码保存到memory
    509          				ret = record_add(barcode);
    510          				if (ret)
    511          				{
    512          					//记录保存失败，给出提示给用户
    513          					//@todo...
    514          
    515          				}
    516          				break;
    517          			case EVENT_SCAN_KEY_LONG_PRESS:
    518          				hw_platform_stop_led_blink();
    519          				//切换至蓝牙模式
    520          				exit_from_Memory_Mode();
    521          				device_current_state = STATE_BT_Mode_Disconnect;
    522          				enter_into_BT_Mode(0);
    523          				break;
    524          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    525          				//删除扫到的条码对应的最后一笔资料
    526          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    527          				if (ret != 0)
    528          				{
    529          					break;
    530          				}
    531          				hw_platform_led_ctrl(LED_YELLOW,1);
    532          				OSTimeDlyHMSM(0,0,0,50);
    533          				hw_platform_led_ctrl(LED_YELLOW,0);
    534          				rec = rec_searchby_tag(barcode,&index);
    535          				if (rec)
    536          				{
    537          					ret = delete_one_node(index);
    538          					if (ret)
    539          					{
    540          						//提示用户，删除失败
    541          						//@todo...
    542          					}
    543          				}
    544          				break;
    545          			case EVENT_ERASE_KEY_LONG_PRESS:
    546          				//删除所有的条码记录
    547          				ret = record_clear();
    548          				if (ret)
    549          				{
    550          					//提示用户，删除失败
    551          					//@todo...
    552          				}
    553          				break;
    554          			case EVENT_RESET_KEY_PRESS:
    555          				//@todo...
    556          				break;
    557          			case EVENT_BT_CONNECTED:
    558          				break;
    559          			case EVENT_BT_DISCONNECTED:
    560          				break;
    561          			case EVENT_USB_CABLE_INSERT:
    562          				//切换到USB HID模式
    563          				exit_from_Memory_Mode();
    564          				last_state = STATE_Memory_Mode;
    565          				device_current_state = STATE_HID_Mode;
    566          				enter_into_USB_HID_Mode();
    567          				break;
    568          			case EVENT_USB_CABLE_REMOVE:
    569          				break;
    570          			case EVENT_LOW_POWER:
    571          				//@todo...
    572          				break;
    573          			default:
    574          				break;
    575          			}
    576          		}
    577          		else if(device_current_state ==  STATE_HID_Mode)
    578          		{
    579          			switch(event)
    580          			{
    581          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    582          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    583          				hw_platform_stop_led_blink();
    584          				if(ret !=0)	//扫描条码
    585          				{
    586          					break;
    587          				}
    588          
    589          				hw_platform_led_ctrl(LED_YELLOW,1);
    590          				OSTimeDlyHMSM(0,0,0,50);
    591          				hw_platform_led_ctrl(LED_YELLOW,0);
    592          				//将扫描到的条码通过HID 接口发送出去
    593          				barcode_hid_send(barcode);
    594          				break;
    595          			case EVENT_SCAN_KEY_LONG_PRESS:
    596          				hw_platform_stop_led_blink();
    597          				break;
    598          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    599          				break;
    600          			case EVENT_ERASE_KEY_LONG_PRESS:
    601          				//将所有保存在Memory中的条码，全部上传到PC
    602          				cnt = record_module_count();
    603          				for (i = 0; i < cnt;i++)
    604          				{
    605          					if (get_node((i==0)?0:2,0) == 0)
    606          					{
    607          						barcode_hid_send(barcode);
    608          					}
    609          					else
    610          					{
    611          						//提示用户读取失败一次
    612          						//@todo...
    613          					}
    614          				}
    615          				break;
    616          			case EVENT_RESET_KEY_PRESS:
    617          				//@todo...
    618          				break;
    619          			case EVENT_BT_CONNECTED:
    620          				break;
    621          			case EVENT_BT_DISCONNECTED:
    622          				break;
    623          			case EVENT_USB_CABLE_INSERT:
    624          				break;
    625          			case EVENT_USB_CABLE_REMOVE:
    626          				//切换到之前的状态
    627          				exit_from_USB_HID_Mode();
    628          				device_current_state = last_state;
    629          				if (device_current_state == STATE_Memory_Mode)
    630          				{
    631          					enter_into_Memory_Mode();
    632          				}
    633          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    634          				{
    635          					enter_into_BT_Mode(2);
    636          				}
    637          				else
    638          				{
    639          					enter_into_BT_Mode(0);
    640          				}
    641          				break;
    642          			case EVENT_LOW_POWER:
    643          				break;
    644          			default:
    645          				break;
    646          			}
    647          		}
    648          	}
    649          }
    650          
    651          /**
    652          * @brief	获取部分异步事件的线程
    653          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    654          *			比如：按键事件会在定时器中断的服务程序post出来
    655          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    656          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    657          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    658          */
    659          void Event_capture_thread(void *p)
    660          {
    661          #ifdef DEBUG_VER
    662          	printf("Enter into Event_capture_thread!\r\n");
    663          #endif
    664          	while (1)
    665          	{
    666          		if (device_current_state == STATE_HID_Mode)
    667          		{
    668          			//判断USB线的拔出
    669          			if (bDeviceState == UNCONNECTED)
    670          			{
    671          #ifdef DEBUG_VER
    672          				printf("usb cable remove detected!\r\n");
    673          #endif
    674          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    675          			}
    676          
    677          			if (hw_platform_ChargeState_Detect())
    678          			{
    679          				//充电完成
    680          				hw_platform_led_ctrl(LED_RED,0);
    681          			}
    682          
    683          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    684          		}
    685          		else
    686          		{
    687          			//判断电池电量低
    688          			if (hw_platform_get_PowerClass() == 0)
    689          			{
    690          #ifdef DEBUG_VER
    691          				printf("low power detected!\r\n");
    692          #endif
    693          				OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    694          			}
    695          
    696          			if (bDeviceState == CONFIGURED)
    697          			{
    698          #ifdef DEBUG_VER
    699          				printf("USB HID Enum OK detected!\r\n");
    700          #endif
    701          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_INSERT);
    702          			}
    703          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    704          		}
    705          	}
    706          }
    707          
    708          
    709          /*
    710           * @brief 蓝牙模块维护线程
    711           * @note  此线程需要完成两个任务：
    712           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    713           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    714          */
    715          void BT_Daemon_thread(void *p)
    716          {
    717          	int ret;
    718                  unsigned int len;
    719          	unsigned char	err;
    720          	unsigned char	*pbarcode;
    721          
    722          	ret = WBTD_init();
    723          	if (ret)
    724          	{
    725          		WBTD_Reset();
    726          		ret = WBTD_init();
    727          		assert(ret == 0);
    728          	}
    729          
    730          #ifdef DEBUG_VER
    731          	printf("WBTD init Success!\r\n");
    732          #endif
    733          
    734          	while (1)
    735          	{
    736          		ret = WBTD_got_notify_type();
    737          		if ((ret == 1) || (ret == 2))
    738          		{
    739          #ifdef DEBUG_VER
    740          			printf("WBTD got notify = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    741          #endif
    742          			OSQPost(pEvent_Queue,(void*)((ret == 1)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    743          		}
    744          
    745          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    746          		if (pbarcode)
    747          		{
    748          #ifdef DEBUG_VER
    749          			printf("WBTD got data(%s) to send!\r\n",pbarcode);
    750          #endif
    751          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    752          			{
    753          				//发送失败应该怎么处理，什么都不做了么????!!!!
    754          				//@todo...
    755          #ifdef DEBUG_VER
    756          				printf("WBTD send data Fail!\r\n");
    757          #endif
    758          			}
    759          
    760          #ifdef DEBUG_VER
    761          			printf("WBTD send data Success!\r\n");
    762          #endif
    763          		}
    764          	}
    765          }
    766          
    767          
    768          /*
    769           * @brief进入U盘模式
    770          */
    771          void u_disk_proc(void)
    772          {
    773          	//g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
    774          	//usb_device_init(USB_MASSSTORAGE);
    775          
    776          	OSSchedLock();
    777          
    778          	while(hw_platform_USBcable_Insert_Detect() == 1)
    779          	{	
    780          		if(bDeviceState != CONFIGURED)
    781          		{
    782          			break;
    783          		}
    784          
    785          		Delay(2000);
    786          	}
    787          
    788          	OSSchedUnlock();
    789          }
    790          
    791          /*
    792           * @brief 低电量提示,红灯持续5S的闪烁
    793           * @return 0:提示期间没有USB线的插入		1:提示期间有USB线的插入
    794          */
    795          int lowpower_tip(void)
    796          {
    797          	int i;
    798          	OSSchedLock();
    799          	hw_platform_start_led_blink(LED_RED,3);
    800          	for (i = 0; i<100;i++)
    801          	{
    802          		hw_platform_beep_ctrl(50,2000);
    803          		if (hw_platform_USBcable_Insert_Detect())
    804          		{
    805          			hw_platform_stop_led_blink();
    806          			OSSchedUnlock();
    807          			return 1;
    808          		}
    809          	}
    810          	hw_platform_stop_led_blink();
    811          	OSSchedUnlock();
    812          	return 0;
    813          }
    814          
    815          /*
    816           * @brief 系统错误的提示
    817          */
    818          void system_err_tip(void)
    819          {
    820          	while(1)
    821          	{
    822          		//@todo...
    823          	}
    824          }
    825          
    826          
    827          // Cortex System Control register address
    828          #define SCB_SysCtrl					((u32)0xE000ED10)
    829          // SLEEPDEEP bit mask
    830          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
    831          
    832          /*
    833           * @brief 初始化线程
    834           */
    835          void app_init_thread(void *p)
    836          {
    837          	int ret;
    838          #ifdef DEBUG_VER
    839          	printf("app init thread startup...\r\n");
    840          #endif
    841          
    842          	OS_CPU_SysTickInit();
    843          
    844          	app_init();
    845          
    846          	Keypad_Init();
    847          
    848          	ret = record_module_init();
    849          	if (ret != 0)
    850          	{
    851          		system_err_tip();
    852          	}
    853          
    854          	scanner_mod_init();
    855          
    856          	usb_device_init(USB_KEYBOARD);
    857          
    858          	OSTaskCreateExt(State_Machine_thread,
    859          		(void *)0,
    860          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
    861          		8,
    862          		8,
    863          		&thread_statemachine_stk[0],
    864          		STACK_SIZE_TASKSM,
    865          		(void *)0,
    866          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    867          
    868          	OSTaskCreateExt(Event_capture_thread,
    869          		(void *)0,
    870          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
    871          		7,
    872          		7,
    873          		&thread_eventcapture_stk[0],
    874          		STACK_SIZE_TASKEC,
    875          		(void *)0,
    876          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    877          
    878          	OSTaskCreateExt(BT_Daemon_thread,
    879          		(void *)0,
    880          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
    881          		6,
    882          		6,
    883          		&thread_bt_stk[0],
    884          		STACK_SIZE_TASKBT,
    885          		(void *)0,
    886          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    887          
    888          	OSTimeDlyHMSM(0,0,0,10);
    889          	OSTaskDel(OS_PRIO_SELF);
    890          }
    891          
    892          /*
    893           * @brief 启动应用
    894           */
    895          void app_startup(void)
    896          {
    897          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
    898          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
    899          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
    900          
    901          	OSInit();
    902          
    903          	OSDebugInit();
    904          
    905          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI);
    906          	assert(p_init_thread_stk != 0);
    907          	memset((void*)p_init_thread_stk,0xDD,STACK_SIZE_TASKINI);
    908          
    909          	OSTaskCreateExt(app_init_thread,
    910          		(void *)0,
    911          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
    912          		5,
    913          		5,
    914          		&p_init_thread_stk[0],
    915          		STACK_SIZE_TASKINI,
    916          		(void *)0,
    917          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    918          
    919          	OSStart();
    920          }
    921          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            16
     Event_capture_thread         8
     State_Machine_thread       136
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           8
     enter_into_Memory_Mode       8
     enter_into_USB_HID_Mode      8
     exit_from_BT_Mode            8
     exit_from_Memory_Mode        8
     exit_from_USB_HID_Mode       8
     lowpower_tip                 8
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     system_err_tip               0
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1024
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  60
     barcode_cash                                1232
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     keypress_timeout                               4
     push_barcode_into_cash                       150
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                        16
     exit_from_Memory_Mode                         16
     enter_into_USB_HID_Mode                       24
     exit_from_USB_HID_Mode                        24
     enter_into_BT_Mode                            36
     exit_from_BT_Mode                             44
     barcode_hid_send                              92
     app_init                                     164
     State_Machine_thread                        1276
     Event_capture_thread                         148
     BT_Daemon_thread                             188
     u_disk_proc                                   40
     lowpower_tip                                  66
     system_err_tip                                 2
     app_init_thread                              184
     app_startup                                  144
     ??DataTable19                                  4
     ??DataTable52                                  4
     ??DataTable56                                  4
     ??DataTable57                                  4
     ??DataTable58                                  4
     ??DataTable62                                  4
     ??DataTable63                                  4
     ??DataTable64                                  4
     ??DataTable67                                  4
     ??DataTable70                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "enter into Memory Mode\r\n">      28
     ?<Constant "exit from Memory Mode\r\n">       24
     ?<Constant "enter into USB HID Mo...">        28
     ?<Constant "exit from USB HID Mode\r\n">      28
     ?<Constant "enter into BT Mode:%d\r\n">       24
     ?<Constant "exit from BT Mode:%d\r\n">        24
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "current state:%d\r\n">            20
     ?<Constant "event:%d\r\n">                    12
     ?<Constant "0">                                2
     ?<Constant "Enter into Event_capt...">        36
     ?<Constant "usb cable remove dete...">        32
     ?<Constant "low power detected!\r\n">         24
     ?<Constant "USB HID Enum OK detec...">        28
     ?<Constant "ret == 0">                        12
     ?<Constant "WBTD init Success!\r\n">          24
     ?<Constant "WBTD got notify = %s!\r\n">       24
     ?<Constant "Connected">                       12
     ?<Constant "Disconnect">                      12
     ?<Constant "WBTD got data(%s) to ...">        32
     ?<Constant "WBTD send data Fail!\r\n">        24
     ?<Constant "WBTD send data Succes...">        28
     ?<Constant "app init thread start...">        32
     ?<Constant "p_init_thread_stk != 0">          24

 
 3 396 bytes in section .bss
   830 bytes in section .rodata
 2 796 bytes in section .text
 
 2 762 bytes of CODE  memory (+ 34 bytes shared)
   830 bytes of CONST memory
 3 396 bytes of DATA  memory

Errors: none
Warnings: none
