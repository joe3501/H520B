###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     29/Jan/2016  14:15:44 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -lcN                           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record_m.h"
     28          #include "Terminal_Para.h"
     29          #include "usb_lib.h"
     30          #include "PCUsart.h"
     31          
     32          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     33          #define BARCODE_CASH_NUM	15			//定义等待蓝牙模块线程发送的条码缓冲区为15个条码
     34          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     35          
     36          //define the stack size of each task
     37          #define STACK_SIZE_TASKEC			128	
     38          #define STACK_SIZE_TASKSM			356
     39          #define STACK_SIZE_TASKBT			128
     40          #define STACK_SIZE_TASKINI			224
     41          
     42          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     43          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     44          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     45          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     46          
     47          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     48          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     49          static	unsigned char	lowpower_state;
     50          static	unsigned char	lowpower_cnt;
     51          static  TBATCH_NODE		batch_node;
     52          /*
     53          ------------------------------------------------------------
     54          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     55          ------------------------------------------------------------
     56          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     57          ------------------------------------------------------------
     58          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     59          ------------------------------------------------------------
     60          .........
     61          ------------------------------------------------------------
     62          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     63          ------------------------------------------------------------
     64          */
     65          //定义条码的静态缓冲区，以免动态分配内存
     66          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     67          
     68          
     69          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     70          //定义事件监测线程与主状态机之间通讯的IPC对象
     71          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     72          OS_EVENT	*pEvent_Queue;			//事件消息队列
     73          
     74          static OS_EVENT *pIOSem;				//IO信号量
     75          //
     76          
     77          unsigned int	device_current_state;		//设备主状态机
     78          
     79          unsigned int	keypress_timeout;
     80          unsigned char	barcode[MAX_BARCODE_LEN+1];
     81          
     82          void u_disk_proc(void);
     83          int lowpower_tip(void);
     84          void system_err_tip(void);
     85          
     86          extern void EnterLowPowerMode(void);
     87          extern void ExitLowPowerMode(void);
     88          
     89          
     90          /**
     91          * @brief	扫描条码成功的提示
     92          */
     93          static inline void scan_barcode_ok_tip(void)
     94          {
     95          	hw_platform_led_ctrl(LED_YELLOW,1);
     96          	if (g_param.motor_enable)
     97          	{
     98          		hw_platform_beep_motor_ctrl(100,4000);
     99          	}
    100          	else
    101          	{
    102          		hw_platform_beep_ctrl(100,4000);
    103          	}
    104          	
    105          	OSTimeDlyHMSM(0,0,0,10);
    106          	hw_platform_led_ctrl(LED_YELLOW,0);
    107          }
    108          
    109          /**
    110          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
    111          * @param[in] unsigned char* barcode				需要缓存的条码
    112          * @return   缓存的地址
    113          * @note 策略:只要找到一个空位置就放进去，每一列的最后一个字节为0表示该位置是空的
    114          *											     最后一个字节0x55表示该位置已经缓存了条码
    115          */
    116          unsigned char * push_barcode_into_cash(unsigned char* barcode)
    117          {
    118          	unsigned int	i;
    119          	for (i = 0; i < BARCODE_CASH_NUM;i++)
    120          	{
    121          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
    122          		{
    123          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
    124          			{
    125          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
    126          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
    127          			}
    128          			else
    129          			{
    130          				strcpy((char*)barcode_cash[i],(char const*)barcode);
    131          			}
    132          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
    133          			return (void*)barcode_cash[i];
    134          		}
    135          	}
    136          
    137          	return (void*)0;
    138          }
    139          
    140          
    141          /**
    142          * @brief	将已经发送出去的缓存地址pull出来
    143          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    144          * @return   none
    145          */
    146          void pull_barcode_from_cash(unsigned char* barcode_addr)
    147          {
    148          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    149          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    150          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    151          
    152          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    153          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    154          	return;
    155          }
    156          
    157          
    158          
    159          /**
    160          * @brief	进入Memory模式时，需要进行的一些设置
    161          */
    162          static inline void enter_into_Memory_Mode(void)
    163          {
    164          #ifdef DEBUG_VER
    165          	printf("enter into Memory Mode\r\n");
    166          #endif
    167          #if(BT_MODULE == USE_BT816)
    168          	BT816_enter_sleep();
    169          #endif
    170          	g_param.last_state = 1;
    171          	SaveTerminalPara();
    172          }
    173          
    174          /**
    175          * @brief	退出Memory模式时，需要进行的一些设置
    176          */
    177          static inline void exit_from_Memory_Mode(void)
    178          {
    179          #ifdef DEBUG_VER
    180          	printf("exit from Memory Mode\r\n");
    181          #endif
    182          	//@todo...
    183          }
    184          
    185          /**
    186          * @brief	进入USB HID模式时，需要进行的一些设置
    187          */
    188          static inline void enter_into_USB_HID_Mode(void)
    189          {
    190          #ifdef DEBUG_VER
    191          	printf("enter into USB HID Mode\r\n");
    192          #endif
    193          #if(BT_MODULE == USE_BT816)
    194          	BT816_enter_sleep();
    195          #endif
    196          	hw_platform_led_ctrl(LED_RED,1);
    197          	//hw_platform_beep_ctrl(100,1045);
    198          	//hw_platform_beep_ctrl(100,1171);
    199          	//hw_platform_beep_ctrl(100,1316);
    200          	//hw_platform_beep_ctrl(100,1393);
    201          	//hw_platform_beep_ctrl(100,1563);
    202          	//hw_platform_beep_ctrl(100,1755);
    203          	//hw_platform_beep_ctrl(100,1971);
    204          
    205          	hw_platform_beep_ctrl(100,1316);
    206          	hw_platform_beep_ctrl(100,1316);
    207          	hw_platform_beep_ctrl(100,1393);
    208          	hw_platform_beep_ctrl(100,1563);
    209          	hw_platform_beep_ctrl(100,1563);
    210          	hw_platform_beep_ctrl(100,1393);
    211          	hw_platform_beep_ctrl(100,1316);
    212          	hw_platform_beep_ctrl(100,1171);
    213          }
    214          
    215          /**
    216          * @brief	退出USB HID模式时，需要进行的一些设置
    217          */
    218          static inline void exit_from_USB_HID_Mode(void)
    219          {
    220          #ifdef DEBUG_VER
    221          	printf("exit from USB HID Mode\r\n");
    222          #endif
    223          	hw_platform_led_ctrl(LED_RED,0);
    224          }
    225          
    226          /**
    227          * @brief	进入BT模式时，需要进行的一些设置
    228          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    229          */
    230          static inline void enter_into_BT_Mode(unsigned char child_state)
    231          {
    232          #ifdef DEBUG_VER
    233          	printf("enter into BT Mode:%d\r\n",child_state);
    234          #endif
    235          #if(BT_MODULE == USE_BT816)
    236          	BT816_wakeup();
    237          #endif
    238          	if (child_state == 2)
    239          	{
    240          #if(BT_MODULE == USE_WBTDS01)
    241          		WBTD_Reset();
    242          #else
    243          		BT816_enter_pair_mode();
    244          #endif
    245          		hw_platform_beep_ctrl(300,3000);
    246          		hw_platform_start_led_blink(LED_BLUE,10);
    247          #if(BT_MODULE == USE_WBTDS01)
    248          		WBTD_set_autocon(0);
    249          #endif
    250          	}
    251          	else if (child_state == 0)
    252          	{
    253          		hw_platform_beep_ctrl(300,3000);
    254          		hw_platform_start_led_blink(LED_BLUE,150);
    255          	}
    256          	else
    257          	{
    258          		hw_platform_beep_ctrl(300,3000);
    259          		hw_platform_led_ctrl(LED_BLUE,1);
    260          	}
    261          	g_param.last_state = 0;
    262          	SaveTerminalPara();
    263          }
    264          
    265          /**
    266          * @brief	退出BT模式时，需要进行的一些设置
    267          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    268          */
    269          static inline void exit_from_BT_Mode(unsigned char child_state)
    270          {
    271          #ifdef DEBUG_VER
    272          	printf("exit from BT Mode:%d\r\n",child_state);
    273          #endif
    274          	if (child_state == 1)
    275          	{
    276          #if(BT_MODULE == USE_WBTDS01)
    277          		WBTD_set_autocon(1);
    278          #else
    279          		//BT816_set_autocon(0);
    280          		BT816_hid_disconnect();
    281          #endif
    282          		//delay_ms(1);
    283          		hw_platform_beep_ctrl(300,3000);
    284          		hw_platform_led_ctrl(LED_BLUE,0);
    285          #if(BT_MODULE == USE_WBTDS01)
    286          		WBTD_Reset();//主动断开与蓝牙主机的连接	
    287          #endif	
    288          	}
    289          	else
    290          	{
    291          		hw_platform_stop_led_blink(LED_BLUE);
    292          	}
    293          }
    294          
    295          
    296          /**
    297          * @brief	通过USB HID发送条码
    298          */
    299          static void barcode_hid_send(unsigned char* barcode)
    300          {
    301          	unsigned int	i,code_len;
    302          	unsigned char key_value_report[8];
    303          
    304              code_len = strlen((char const*)barcode);
    305          	OSSchedLock();
    306          	for (i = 0; i < code_len; i++)
    307          	{
    308          		ascii_to_keyreport(barcode[i],key_value_report);
    309          
    310          		SendData_To_PC(key_value_report, 3);
    311          		SendData_To_PC("\x00\x00\x00", 3);
    312          	}
    313          
    314          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    315          
    316          	SendData_To_PC(key_value_report, 3);
    317          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    318          	OSSchedUnlock();
    319          }
    320          
    321          /**
    322          * @brief	应用的初始化
    323          */
    324          void app_init(void)
    325          {
    326          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    327          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    328          	assert(pEvent_Queue != (OS_EVENT*)0);
    329          
    330          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    331          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    332          	assert(pBarcode_Queue != (OS_EVENT*)0);
    333          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    334          
    335          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    336          	pIOSem = OSSemCreate(0);
    337          	assert(pIOSem != (OS_EVENT*)0);
    338          
    339          	lowpower_state = 0;
    340          	lowpower_cnt = 0;
    341          }
    342          
    343          /**
    344          * @brief	维护主状态机的线程
    345          */
    346          void State_Machine_thread(void *p)
    347          {
    348          	unsigned int	i,cnt,event;
    349          	unsigned char	err;
    350          	unsigned char   codetype[20];
    351          	unsigned int    codelen;
    352          	int				ret,index;
    353          	unsigned int	last_state;
    354          	unsigned char	*rec;
    355          
    356          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    357          
    358          	//hw_platform_led_blink_test();		//for test
    359          	//lowpower_tip();					//for test
    360          	//record_m_test();					//for test
    361          	
    362          	while(1)
    363          	{
    364          		event = (unsigned int)OSQPend(pEvent_Queue,25,&err);
    365          		if (event == 0)
    366          		{
    367          			if ((g_param.lower_power_timeout)&&(device_current_state != STATE_HID_Mode))
    368          			{
    369          				keypress_timeout++;
    370          				if (keypress_timeout == g_param.lower_power_timeout*4*60)
    371          				{
    372          					hw_platform_beep_ctrl(500,3000);
    373          #ifndef DEBUG_VER
    374          					EnterLowPowerMode();
    375          					ExitLowPowerMode();
    376          #endif	
    377          					hw_platform_beep_ctrl(500,3000);
    378          				}
    379          			}
    380          			continue;
    381          		}
    382          #ifdef DEBUG_VER
    383          		printf("current state:%d\r\n",device_current_state);
    384          		printf("event:%d\r\n",event);
    385          #endif
    386          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    387          		{
    388          			switch(event)
    389          			{
    390          			//case EVENT_SCAN_KEY_SINGLE_CLICK:
    391          			//case EVENT_SCAN_KEY_DOUBLE_CLICK:
    392          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    393          			//	hw_platform_stop_led_blink(LED_GREEN);
    394          			//	if (ret == 0)
    395          			case EVENT_SCAN_GOT_BARCODE:
    396          				scan_barcode_ok_tip();
    397          				if (lowpower_state)
    398          				{
    399          					lowpower_tip();
    400          				}
    401          				//只是扫描到条码而已，什么都不做
    402          				break;
    403          			case EVENT_SCAN_KEY_LONG_PRESS:
    404          				//切换到Memory Mode
    405          				//hw_platform_stop_led_blink(LED_GREEN);
    406          				exit_from_BT_Mode(0);
    407          				device_current_state = STATE_Memory_Mode;
    408          				hw_platform_beep_ctrl(300,3000);
    409          				enter_into_Memory_Mode();
    410          				break;
    411          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    412          				break;
    413          			case EVENT_ERASE_KEY_LONG_PRESS:
    414          				//切换到配对模式
    415          				exit_from_BT_Mode(0);
    416          				device_current_state = STATE_BT_Mode_WaitPair;
    417          				enter_into_BT_Mode(2);
    418          				break;
    419          			case EVENT_RESET_KEY_PRESS:
    420          				break;
    421          			case EVENT_BT_CONNECTED:
    422          				//切换到蓝牙连接模式
    423          				exit_from_BT_Mode(0);
    424          				device_current_state = STATE_BT_Mode_Connect;
    425          				enter_into_BT_Mode(1);
    426          				break;
    427          			case EVENT_BT_DISCONNECTED:
    428          				break;
    429          			case EVENT_USB_CABLE_INSERT:
    430          				//切换到USB HID模式
    431          				exit_from_BT_Mode(0);
    432          				last_state = STATE_BT_Mode_Disconnect;
    433          				device_current_state = STATE_HID_Mode;
    434          				enter_into_USB_HID_Mode();
    435          				break;
    436          			case EVENT_USB_CABLE_REMOVE:
    437          				break;
    438          			case EVENT_LOW_POWER:
    439          				lowpower_tip();
    440          				break;
    441          			default:
    442          				break;
    443          			}
    444          		}
    445          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    446          		{
    447          			switch(event)
    448          			{
    449          			//case EVENT_SCAN_KEY_SINGLE_CLICK:
    450          				//扫描条码
    451          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    452          			//	hw_platform_stop_led_blink(LED_GREEN);
    453          			//	if (ret != 0)
    454          			//	{
    455          			//		break;
    456          			//	}
    457          			case EVENT_SCAN_GOT_BARCODE:
    458          				scan_barcode_ok_tip();
    459          				if (lowpower_state)
    460          				{
    461          					lowpower_tip();
    462          				}
    463          				//扫描到条码了
    464          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    465          				//Queue，由蓝牙模块线程负责去发送到主机
    466          repost:
    467          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode));
    468          				if(ret != OS_ERR_NONE)
    469          				{
    470          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    471          					{
    472          						//如果队列满了或者空事件时，那么需要延时重试
    473          						OSTimeDlyHMSM(0,0,0,100);
    474          						goto repost;
    475          					}
    476          					else
    477          					{
    478          						assert(0);	//系统错误
    479          					}
    480          				}
    481          				break;
    482          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    483          				if (g_param.ios_softkeypad_enable)
    484          				{
    485          #if(BT_MODULE == USE_WBTDS01)
    486          					WBTD_set_ioskeypad(1);
    487          #else
    488          					BT816_toggle_ioskeypad();
    489          #endif
    490          				}
    491          				break;
    492          			case EVENT_SCAN_KEY_LONG_PRESS:
    493          				//hw_platform_stop_led_blink(LED_GREEN);
    494          				//切换到Memory mode
    495          				exit_from_BT_Mode(1);
    496          				device_current_state = STATE_Memory_Mode;
    497          				hw_platform_beep_ctrl(300,3000);
    498          				enter_into_Memory_Mode();
    499          				break;
    500          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    501          #if(BT_MODULE == USE_WBTDS01)
    502          				//WBTD_hid_send_test();
    503          #else
    504          				//BT816_hid_send_test();
    505          #endif
    506          				break;
    507          			case EVENT_ERASE_KEY_LONG_PRESS:
    508          				//进入配对模式
    509          				exit_from_BT_Mode(1);
    510          				device_current_state = STATE_BT_Mode_WaitPair;
    511          				enter_into_BT_Mode(2);
    512          				break;
    513          			case EVENT_RESET_KEY_PRESS:
    514          				//@todo...
    515          				break;
    516          			case EVENT_BT_CONNECTED:
    517          				break;
    518          			case EVENT_BT_DISCONNECTED:
    519          				//切换到蓝牙断开状态
    520          				exit_from_BT_Mode(1);
    521          				device_current_state = STATE_BT_Mode_Disconnect;
    522          				enter_into_BT_Mode(0);
    523          				break;
    524          			case EVENT_USB_CABLE_INSERT:
    525          				//切换到USB HID模式
    526          				exit_from_BT_Mode(1);
    527          				last_state = STATE_BT_Mode_Disconnect;
    528          				device_current_state = STATE_HID_Mode;
    529          				enter_into_USB_HID_Mode();
    530          				break;
    531          			case EVENT_USB_CABLE_REMOVE:
    532          				break;
    533          			case EVENT_LOW_POWER:
    534          				lowpower_tip();
    535          				break;
    536          			default:
    537          				break;
    538          			}
    539          		}
    540          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    541          		{
    542          			switch(event)
    543          			{
    544          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    545          				exit_from_BT_Mode(2);
    546          				device_current_state = STATE_BT_Mode_Disconnect;
    547          				//hw_platform_beep_ctrl(300,3000);
    548          				enter_into_BT_Mode(0);
    549          			//case EVENT_SCAN_KEY_DOUBLE_CLICK:
    550          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    551          			//	hw_platform_stop_led_blink(LED_GREEN);
    552          			//	if (ret == 0)
    553          			case EVENT_SCAN_GOT_BARCODE:
    554          				
    555          				scan_barcode_ok_tip();
    556          				
    557          				if (lowpower_state)
    558          				{
    559          					lowpower_tip();
    560          				}
    561          				//只是扫描到条码而已，什么都不做
    562          				break;
    563          			case EVENT_SCAN_KEY_LONG_PRESS:
    564          				//hw_platform_stop_led_blink(LED_GREEN);
    565          				//切换到Memory Mode
    566          				exit_from_BT_Mode(2);
    567          				device_current_state = STATE_Memory_Mode;
    568          				hw_platform_beep_ctrl(300,3000);
    569          				enter_into_Memory_Mode();
    570          				break;
    571          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    572          				//exit_from_BT_Mode(2);
    573          				//device_current_state = STATE_BT_Mode_Disconnect;
    574          				//hw_platform_beep_ctrl(300,3000);
    575          				//enter_into_BT_Mode(0);
    576          				break;
    577          			case EVENT_ERASE_KEY_LONG_PRESS:
    578          				//已经是配对模式，什么都不做
    579          				break;
    580          			case EVENT_RESET_KEY_PRESS:
    581          				//@todo...
    582          				break;
    583          			case EVENT_BT_CONNECTED:
    584          				//切换到蓝牙连接状态
    585          				exit_from_BT_Mode(2);
    586          				device_current_state = STATE_BT_Mode_Connect;
    587          				enter_into_BT_Mode(1);
    588          				break;
    589          			case EVENT_BT_DISCONNECTED:
    590          				break;
    591          			case EVENT_USB_CABLE_INSERT:
    592          				//切换到USB HID模式
    593          				exit_from_BT_Mode(2);
    594          				last_state = STATE_BT_Mode_WaitPair;
    595          				device_current_state = STATE_HID_Mode;
    596          				enter_into_USB_HID_Mode();
    597          				break;
    598          			case EVENT_USB_CABLE_REMOVE:
    599          				break;
    600          			case EVENT_LOW_POWER:
    601          				lowpower_tip();
    602          				break;
    603          			default:
    604          				break;
    605          			}
    606          		}
    607          		else if(device_current_state ==  STATE_Memory_Mode)
    608          		{
    609          			switch(event)
    610          			{
    611          			//case EVENT_SCAN_KEY_SINGLE_CLICK:
    612          				//扫描条码
    613          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    614          			//	hw_platform_stop_led_blink(LED_GREEN);
    615          			//	if (ret != 0)
    616          			//	{
    617          			//		break;
    618          			//	}
    619          			case EVENT_SCAN_GOT_BARCODE:
    620          				scan_barcode_ok_tip();
    621          				if (lowpower_state)
    622          				{
    623          					lowpower_tip();
    624          				}
    625          				//扫描到条码了
    626          				//将获取到的条码保存到memory
    627          				memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    628          				strcpy((char*)batch_node.barcode,(char const*)barcode);
    629          				ret = record_add((unsigned char*)&batch_node);
    630          				if (ret)
    631          				{
    632          					//记录保存失败，给出提示给用户
    633          					//@todo...
    634          
    635          				}
    636          				break;
    637          			case EVENT_SCAN_KEY_LONG_PRESS:
    638          				//hw_platform_stop_led_blink(LED_GREEN);
    639          				//切换至蓝牙模式
    640          				exit_from_Memory_Mode();
    641          				device_current_state = STATE_BT_Mode_Disconnect;
    642          				enter_into_BT_Mode(0);
    643          				break;
    644          			//case EVENT_ERASE_KEY_SINGLE_CLICK:
    645          			//	//删除扫到的条码对应的最后一笔资料
    646          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    647          			//	if (ret != 0)
    648          			//	{
    649          			//		break;
    650          			//	}
    651          			case EVENT_ERASE_GOT_BARCODE:
    652          				scan_barcode_ok_tip();
    653          				if (lowpower_state)
    654          				{
    655          					lowpower_tip();
    656          				}
    657          				OSSchedLock();
    658          				rec = rec_searchby_tag(barcode,&index);
    659          				OSSchedUnlock();
    660          				if (rec)
    661          				{
    662          					ret = delete_one_node(index);
    663          					if (ret)
    664          					{
    665          						//提示用户，删除失败
    666          						//@todo...
    667          					}
    668          				}
    669          				break;
    670          			case EVENT_ERASE_KEY_LONG_PRESS:
    671          				//删除所有的条码记录
    672          				ret = record_clear();
    673          				if (ret)
    674          				{
    675          					//提示用户，删除失败
    676          					//@todo...
    677          				}
    678          				hw_platform_beep_ctrl(300,3000);
    679          				break;
    680          			case EVENT_RESET_KEY_PRESS:
    681          				//@todo...
    682          				break;
    683          			case EVENT_BT_CONNECTED:
    684          				break;
    685          			case EVENT_BT_DISCONNECTED:
    686          				break;
    687          			case EVENT_USB_CABLE_INSERT:
    688          				//切换到USB HID模式
    689          				exit_from_Memory_Mode();
    690          				last_state = STATE_Memory_Mode;
    691          				device_current_state = STATE_HID_Mode;
    692          				enter_into_USB_HID_Mode();
    693          				break;
    694          			case EVENT_USB_CABLE_REMOVE:
    695          				break;
    696          			case EVENT_LOW_POWER:
    697          				lowpower_tip();
    698          				break;
    699          			default:
    700          				break;
    701          			}
    702          		}
    703          		else if(device_current_state ==  STATE_HID_Mode)
    704          		{
    705          			switch(event)
    706          			{
    707          			//case EVENT_SCAN_KEY_SINGLE_CLICK:
    708          			//	ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    709          			//	hw_platform_stop_led_blink(LED_GREEN);
    710          			//	if(ret !=0)	//扫描条码
    711          			//	{
    712          			//		break;
    713          			//	}
    714          			case EVENT_SCAN_GOT_BARCODE:
    715          				scan_barcode_ok_tip();
    716          				//将扫描到的条码通过HID 接口发送出去
    717          				barcode_hid_send(barcode);
    718          				break;
    719          			case EVENT_SCAN_KEY_LONG_PRESS:
    720          				//hw_platform_stop_led_blink(LED_GREEN);
    721          				break;
    722          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    723          				break;
    724          			case EVENT_ERASE_KEY_LONG_PRESS:
    725          				//将所有保存在Memory中的条码，全部上传到PC
    726          				hw_platform_beep_ctrl(300,3000);
    727          				cnt = record_module_count();
    728          				for (i = 0; i < cnt;i++)
    729          				{
    730          					rec = get_node((i==0)?0:2,0);
    731          					if (rec)
    732          					{
    733          						barcode_hid_send(((TBATCH_NODE*)rec)->barcode);
    734          					}
    735          					else
    736          					{
    737          						//提示用户读取失败一次
    738          						//@todo...
    739          					}
    740          				}
    741          				hw_platform_beep_ctrl(300,3000);
    742          				break;
    743          			case EVENT_RESET_KEY_PRESS:
    744          				//@todo...
    745          				break;
    746          			case EVENT_BT_CONNECTED:
    747          				break;
    748          			case EVENT_BT_DISCONNECTED:
    749          				break;
    750          			case EVENT_USB_CABLE_INSERT:
    751          				break;
    752          			case EVENT_USB_CABLE_REMOVE:
    753          				//切换到之前的状态
    754          				exit_from_USB_HID_Mode();
    755          				device_current_state = last_state;
    756          				if (device_current_state == STATE_Memory_Mode)
    757          				{
    758          					enter_into_Memory_Mode();
    759          				}
    760          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    761          				{
    762          					enter_into_BT_Mode(2);
    763          				}
    764          				else
    765          				{
    766          					enter_into_BT_Mode(0);
    767          				}
    768          				break;
    769          			case EVENT_LOW_POWER:
    770          				break;
    771          			default:
    772          				break;
    773          			}
    774          		}
    775          	}
    776          }
    777          
    778          /**
    779          * @brief	获取部分异步事件的线程
    780          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    781          *			比如：按键事件会在定时器中断的服务程序post出来
    782          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    783          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    784          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    785          */
    786          void Event_capture_thread(void *p)
    787          {
    788          #ifdef DEBUG_VER
    789          	printf("Enter into Event_capture_thread!\r\n");
    790          #endif
    791          	while (1)
    792          	{
    793          		if (device_current_state == STATE_HID_Mode)
    794          		{
    795          			lowpower_state = 0;
    796          			lowpower_cnt = 0;
    797          			//判断USB线的拔出
    798          			if (bDeviceState == UNCONNECTED)
    799          			{
    800          #ifdef DEBUG_VER
    801          				printf("usb cable remove detected!\r\n");
    802          #endif
    803          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    804          			}
    805          
    806          			if (hw_platform_ChargeState_Detect())
    807          			{
    808          				//充电完成
    809          				hw_platform_led_ctrl(LED_RED,0);
    810          			}
    811          
    812          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    813          		}
    814          		else
    815          		{
    816          			if(hw_platform_USBcable_Insert_Detect())
    817          			{
    818          				//正在充电
    819          				if (hw_platform_ChargeState_Detect())
    820          				{
    821          					//充电完成
    822          					hw_platform_led_ctrl(LED_RED,0);
    823          				}
    824          				else
    825          				{
    826          					hw_platform_led_ctrl(LED_RED,1);
    827          				}
    828          			}
    829          			else
    830          			{
    831          				hw_platform_led_ctrl(LED_RED,0);
    832          				//判断电池电量低
    833          				if (hw_platform_get_PowerClass() == 0)
    834          				{
    835          					lowpower_cnt++;
    836          					if (lowpower_cnt>10)
    837          					{
    838          #ifdef DEBUG_VER
    839          						printf("low power detected!\r\n");
    840          #endif
    841          						if (lowpower_state == 0)
    842          						{
    843          							OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    844          							lowpower_state = 1;
    845          						}
    846          
    847          					}
    848          				}
    849          				else
    850          				{
    851          					lowpower_cnt = 0;
    852          				}
    853          			}
    854          			
    855          
    856          			if (bDeviceState == CONFIGURED)
    857          			{
    858          #ifdef DEBUG_VER
    859          				printf("USB HID Enum OK detected!\r\n");
    860          #endif
    861          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_INSERT);
    862          			}
    863          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    864          		}
    865          	}
    866          }
    867          
    868          
    869          /*
    870           * @brief 蓝牙模块维护线程
    871           * @note  此线程需要完成两个任务：
    872           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    873           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    874          */
    875          void BT_Daemon_thread(void *p)
    876          {
    877          #if(BT_MODULE == USE_BT816)
    878          	static unsigned int last_status;
    879          #endif
    880          	int ret;
    881              unsigned int len;
    882          	unsigned char	err;
    883          	unsigned char	*pbarcode;
    884          
    885          #if(BT_MODULE == USE_WBTDS01)
    886          	ret = WBTD_init();
    887          #else
    888          	ret = BT816_init();
    889          	last_status = BT_MODULE_STATUS_DISCONNECT;
    890          #endif
    891          	if (ret)
    892          	{
    893          #if(BT_MODULE == USE_WBTDS01)
    894          		WBTD_Reset();
    895          		ret = WBTD_init();
    896          #else
    897          		ret = BT816_init();
    898          #endif
    899          		assert(ret == 0);
    900          	}
    901          
    902          #ifdef DEBUG_VER
    903          	printf("BT Module init Success!\r\n");
    904          #endif
    905          
    906          #if(BT_MODULE == USE_BT816)
    907          	//BT816_hid_connect_last_host();		//试图连接最近一次的蓝牙主机
    908          #endif
    909          
    910          
    911          	//for test SPP mode
    912          	//while(1)
    913          	//{
    914          	//	if (spp_buffer_head)
    915          	//	{
    916          	//		printf("spp reclen=%d\r\n",spp_buffer_head);
    917          
    918          	//		for (len = 0; len < spp_buffer_head;len++)
    919          	//		{
    920          	//			printf("0x%x,",spp_rec_buffer[len]);
    921          	//		}
    922          	//		printf("\r\n");
    923          
    924          	//		spp_buffer_head = 0;
    925          	//	}
    926          
    927          	//	OSTimeDlyHMSM(0,0,0,50);
    928          	//}
    929          
    930          	while (1)
    931          	{
    932          #if(BT_MODULE == USE_WBTDS01)
    933          		ret = WBTD_got_notify_type();
    934          		if ((ret == BT_MODULE_STATUS_CONNECTED) || (ret == BT_MODULE_STATUS_DISCONNECT))
    935          		{
    936          #ifdef DEBUG_VER
    937          			printf("BT Module Status = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    938          #endif
    939          			OSQPost(pEvent_Queue,(void*)((ret == BT_MODULE_STATUS_CONNECTED)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    940          		}
    941          #else
    942          		ret = BT816_hid_status();
    943          		if ((ret == BT_MODULE_STATUS_CONNECTED)||(ret == BT_MODULE_STATUS_DISCONNECT))
    944          		{
    945          			if (ret != last_status)
    946          			{
    947          				last_status = ret;
    948          
    949          #ifdef DEBUG_VER
    950          				printf("BT Module Status = %s!\r\n",(ret==BT_MODULE_STATUS_CONNECTED)?"Connected":"Disconnect");
    951          #endif
    952          				OSQPost(pEvent_Queue,(void*)((ret == BT_MODULE_STATUS_CONNECTED)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    953          			}
    954          			else
    955          			{
    956          				if ((ret == BT_MODULE_STATUS_DISCONNECT)&&(device_current_state == STATE_BT_Mode_Disconnect))
    957          				{
    958          					//发送一个键值，试图重连蓝牙主机
    959          					//BT816_hid_send("1",1);
    960          					BT816_hid_connect_last_host();
    961          				}
    962          			}
    963          		}
    964          #endif
    965          
    966          
    967          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    968          		if (pbarcode)
    969          		{
    970          #ifdef DEBUG_VER
    971          			printf("BT Module got data(%s) to send!\r\n",pbarcode);
    972          #endif
    973          #if(BT_MODULE == USE_WBTDS01)
    974          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    975          #else
    976          			if (BT816_hid_send(pbarcode,strlen((char const*)pbarcode)))
    977          #endif
    978          			{
    979          				//发送失败应该怎么处理，什么都不做了么????!!!!
    980          				//@todo...
    981          #ifdef DEBUG_VER
    982          				printf("BT Module send data Fail!\r\n");
    983          #endif
    984          			}
    985          			else
    986          			{
    987          				pull_barcode_from_cash(pbarcode);
    988          				//OSTimeDlyHMSM(0,0,0,50);
    989          
    990          #ifdef DEBUG_VER
    991          				printf("BT Module send data Success!\r\n");
    992          #endif
    993          			}
    994          		}
    995          	}
    996          }
    997          
    998          
    999          /*
   1000           * @brief进入U盘模式
   1001          */
   1002          void u_disk_proc(void)
   1003          {
   1004          	//g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
   1005          	//usb_device_init(USB_MASSSTORAGE);
   1006          
   1007          	OSSchedLock();
   1008          
   1009          	while(hw_platform_USBcable_Insert_Detect() == 1)
   1010          	{	
   1011          		if(bDeviceState != CONFIGURED)
   1012          		{
   1013          			break;
   1014          		}
   1015          
   1016          		delay_ms(1);
   1017          	}
   1018          
   1019          	OSSchedUnlock();
   1020          }
   1021          
   1022          /*
   1023           * @brief 低电量提示,红灯持续5S的闪烁
   1024           * @return 0:提示期间没有USB线的插入		1:提示期间有USB线的插入
   1025          */
   1026          int lowpower_tip(void)
   1027          {
   1028          	int i;
   1029          	OSSchedLock();
   1030          	hw_platform_start_led_blink(LED_RED,5);
   1031          	for (i = 0; i<20;i++)
   1032          	{
   1033          		hw_platform_beep_ctrl(50,1000);
   1034          		if (hw_platform_USBcable_Insert_Detect())
   1035          		{
   1036          			hw_platform_stop_led_blink(LED_RED);
   1037          			OSSchedUnlock();
   1038          			return 1;
   1039          		}
   1040          	}
   1041          	hw_platform_stop_led_blink(LED_RED);
   1042          	OSSchedUnlock();
   1043          	return 0;
   1044          }
   1045          
   1046          /*
   1047           * @brief 系统错误的提示
   1048          */
   1049          void system_err_tip(void)
   1050          {
   1051          	while(1)
   1052          	{
   1053          		//@todo...
   1054          	}
   1055          }
   1056          
   1057          
   1058          // Cortex System Control register address
   1059          #define SCB_SysCtrl					((u32)0xE000ED10)
   1060          // SLEEPDEEP bit mask
   1061          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
   1062          
   1063          /*
   1064           * @brief 初始化线程
   1065           */
   1066          void app_init_thread(void *p)
   1067          {
   1068          	int ret;
   1069          #ifdef DEBUG_VER
   1070          	printf("app init thread startup...\r\n");
   1071          #endif
   1072          
   1073          	OS_CPU_SysTickInit();
   1074          
   1075          	app_init();
   1076          
   1077          	Keypad_Init();
   1078          
   1079          	ret = record_module_init();
   1080          	if (ret != 0)
   1081          	{
   1082          		system_err_tip();
   1083          	}
   1084          
   1085          	if (recover_record_by_logfile())
   1086          	{
   1087          		system_err_tip();
   1088          	}
   1089          
   1090          	if (ReadTerminalPara())
   1091          	{
   1092          		if (DefaultTerminalPara())
   1093          		{
   1094          			system_err_tip();
   1095          		}
   1096          	}
   1097          
   1098          	if (g_param.last_state == 1)
   1099          	{
   1100          		device_current_state = STATE_Memory_Mode;	//脱机状态
   1101          		enter_into_Memory_Mode();
   1102          	}
   1103          	else
   1104          	{
   1105          		device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
   1106          		hw_platform_start_led_blink(LED_BLUE,150);
   1107          	}
   1108          
   1109          	scanner_mod_init();
   1110          
   1111          	//usb_device_init(USB_KEYBOARD);
   1112          
   1113          	OSTaskCreateExt(State_Machine_thread,
   1114          		(void *)0,
   1115          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
   1116          		8,
   1117          		8,
   1118          		&thread_statemachine_stk[0],
   1119          		STACK_SIZE_TASKSM,
   1120          		(void *)0,
   1121          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1122          
   1123          	OSTaskCreateExt(Event_capture_thread,
   1124          		(void *)0,
   1125          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
   1126          		7,
   1127          		7,
   1128          		&thread_eventcapture_stk[0],
   1129          		STACK_SIZE_TASKEC,
   1130          		(void *)0,
   1131          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1132          
   1133          	OSTaskCreateExt(BT_Daemon_thread,
   1134          		(void *)0,
   1135          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
   1136          		6,
   1137          		6,
   1138          		&thread_bt_stk[0],
   1139          		STACK_SIZE_TASKBT,
   1140          		(void *)0,
   1141          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1142          
   1143          	OSTimeDlyHMSM(0,0,0,10);
   1144          	OSTaskDel(OS_PRIO_SELF);
   1145          }
   1146          
   1147          /*
   1148           * @brief 启动应用
   1149           */
   1150          void app_startup(void)
   1151          {
   1152          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
   1153          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
   1154          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
   1155          
   1156          	OSInit();
   1157          
   1158          	OSDebugInit();
   1159          
   1160          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI*sizeof(OS_STK));
   1161          	assert(p_init_thread_stk != 0);
   1162          
   1163          	OSTaskCreateExt(app_init_thread,
   1164          		(void *)0,
   1165          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
   1166          		5,
   1167          		5,
   1168          		&p_init_thread_stk[0],
   1169          		STACK_SIZE_TASKINI,
   1170          		(void *)0,
   1171          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1172          
   1173          	OSStart();
   1174          }
   1175          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            16
     Event_capture_thread         8
     State_Machine_thread        32
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           8
     enter_into_Memory_Mode       8
     enter_into_USB_HID_Mode      8
     exit_from_BT_Mode            8
     exit_from_Memory_Mode        0
     exit_from_USB_HID_Mode       8
     lowpower_tip                 8
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     scan_barcode_ok_tip          8
     system_err_tip               0
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1424
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  60
     barcode_cash                                1232
     lowpower_state                                 1
     lowpower_cnt                                   1
     batch_node                                    84
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     keypress_timeout                               4
     barcode                                       84
     scan_barcode_ok_tip                           64
     push_barcode_into_cash                       114
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                        20
     exit_from_Memory_Mode                          2
     enter_into_USB_HID_Mode                       96
     exit_from_USB_HID_Mode                        12
     enter_into_BT_Mode                           102
     exit_from_BT_Mode                             42
     barcode_hid_send                              92
     app_init                                     176
     State_Machine_thread                        1192
     Event_capture_thread                         204
     BT_Daemon_thread                             156
     last_status                                    4
     u_disk_proc                                   38
     lowpower_tip                                  70
     system_err_tip                                 2
     app_init_thread                              232
     app_startup                                  136
     ??DataTable20                                  4
     ??DataTable69                                  4
     ??DataTable72                                  4
     ??DataTable75                                  4
     ??DataTable76                                  4
     ??DataTable77                                  4
     ??DataTable78                                  4
     ??DataTable80                                  4
     ??DataTable84                                  4
     ??DataTable85                                  4
     ??DataTable86                                  4
     ??DataTable89                                  4
     ??DataTable91                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "0">                                2
     ?<Constant "ret == 0">                        12
     ?<Constant "p_init_thread_stk != 0">          24

 
 3 970 bytes in section .bss
   334 bytes in section .rodata
 2 944 bytes in section .text
 
 2 910 bytes of CODE  memory (+ 34 bytes shared)
   334 bytes of CONST memory
 3 970 bytes of DATA  memory

Errors: none
Warnings: 3
