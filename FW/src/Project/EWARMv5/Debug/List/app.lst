###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     25/Sep/2015  16:55:33 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -D DEBUG_VER -lcN              #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record.h"
     28          #include "Terminal_Para.h"
     29          #include "usb_lib.h"
     30          #include "PCUsart.h"
     31          
     32          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     33          #define BARCODE_CASH_NUM	15			//定义等待蓝牙模块线程发送的条码缓冲区为15个条码
     34          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     35          
     36          //define the stack size of each task
     37          #define STACK_SIZE_TASKEC			128	
     38          #define STACK_SIZE_TASKSM			256
     39          #define STACK_SIZE_TASKBT			128
     40          #define STACK_SIZE_TASKINI			128
     41          
     42          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     43          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     44          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     45          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     46          
     47          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     48          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     49          static	unsigned char	lowpower_state;
     50          static	unsigned char	lowpower_cnt;
     51          static  TBATCH_NODE		batch_node;
     52          /*
     53          ------------------------------------------------------------
     54          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     55          ------------------------------------------------------------
     56          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     57          ------------------------------------------------------------
     58          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     59          ------------------------------------------------------------
     60          .........
     61          ------------------------------------------------------------
     62          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     63          ------------------------------------------------------------
     64          */
     65          //定义条码的静态缓冲区，以免动态分配内存
     66          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     67          
     68          
     69          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     70          //定义事件监测线程与主状态机之间通讯的IPC对象
     71          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     72          OS_EVENT	*pEvent_Queue;			//事件消息队列
     73          
     74          static OS_EVENT *pIOSem;				//IO信号量
     75          //
     76          
     77          unsigned int	device_current_state;		//设备主状态机
     78          
     79          unsigned int	keypress_timeout;
     80          
     81          
     82          void u_disk_proc(void);
     83          int lowpower_tip(void);
     84          void system_err_tip(void);
     85          
     86          extern void EnterLowPowerMode(void);
     87          extern void ExitLowPowerMode(void);
     88          
     89          
     90          /**
     91          * @brief	扫描条码成功的提示
     92          */
     93          static inline void scan_barcode_ok_tip(void)
     94          {
     95          	hw_platform_led_ctrl(LED_YELLOW,1);
     96          	hw_platform_beep_motor_ctrl(100,4000);
     97          	OSTimeDlyHMSM(0,0,0,10);
     98          	hw_platform_led_ctrl(LED_YELLOW,0);
     99          }
    100          
    101          /**
    102          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
    103          * @param[in] unsigned char* barcode				需要缓存的条码
    104          * @param[in] unsigned char	ios_keypad_flag     是否需要唤取IOS softkeypad
    105          * @return   缓存的地址
    106          * @note 策略:只要找到一个空位置就放进去，每一列的最有一个字节为0表示该位置是空的
    107          *											     最后一个字节0x55表示该位置已经缓存了条码
    108          */
    109          unsigned char * push_barcode_into_cash(unsigned char* barcode,unsigned char	ios_keypad_flag)
    110          {
    111          	unsigned int	i;
    112          	for (i = 0; i < BARCODE_CASH_NUM;i++)
    113          	{
    114          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
    115          		{
    116          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
    117          			{
    118          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
    119          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
    120          			}
    121          			else
    122          			{
    123          				strcpy((char*)barcode_cash[i],(char const*)barcode);
    124          			}
    125          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
    126          			if (ios_keypad_flag)
    127          			{
    128          				barcode_cash[i][MAX_BARCODE_LEN+1] |= 0xF0;
    129          			}
    130          			return (void*)barcode_cash[i];
    131          		}
    132          	}
    133          
    134          	return (void*)0;
    135          }
    136          
    137          
    138          /**
    139          * @brief	将已经发送出去的缓存地址pull出来
    140          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    141          * @return   none
    142          */
    143          void pull_barcode_from_cash(unsigned char* barcode_addr)
    144          {
    145          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    146          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    147          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    148          
    149          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    150          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    151          	return;
    152          }
    153          
    154          
    155          
    156          /**
    157          * @brief	进入Memory模式时，需要进行的一些设置
    158          */
    159          static inline void enter_into_Memory_Mode(void)
    160          {
    161          #ifdef DEBUG_VER
    162          	printf("enter into Memory Mode\r\n");
    163          #endif
    164          	g_param.last_state = 1;
    165          	SaveTerminalPara();
    166          }
    167          
    168          /**
    169          * @brief	退出Memory模式时，需要进行的一些设置
    170          */
    171          static inline void exit_from_Memory_Mode(void)
    172          {
    173          #ifdef DEBUG_VER
    174          	printf("exit from Memory Mode\r\n");
    175          #endif
    176          	//@todo...
    177          }
    178          
    179          /**
    180          * @brief	进入USB HID模式时，需要进行的一些设置
    181          */
    182          static inline void enter_into_USB_HID_Mode(void)
    183          {
    184          #ifdef DEBUG_VER
    185          	printf("enter into USB HID Mode\r\n");
    186          #endif
    187          	hw_platform_led_ctrl(LED_RED,1);
    188          	//hw_platform_beep_ctrl(100,1045);
    189          	//hw_platform_beep_ctrl(100,1171);
    190          	//hw_platform_beep_ctrl(100,1316);
    191          	//hw_platform_beep_ctrl(100,1393);
    192          	//hw_platform_beep_ctrl(100,1563);
    193          	//hw_platform_beep_ctrl(100,1755);
    194          	//hw_platform_beep_ctrl(100,1971);
    195          
    196          	hw_platform_beep_ctrl(100,1316);
    197          	hw_platform_beep_ctrl(100,1316);
    198          	hw_platform_beep_ctrl(100,1393);
    199          	hw_platform_beep_ctrl(100,1563);
    200          	hw_platform_beep_ctrl(100,1563);
    201          	hw_platform_beep_ctrl(100,1393);
    202          	hw_platform_beep_ctrl(100,1316);
    203          	hw_platform_beep_ctrl(100,1171);
    204          }
    205          
    206          /**
    207          * @brief	退出USB HID模式时，需要进行的一些设置
    208          */
    209          static inline void exit_from_USB_HID_Mode(void)
    210          {
    211          #ifdef DEBUG_VER
    212          	printf("exit from USB HID Mode\r\n");
    213          #endif
    214          	hw_platform_led_ctrl(LED_RED,0);
    215          }
    216          
    217          /**
    218          * @brief	进入BT模式时，需要进行的一些设置
    219          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    220          */
    221          static inline void enter_into_BT_Mode(unsigned char child_state)
    222          {
    223          #ifdef DEBUG_VER
    224          	printf("enter into BT Mode:%d\r\n",child_state);
    225          #endif
    226          	if (child_state == 2)
    227          	{
    228          		WBTD_Reset();
    229          		hw_platform_beep_ctrl(300,3000);
    230          		hw_platform_start_led_blink(LED_BLUE,10);
    231          		WBTD_set_autocon(0);
    232          	}
    233          	else if (child_state == 0)
    234          	{
    235          		hw_platform_start_led_blink(LED_BLUE,300);
    236          	}
    237          	else
    238          	{
    239          		hw_platform_led_ctrl(LED_BLUE,1);
    240          	}
    241          	g_param.last_state = 0;
    242          	SaveTerminalPara();
    243          }
    244          
    245          /**
    246          * @brief	退出BT模式时，需要进行的一些设置
    247          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    248          */
    249          static inline void exit_from_BT_Mode(unsigned char child_state)
    250          {
    251          #ifdef DEBUG_VER
    252          	printf("exit from BT Mode:%d\r\n",child_state);
    253          #endif
    254          	if (child_state == 1)
    255          	{
    256          		WBTD_set_autocon(1);
    257          		//delay_ms(1);
    258          		hw_platform_beep_ctrl(300,3000);
    259          		hw_platform_led_ctrl(LED_BLUE,0);
    260          		WBTD_Reset();//主动断开与蓝牙主机的连接
    261          		
    262          	}
    263          	else
    264          	{
    265          		hw_platform_stop_led_blink(LED_BLUE);
    266          	}
    267          }
    268          
    269          
    270          /**
    271          * @brief	通过USB HID发送条码
    272          */
    273          static void barcode_hid_send(unsigned char* barcode)
    274          {
    275          	unsigned int	i,code_len;
    276          	unsigned char key_value_report[8];
    277          
    278              code_len = strlen((char const*)barcode);
    279          	OSSchedLock();
    280          	for (i = 0; i < code_len; i++)
    281          	{
    282          		ascii_to_keyreport(barcode[i],key_value_report);
    283          
    284          		SendData_To_PC(key_value_report, 3);
    285          		SendData_To_PC("\x00\x00\x00", 3);
    286          	}
    287          
    288          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    289          
    290          	SendData_To_PC(key_value_report, 3);
    291          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    292          	OSSchedUnlock();
    293          }
    294          
    295          /**
    296          * @brief	应用的初始化
    297          */
    298          void app_init(void)
    299          {
    300          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    301          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    302          	assert(pEvent_Queue != (OS_EVENT*)0);
    303          
    304          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    305          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    306          	assert(pBarcode_Queue != (OS_EVENT*)0);
    307          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    308          
    309          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    310          	pIOSem = OSSemCreate(0);
    311          	assert(pIOSem != (OS_EVENT*)0);
    312          
    313          	lowpower_state = 0;
    314          	lowpower_cnt = 0;
    315          }
    316          
    317          /**
    318          * @brief	维护主状态机的线程
    319          */
    320          void State_Machine_thread(void *p)
    321          {
    322          	unsigned int	i,cnt,event;
    323          	unsigned char	err;
    324          	unsigned char	barcode[MAX_BARCODE_LEN+1];
    325          	unsigned char   codetype[20];
    326          	unsigned int    codelen;
    327          	int				ret,index;
    328          	unsigned int	last_state;
    329          	unsigned char	*rec;
    330          
    331          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    332          
    333          	//hw_platform_led_blink_test();		//for test
    334          	//lowpower_tip();					//for test
    335          	while(1)
    336          	{
    337          		event = (unsigned int)OSQPend(pEvent_Queue,25,&err);
    338          		if (event == 0)
    339          		{
    340          			if ((g_param.lower_power_timeout)&&(device_current_state != STATE_HID_Mode))
    341          			{
    342          				keypress_timeout++;
    343          				if (keypress_timeout == g_param.lower_power_timeout*4*60)
    344          				{
    345          					hw_platform_beep_ctrl(500,3000);
    346          					EnterLowPowerMode();
    347          					ExitLowPowerMode();
    348          				}
    349          			}
    350          			continue;
    351          		}
    352          #ifdef DEBUG_VER
    353          		printf("current state:%d\r\n",device_current_state);
    354          		printf("event:%d\r\n",event);
    355          #endif
    356          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    357          		{
    358          			switch(event)
    359          			{
    360          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    361          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    362          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    363          				hw_platform_stop_led_blink(LED_GREEN);
    364          				if (ret == 0)
    365          				{
    366          					scan_barcode_ok_tip();
    367          				}
    368          
    369          				if (lowpower_state)
    370          				{
    371          					lowpower_tip();
    372          				}
    373          				//只是扫描到条码而已，什么都不做
    374          				break;
    375          			case EVENT_SCAN_KEY_LONG_PRESS:
    376          				//切换到Memory Mode
    377          				hw_platform_stop_led_blink(LED_GREEN);
    378          				exit_from_BT_Mode(0);
    379          				device_current_state = STATE_Memory_Mode;
    380          				hw_platform_beep_ctrl(300,3000);
    381          				enter_into_Memory_Mode();
    382          				break;
    383          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    384          				break;
    385          			case EVENT_ERASE_KEY_LONG_PRESS:
    386          				//切换到配对模式
    387          				exit_from_BT_Mode(0);
    388          				device_current_state = STATE_BT_Mode_WaitPair;
    389          				enter_into_BT_Mode(2);
    390          				break;
    391          			case EVENT_RESET_KEY_PRESS:
    392          				break;
    393          			case EVENT_BT_CONNECTED:
    394          				//切换到蓝牙连接模式
    395          				exit_from_BT_Mode(0);
    396          				device_current_state = STATE_BT_Mode_Connect;
    397          				enter_into_BT_Mode(1);
    398          				break;
    399          			case EVENT_BT_DISCONNECTED:
    400          				break;
    401          			case EVENT_USB_CABLE_INSERT:
    402          				//切换到USB HID模式
    403          				exit_from_BT_Mode(0);
    404          				last_state = STATE_BT_Mode_Disconnect;
    405          				device_current_state = STATE_HID_Mode;
    406          				enter_into_USB_HID_Mode();
    407          				break;
    408          			case EVENT_USB_CABLE_REMOVE:
    409          				break;
    410          			case EVENT_LOW_POWER:
    411          				lowpower_tip();
    412          				break;
    413          			default:
    414          				break;
    415          			}
    416          		}
    417          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    418          		{
    419          			switch(event)
    420          			{
    421          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    422          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    423          				//扫描条码
    424          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    425          				hw_platform_stop_led_blink(LED_GREEN);
    426          				if (ret != 0)
    427          				{
    428          					break;
    429          				}
    430          
    431          				scan_barcode_ok_tip();
    432          				if (lowpower_state)
    433          				{
    434          					lowpower_tip();
    435          				}
    436          				//扫描到条码了
    437          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    438          				//Queue，由蓝牙模块线程负责去发送到主机
    439          repost:
    440          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode,(event == EVENT_SCAN_KEY_SINGLE_CLICK)?0:1));
    441          				if(ret != OS_ERR_NONE)
    442          				{
    443          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    444          					{
    445          						//如果队列满了或者空事件时，那么需要延时重试
    446          						OSTimeDlyHMSM(0,0,0,100);
    447          						goto repost;
    448          					}
    449          					else
    450          					{
    451          						assert(0);	//系统错误
    452          					}
    453          				}
    454          				break;
    455          			case EVENT_SCAN_KEY_LONG_PRESS:
    456          				hw_platform_stop_led_blink(LED_GREEN);
    457          				//切换到Memory mode
    458          				exit_from_BT_Mode(1);
    459          				device_current_state = STATE_Memory_Mode;
    460          				hw_platform_beep_ctrl(300,3000);
    461          				enter_into_Memory_Mode();
    462          				break;
    463          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    464          				break;
    465          			case EVENT_ERASE_KEY_LONG_PRESS:
    466          				//进入配对模式
    467          				exit_from_BT_Mode(1);
    468          				device_current_state = STATE_BT_Mode_WaitPair;
    469          				enter_into_BT_Mode(2);
    470          				break;
    471          			case EVENT_RESET_KEY_PRESS:
    472          				//@todo...
    473          				break;
    474          			case EVENT_BT_CONNECTED:
    475          				break;
    476          			case EVENT_BT_DISCONNECTED:
    477          				//切换到蓝牙断开状态
    478          				exit_from_BT_Mode(1);
    479          				device_current_state = STATE_BT_Mode_Disconnect;
    480          				enter_into_BT_Mode(0);
    481          				break;
    482          			case EVENT_USB_CABLE_INSERT:
    483          				//切换到USB HID模式
    484          				exit_from_BT_Mode(1);
    485          				last_state = STATE_BT_Mode_Disconnect;
    486          				device_current_state = STATE_HID_Mode;
    487          				enter_into_USB_HID_Mode();
    488          				break;
    489          			case EVENT_USB_CABLE_REMOVE:
    490          				break;
    491          			case EVENT_LOW_POWER:
    492          				lowpower_tip();
    493          				break;
    494          			default:
    495          				break;
    496          			}
    497          		}
    498          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    499          		{
    500          			switch(event)
    501          			{
    502          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    503          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    504          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    505          				hw_platform_stop_led_blink(LED_GREEN);
    506          				if (ret == 0)
    507          				{
    508          					scan_barcode_ok_tip();
    509          				}
    510          				if (lowpower_state)
    511          				{
    512          					lowpower_tip();
    513          				}
    514          				//只是扫描到条码而已，什么都不做
    515          				break;
    516          			case EVENT_SCAN_KEY_LONG_PRESS:
    517          				hw_platform_stop_led_blink(LED_GREEN);
    518          				//切换到Memory Mode
    519          				exit_from_BT_Mode(2);
    520          				device_current_state = STATE_Memory_Mode;
    521          				hw_platform_beep_ctrl(300,3000);
    522          				enter_into_Memory_Mode();
    523          				break;
    524          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    525          				break;
    526          			case EVENT_ERASE_KEY_LONG_PRESS:
    527          				//已经是配对模式，什么都不做
    528          				break;
    529          			case EVENT_RESET_KEY_PRESS:
    530          				//@todo...
    531          				break;
    532          			case EVENT_BT_CONNECTED:
    533          				//切换到蓝牙连接状态
    534          				exit_from_BT_Mode(2);
    535          				device_current_state = STATE_BT_Mode_Connect;
    536          				enter_into_BT_Mode(1);
    537          				break;
    538          			case EVENT_BT_DISCONNECTED:
    539          				break;
    540          			case EVENT_USB_CABLE_INSERT:
    541          				//切换到USB HID模式
    542          				exit_from_BT_Mode(2);
    543          				last_state = STATE_BT_Mode_WaitPair;
    544          				device_current_state = STATE_HID_Mode;
    545          				enter_into_USB_HID_Mode();
    546          				break;
    547          			case EVENT_USB_CABLE_REMOVE:
    548          				break;
    549          			case EVENT_LOW_POWER:
    550          				lowpower_tip();
    551          				break;
    552          			default:
    553          				break;
    554          			}
    555          		}
    556          		else if(device_current_state ==  STATE_Memory_Mode)
    557          		{
    558          			switch(event)
    559          			{
    560          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    561          				//扫描条码
    562          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    563          				hw_platform_stop_led_blink(LED_GREEN);
    564          				if (ret != 0)
    565          				{
    566          					break;
    567          				}
    568          
    569          				scan_barcode_ok_tip();
    570          				if (lowpower_state)
    571          				{
    572          					lowpower_tip();
    573          				}
    574          				//扫描到条码了
    575          				//将获取到的条码保存到memory
    576          				memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    577          				strcpy((char*)batch_node.barcode,(char const*)barcode);
    578          				ret = record_add((unsigned char*)&batch_node);
    579          				if (ret)
    580          				{
    581          					//记录保存失败，给出提示给用户
    582          					//@todo...
    583          
    584          				}
    585          				break;
    586          			case EVENT_SCAN_KEY_LONG_PRESS:
    587          				hw_platform_stop_led_blink(LED_GREEN);
    588          				//切换至蓝牙模式
    589          				exit_from_Memory_Mode();
    590          				device_current_state = STATE_BT_Mode_Disconnect;
    591          				enter_into_BT_Mode(0);
    592          				break;
    593          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    594          				//删除扫到的条码对应的最后一笔资料
    595          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    596          				if (ret != 0)
    597          				{
    598          					break;
    599          				}
    600          				scan_barcode_ok_tip();
    601          				if (lowpower_state)
    602          				{
    603          					lowpower_tip();
    604          				}
    605          				rec = rec_searchby_tag(barcode,&index);
    606          				if (rec)
    607          				{
    608          					ret = delete_one_node(index);
    609          					if (ret)
    610          					{
    611          						//提示用户，删除失败
    612          						//@todo...
    613          					}
    614          				}
    615          				break;
    616          			case EVENT_ERASE_KEY_LONG_PRESS:
    617          				//删除所有的条码记录
    618          				ret = record_clear();
    619          				if (ret)
    620          				{
    621          					//提示用户，删除失败
    622          					//@todo...
    623          				}
    624          				hw_platform_beep_ctrl(300,3000);
    625          				break;
    626          			case EVENT_RESET_KEY_PRESS:
    627          				//@todo...
    628          				break;
    629          			case EVENT_BT_CONNECTED:
    630          				break;
    631          			case EVENT_BT_DISCONNECTED:
    632          				break;
    633          			case EVENT_USB_CABLE_INSERT:
    634          				//切换到USB HID模式
    635          				exit_from_Memory_Mode();
    636          				last_state = STATE_Memory_Mode;
    637          				device_current_state = STATE_HID_Mode;
    638          				enter_into_USB_HID_Mode();
    639          				break;
    640          			case EVENT_USB_CABLE_REMOVE:
    641          				break;
    642          			case EVENT_LOW_POWER:
    643          				lowpower_tip();
    644          				break;
    645          			default:
    646          				break;
    647          			}
    648          		}
    649          		else if(device_current_state ==  STATE_HID_Mode)
    650          		{
    651          			switch(event)
    652          			{
    653          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    654          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    655          				hw_platform_stop_led_blink(LED_GREEN);
    656          				if(ret !=0)	//扫描条码
    657          				{
    658          					break;
    659          				}
    660          
    661          				scan_barcode_ok_tip();
    662          				//将扫描到的条码通过HID 接口发送出去
    663          				barcode_hid_send(barcode);
    664          				break;
    665          			case EVENT_SCAN_KEY_LONG_PRESS:
    666          				hw_platform_stop_led_blink(LED_GREEN);
    667          				break;
    668          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    669          				break;
    670          			case EVENT_ERASE_KEY_LONG_PRESS:
    671          				//将所有保存在Memory中的条码，全部上传到PC
    672          				hw_platform_beep_ctrl(300,3000);
    673          				cnt = record_module_count();
    674          				for (i = 0; i < cnt;i++)
    675          				{
    676          					rec = get_node((i==0)?0:2,0);
    677          					if (rec)
    678          					{
    679          						barcode_hid_send(((TBATCH_NODE*)rec)->barcode);
    680          					}
    681          					else
    682          					{
    683          						//提示用户读取失败一次
    684          						//@todo...
    685          					}
    686          				}
    687          				hw_platform_beep_ctrl(300,3000);
    688          				break;
    689          			case EVENT_RESET_KEY_PRESS:
    690          				//@todo...
    691          				break;
    692          			case EVENT_BT_CONNECTED:
    693          				break;
    694          			case EVENT_BT_DISCONNECTED:
    695          				break;
    696          			case EVENT_USB_CABLE_INSERT:
    697          				break;
    698          			case EVENT_USB_CABLE_REMOVE:
    699          				//切换到之前的状态
    700          				exit_from_USB_HID_Mode();
    701          				device_current_state = last_state;
    702          				if (device_current_state == STATE_Memory_Mode)
    703          				{
    704          					enter_into_Memory_Mode();
    705          				}
    706          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    707          				{
    708          					enter_into_BT_Mode(2);
    709          				}
    710          				else
    711          				{
    712          					enter_into_BT_Mode(0);
    713          				}
    714          				break;
    715          			case EVENT_LOW_POWER:
    716          				break;
    717          			default:
    718          				break;
    719          			}
    720          		}
    721          	}
    722          }
    723          
    724          /**
    725          * @brief	获取部分异步事件的线程
    726          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    727          *			比如：按键事件会在定时器中断的服务程序post出来
    728          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    729          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    730          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    731          */
    732          void Event_capture_thread(void *p)
    733          {
    734          #ifdef DEBUG_VER
    735          	printf("Enter into Event_capture_thread!\r\n");
    736          #endif
    737          	while (1)
    738          	{
    739          		if (device_current_state == STATE_HID_Mode)
    740          		{
    741          			lowpower_state = 0;
    742          			lowpower_cnt = 0;
    743          			//判断USB线的拔出
    744          			if (bDeviceState == UNCONNECTED)
    745          			{
    746          #ifdef DEBUG_VER
    747          				printf("usb cable remove detected!\r\n");
    748          #endif
    749          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    750          			}
    751          
    752          			if (hw_platform_ChargeState_Detect())
    753          			{
    754          				//充电完成
    755          				hw_platform_led_ctrl(LED_RED,0);
    756          			}
    757          
    758          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    759          		}
    760          		else
    761          		{
    762          			//判断电池电量低
    763          			if (hw_platform_get_PowerClass() == 0)
    764          			{
    765          				lowpower_cnt++;
    766          				if (lowpower_cnt>10)
    767          				{
    768          #ifdef DEBUG_VER
    769          					printf("low power detected!\r\n");
    770          #endif
    771          					if (lowpower_state == 0)
    772          					{
    773          						OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    774          						lowpower_state = 1;
    775          					}
    776          					
    777          				}
    778          			}
    779          			else
    780          			{
    781          				lowpower_cnt = 0;
    782          			}
    783          
    784          			if (bDeviceState == CONFIGURED)
    785          			{
    786          #ifdef DEBUG_VER
    787          				printf("USB HID Enum OK detected!\r\n");
    788          #endif
    789          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_INSERT);
    790          			}
    791          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    792          		}
    793          	}
    794          }
    795          
    796          
    797          /*
    798           * @brief 蓝牙模块维护线程
    799           * @note  此线程需要完成两个任务：
    800           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    801           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    802          */
    803          void BT_Daemon_thread(void *p)
    804          {
    805          	int ret;
    806                  unsigned int len;
    807          	unsigned char	err;
    808          	unsigned char	*pbarcode;
    809          
    810          	ret = WBTD_init();
    811          	if (ret)
    812          	{
    813          		WBTD_Reset();
    814          		ret = WBTD_init();
    815          		assert(ret == 0);
    816          	}
    817          
    818          #ifdef DEBUG_VER
    819          	printf("WBTD init Success!\r\n");
    820          #endif
    821          
    822          	while (1)
    823          	{
    824          		ret = WBTD_got_notify_type();
    825          		if ((ret == 1) || (ret == 2))
    826          		{
    827          #ifdef DEBUG_VER
    828          			printf("WBTD got notify = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    829          #endif
    830          			OSQPost(pEvent_Queue,(void*)((ret == 1)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    831          		}
    832          
    833          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    834          		if (pbarcode)
    835          		{
    836          #ifdef DEBUG_VER
    837          			printf("WBTD got data(%s) to send!\r\n",pbarcode);
    838          #endif
    839          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    840          			{
    841          				//发送失败应该怎么处理，什么都不做了么????!!!!
    842          				//@todo...
    843          #ifdef DEBUG_VER
    844          				printf("WBTD send data Fail!\r\n");
    845          #endif
    846          			}
    847          
    848          #ifdef DEBUG_VER
    849          			printf("WBTD send data Success!\r\n");
    850          #endif
    851          		}
    852          	}
    853          }
    854          
    855          
    856          /*
    857           * @brief进入U盘模式
    858          */
    859          void u_disk_proc(void)
    860          {
    861          	//g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
    862          	//usb_device_init(USB_MASSSTORAGE);
    863          
    864          	OSSchedLock();
    865          
    866          	while(hw_platform_USBcable_Insert_Detect() == 1)
    867          	{	
    868          		if(bDeviceState != CONFIGURED)
    869          		{
    870          			break;
    871          		}
    872          
    873          		delay_ms(1);
    874          	}
    875          
    876          	OSSchedUnlock();
    877          }
    878          
    879          /*
    880           * @brief 低电量提示,红灯持续5S的闪烁
    881           * @return 0:提示期间没有USB线的插入		1:提示期间有USB线的插入
    882          */
    883          int lowpower_tip(void)
    884          {
    885          	int i;
    886          	OSSchedLock();
    887          	hw_platform_start_led_blink(LED_RED,5);
    888          	for (i = 0; i<20;i++)
    889          	{
    890          		hw_platform_beep_ctrl(50,1000);
    891          		if (hw_platform_USBcable_Insert_Detect())
    892          		{
    893          			hw_platform_stop_led_blink(LED_RED);
    894          			OSSchedUnlock();
    895          			return 1;
    896          		}
    897          	}
    898          	hw_platform_stop_led_blink(LED_RED);
    899          	OSSchedUnlock();
    900          	return 0;
    901          }
    902          
    903          /*
    904           * @brief 系统错误的提示
    905          */
    906          void system_err_tip(void)
    907          {
    908          	while(1)
    909          	{
    910          		//@todo...
    911          	}
    912          }
    913          
    914          
    915          // Cortex System Control register address
    916          #define SCB_SysCtrl					((u32)0xE000ED10)
    917          // SLEEPDEEP bit mask
    918          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
    919          
    920          /*
    921           * @brief 初始化线程
    922           */
    923          void app_init_thread(void *p)
    924          {
    925          	int ret;
    926          #ifdef DEBUG_VER
    927          	printf("app init thread startup...\r\n");
    928          #endif
    929          
    930          	OS_CPU_SysTickInit();
    931          
    932          	app_init();
    933          
    934          	Keypad_Init();
    935          
    936          	ret = record_module_init();
    937          	if (ret != 0)
    938          	{
    939          		system_err_tip();
    940          	}
    941          
    942          	if (recover_record_by_logfile())
    943          	{
    944          		system_err_tip();
    945          	}
    946          
    947          	if (ReadTerminalPara())
    948          	{
    949          		if (DefaultTerminalPara())
    950          		{
    951          			system_err_tip();
    952          		}
    953          	}
    954          
    955          	if (g_param.last_state == 1)
    956          	{
    957          		device_current_state = STATE_Memory_Mode;	//脱机状态
    958          		enter_into_Memory_Mode();
    959          	}
    960          	else
    961          	{
    962          		device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
    963          		enter_into_BT_Mode(0);
    964          	}
    965          
    966          	scanner_mod_init();
    967          
    968          	usb_device_init(USB_KEYBOARD);
    969          
    970          	OSTaskCreateExt(State_Machine_thread,
    971          		(void *)0,
    972          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
    973          		8,
    974          		8,
    975          		&thread_statemachine_stk[0],
    976          		STACK_SIZE_TASKSM,
    977          		(void *)0,
    978          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    979          
    980          	OSTaskCreateExt(Event_capture_thread,
    981          		(void *)0,
    982          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
    983          		7,
    984          		7,
    985          		&thread_eventcapture_stk[0],
    986          		STACK_SIZE_TASKEC,
    987          		(void *)0,
    988          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    989          
    990          	OSTaskCreateExt(BT_Daemon_thread,
    991          		(void *)0,
    992          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
    993          		6,
    994          		6,
    995          		&thread_bt_stk[0],
    996          		STACK_SIZE_TASKBT,
    997          		(void *)0,
    998          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    999          
   1000          	OSTimeDlyHMSM(0,0,0,10);
   1001          	OSTaskDel(OS_PRIO_SELF);
   1002          }
   1003          
   1004          /*
   1005           * @brief 启动应用
   1006           */
   1007          void app_startup(void)
   1008          {
   1009          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
   1010          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
   1011          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
   1012          
   1013          	OSInit();
   1014          
   1015          	OSDebugInit();
   1016          
   1017          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI*sizeof(OS_STK));
   1018          	assert(p_init_thread_stk != 0);
   1019          
   1020          	OSTaskCreateExt(app_init_thread,
   1021          		(void *)0,
   1022          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
   1023          		5,
   1024          		5,
   1025          		&p_init_thread_stk[0],
   1026          		STACK_SIZE_TASKINI,
   1027          		(void *)0,
   1028          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1029          
   1030          	OSStart();
   1031          }
   1032          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            16
     Event_capture_thread         8
     State_Machine_thread       136
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           8
     enter_into_Memory_Mode       8
     enter_into_USB_HID_Mode      8
     exit_from_BT_Mode            8
     exit_from_Memory_Mode        8
     exit_from_USB_HID_Mode       8
     lowpower_tip                 8
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     scan_barcode_ok_tip          8
     system_err_tip               0
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1024
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  60
     barcode_cash                                1232
     lowpower_state                                 1
     lowpower_cnt                                   1
     batch_node                                   108
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     keypress_timeout                               4
     scan_barcode_ok_tip                           42
     push_barcode_into_cash                       150
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                        28
     exit_from_Memory_Mode                         16
     enter_into_USB_HID_Mode                      104
     exit_from_USB_HID_Mode                        24
     enter_into_BT_Mode                            96
     exit_from_BT_Mode                             64
     barcode_hid_send                              92
     app_init                                     176
     State_Machine_thread                        1348
     Event_capture_thread                         200
     BT_Daemon_thread                             188
     u_disk_proc                                   38
     lowpower_tip                                  70
     system_err_tip                                 2
     app_init_thread                              248
     app_startup                                  156
     ??DataTable21                                  4
     ??DataTable25                                  4
     ??DataTable69                                  4
     ??DataTable72                                  4
     ??DataTable73                                  4
     ??DataTable74                                  4
     ??DataTable75                                  4
     ??DataTable76                                  4
     ??DataTable77                                  4
     ??DataTable79                                  4
     ??DataTable80                                  4
     ??DataTable81                                  4
     ??DataTable82                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "enter into Memory Mode\r\n">      28
     ?<Constant "exit from Memory Mode\r\n">       24
     ?<Constant "enter into USB HID Mo...">        28
     ?<Constant "exit from USB HID Mode\r\n">      28
     ?<Constant "enter into BT Mode:%d\r\n">       24
     ?<Constant "exit from BT Mode:%d\r\n">        24
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "current state:%d\r\n">            20
     ?<Constant "event:%d\r\n">                    12
     ?<Constant "0">                                2
     ?<Constant "Enter into Event_capt...">        36
     ?<Constant "usb cable remove dete...">        32
     ?<Constant "low power detected!\r\n">         24
     ?<Constant "USB HID Enum OK detec...">        28
     ?<Constant "ret == 0">                        12
     ?<Constant "WBTD init Success!\r\n">          24
     ?<Constant "WBTD got notify = %s!\r\n">       24
     ?<Constant "Connected">                       12
     ?<Constant "Disconnect">                      12
     ?<Constant "WBTD got data(%s) to ...">        32
     ?<Constant "WBTD send data Fail!\r\n">        24
     ?<Constant "WBTD send data Succes...">        28
     ?<Constant "app init thread start...">        32
     ?<Constant "p_init_thread_stk != 0">          24

 
 3 506 bytes in section .bss
   830 bytes in section .rodata
 3 236 bytes in section .text
 
 3 202 bytes of CODE  memory (+ 34 bytes shared)
   830 bytes of CONST memory
 3 506 bytes of DATA  memory

Errors: none
Warnings: none
