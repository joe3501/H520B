###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     10/Oct/2015  17:25:50 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\app.c                                #
#    Command line =  E:\H520B\FW\src\App\app.c -D DEBUG_VER -lcN              #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\app.lst       #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\app.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief H520B 蓝牙条码数据采集器项目APP
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "ucos_ii.h"
     17          #include "app.h"
     18          #include "hw_platform.h"
     19          #include "usb_pwr.h"
     20          #include <string.h>
     21          #include <assert.h>
     22          #include "JMemory.h"
     23          #include "TimeBase.h"
     24          #include "hw_config.h"
     25          #include "basic_fun.h"
     26          #include <stdio.h>
     27          #include "record_m.h"
     28          #include "Terminal_Para.h"
     29          #include "usb_lib.h"
     30          #include "PCUsart.h"
     31          
     32          //定义主状态机线程与蓝牙模块线程之间通讯的IPC对象
     33          #define BARCODE_CASH_NUM	15			//定义等待蓝牙模块线程发送的条码缓冲区为15个条码
     34          #define MAX_BARCODE_LEN		80			//定义条码最大长度为80个字节
     35          
     36          //define the stack size of each task
     37          #define STACK_SIZE_TASKEC			128	
     38          #define STACK_SIZE_TASKSM			356
     39          #define STACK_SIZE_TASKBT			128
     40          #define STACK_SIZE_TASKINI			224
     41          
     42          static OS_STK	thread_eventcapture_stk[STACK_SIZE_TASKEC];		//the stack of the Event_capture_thread
     43          static OS_STK	thread_statemachine_stk[STACK_SIZE_TASKSM];		//the stack of the State_Machine_thread
     44          static OS_STK	thread_bt_stk[STACK_SIZE_TASKBT];				//the stack of the BT_Daemon_thread
     45          static OS_STK	*p_init_thread_stk;								//此线程的栈动态创建，线程结束自己释放
     46          
     47          static void *barcode_pool[BARCODE_CASH_NUM];	//保存获取到的条码字符串的地址数组
     48          static unsigned char barcode_cash[BARCODE_CASH_NUM][MAX_BARCODE_LEN+2];	//最后一个字节表示此行数据是否被送入pool中待发送了
     49          static	unsigned char	lowpower_state;
     50          static	unsigned char	lowpower_cnt;
     51          static  TBATCH_NODE		batch_node;
     52          /*
     53          ------------------------------------------------------------
     54          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     55          ------------------------------------------------------------
     56          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     57          ------------------------------------------------------------
     58          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     59          ------------------------------------------------------------
     60          .........
     61          ------------------------------------------------------------
     62          |               barcode[MAX_BARCODE_LEN+1]              |flag|
     63          ------------------------------------------------------------
     64          */
     65          //定义条码的静态缓冲区，以免动态分配内存
     66          static OS_EVENT	*pBarcode_Queue;			//barcode消息队列
     67          
     68          
     69          #define EVENT_CASH_NUM		8			//定义事件的缓存数量
     70          //定义事件监测线程与主状态机之间通讯的IPC对象
     71          static void *event_pool[EVENT_CASH_NUM];		//事件缓存
     72          OS_EVENT	*pEvent_Queue;			//事件消息队列
     73          
     74          static OS_EVENT *pIOSem;				//IO信号量
     75          //
     76          
     77          unsigned int	device_current_state;		//设备主状态机
     78          
     79          unsigned int	keypress_timeout;
     80          
     81          
     82          void u_disk_proc(void);
     83          int lowpower_tip(void);
     84          void system_err_tip(void);
     85          
     86          extern void EnterLowPowerMode(void);
     87          extern void ExitLowPowerMode(void);
     88          
     89          
     90          /**
     91          * @brief	扫描条码成功的提示
     92          */
     93          static inline void scan_barcode_ok_tip(void)
     94          {
     95          	hw_platform_led_ctrl(LED_YELLOW,1);
     96          	if (g_param.motor_enable)
     97          	{
     98          		hw_platform_beep_motor_ctrl(100,4000);
     99          	}
    100          	else
    101          	{
    102          		hw_platform_beep_ctrl(100,4000);
    103          	}
    104          	
    105          	OSTimeDlyHMSM(0,0,0,10);
    106          	hw_platform_led_ctrl(LED_YELLOW,0);
    107          }
    108          
    109          /**
    110          * @brief	将条码推入条码的静态缓冲区，返回保存的地址
    111          * @param[in] unsigned char* barcode				需要缓存的条码
    112          * @return   缓存的地址
    113          * @note 策略:只要找到一个空位置就放进去，每一列的最后一个字节为0表示该位置是空的
    114          *											     最后一个字节0x55表示该位置已经缓存了条码
    115          */
    116          unsigned char * push_barcode_into_cash(unsigned char* barcode)
    117          {
    118          	unsigned int	i;
    119          	for (i = 0; i < BARCODE_CASH_NUM;i++)
    120          	{
    121          		if (barcode_cash[i][MAX_BARCODE_LEN+1] == 0)
    122          		{
    123          			if (strlen((char const*)barcode) > MAX_BARCODE_LEN)
    124          			{
    125          				memcpy(barcode_cash[i],barcode,MAX_BARCODE_LEN);
    126          				barcode_cash[i][MAX_BARCODE_LEN] = 0;
    127          			}
    128          			else
    129          			{
    130          				strcpy((char*)barcode_cash[i],(char const*)barcode);
    131          			}
    132          			barcode_cash[i][MAX_BARCODE_LEN+1] = 0x55;		//表示已经缓存数据了
    133          			return (void*)barcode_cash[i];
    134          		}
    135          	}
    136          
    137          	return (void*)0;
    138          }
    139          
    140          
    141          /**
    142          * @brief	将已经发送出去的缓存地址pull出来
    143          * @param[in] unsigned char* barcode_addr    一个合法的缓存区的地址
    144          * @return   none
    145          */
    146          void pull_barcode_from_cash(unsigned char* barcode_addr)
    147          {
    148          	assert((int)barcode_addr >= (int)barcode_cash[0]);
    149          	assert((int)barcode_addr <= (int)barcode_cash[BARCODE_CASH_NUM-1]);
    150          	assert(((int)barcode_addr - (int)barcode_cash[0])%(MAX_BARCODE_LEN+2) == 0);
    151          
    152          	//memset(barcode_addr,0,MAX_BARCODE_LEN+2);
    153          	barcode_addr[MAX_BARCODE_LEN+1] = 0;		//把标志恢复为0即可
    154          	return;
    155          }
    156          
    157          
    158          
    159          /**
    160          * @brief	进入Memory模式时，需要进行的一些设置
    161          */
    162          static inline void enter_into_Memory_Mode(void)
    163          {
    164          #ifdef DEBUG_VER
    165          	printf("enter into Memory Mode\r\n");
    166          #endif
    167          	g_param.last_state = 1;
    168          	SaveTerminalPara();
    169          }
    170          
    171          /**
    172          * @brief	退出Memory模式时，需要进行的一些设置
    173          */
    174          static inline void exit_from_Memory_Mode(void)
    175          {
    176          #ifdef DEBUG_VER
    177          	printf("exit from Memory Mode\r\n");
    178          #endif
    179          	//@todo...
    180          }
    181          
    182          /**
    183          * @brief	进入USB HID模式时，需要进行的一些设置
    184          */
    185          static inline void enter_into_USB_HID_Mode(void)
    186          {
    187          #ifdef DEBUG_VER
    188          	printf("enter into USB HID Mode\r\n");
    189          #endif
    190          	hw_platform_led_ctrl(LED_RED,1);
    191          	//hw_platform_beep_ctrl(100,1045);
    192          	//hw_platform_beep_ctrl(100,1171);
    193          	//hw_platform_beep_ctrl(100,1316);
    194          	//hw_platform_beep_ctrl(100,1393);
    195          	//hw_platform_beep_ctrl(100,1563);
    196          	//hw_platform_beep_ctrl(100,1755);
    197          	//hw_platform_beep_ctrl(100,1971);
    198          
    199          	hw_platform_beep_ctrl(100,1316);
    200          	hw_platform_beep_ctrl(100,1316);
    201          	hw_platform_beep_ctrl(100,1393);
    202          	hw_platform_beep_ctrl(100,1563);
    203          	hw_platform_beep_ctrl(100,1563);
    204          	hw_platform_beep_ctrl(100,1393);
    205          	hw_platform_beep_ctrl(100,1316);
    206          	hw_platform_beep_ctrl(100,1171);
    207          }
    208          
    209          /**
    210          * @brief	退出USB HID模式时，需要进行的一些设置
    211          */
    212          static inline void exit_from_USB_HID_Mode(void)
    213          {
    214          #ifdef DEBUG_VER
    215          	printf("exit from USB HID Mode\r\n");
    216          #endif
    217          	hw_platform_led_ctrl(LED_RED,0);
    218          }
    219          
    220          /**
    221          * @brief	进入BT模式时，需要进行的一些设置
    222          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    223          */
    224          static inline void enter_into_BT_Mode(unsigned char child_state)
    225          {
    226          #ifdef DEBUG_VER
    227          	printf("enter into BT Mode:%d\r\n",child_state);
    228          #endif
    229          	if (child_state == 2)
    230          	{
    231          #if(BT_MODULE == USE_WBTDS01)
    232          		WBTD_Reset();
    233          #else
    234          		BT816_enter_pair_mode();
    235          #endif
    236          		hw_platform_beep_ctrl(300,3000);
    237          		hw_platform_start_led_blink(LED_BLUE,10);
    238          #if(BT_MODULE == USE_WBTDS01)
    239          		WBTD_set_autocon(0);
    240          #endif
    241          	}
    242          	else if (child_state == 0)
    243          	{
    244          		hw_platform_start_led_blink(LED_BLUE,150);
    245          	}
    246          	else
    247          	{
    248          		hw_platform_led_ctrl(LED_BLUE,1);
    249          	}
    250          	g_param.last_state = 0;
    251          	SaveTerminalPara();
    252          }
    253          
    254          /**
    255          * @brief	退出BT模式时，需要进行的一些设置
    256          * @param[in] unsigned char	child_state		0: disconnect  1：connected  2：:waitpair
    257          */
    258          static inline void exit_from_BT_Mode(unsigned char child_state)
    259          {
    260          #ifdef DEBUG_VER
    261          	printf("exit from BT Mode:%d\r\n",child_state);
    262          #endif
    263          	if (child_state == 1)
    264          	{
    265          #if(BT_MODULE == USE_WBTDS01)
    266          		WBTD_set_autocon(1);
    267          #else
    268          		BT816_set_autocon(0);
    269          		BT816_hid_disconnect();
    270          #endif
    271          		//delay_ms(1);
    272          		hw_platform_beep_ctrl(300,3000);
    273          		hw_platform_led_ctrl(LED_BLUE,0);
    274          #if(BT_MODULE == USE_WBTDS01)
    275          		WBTD_Reset();//主动断开与蓝牙主机的连接	
    276          #endif	
    277          	}
    278          	else
    279          	{
    280          		hw_platform_stop_led_blink(LED_BLUE);
    281          	}
    282          }
    283          
    284          
    285          /**
    286          * @brief	通过USB HID发送条码
    287          */
    288          static void barcode_hid_send(unsigned char* barcode)
    289          {
    290          	unsigned int	i,code_len;
    291          	unsigned char key_value_report[8];
    292          
    293              code_len = strlen((char const*)barcode);
    294          	OSSchedLock();
    295          	for (i = 0; i < code_len; i++)
    296          	{
    297          		ascii_to_keyreport(barcode[i],key_value_report);
    298          
    299          		SendData_To_PC(key_value_report, 3);
    300          		SendData_To_PC("\x00\x00\x00", 3);
    301          	}
    302          
    303          	memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    304          
    305          	SendData_To_PC(key_value_report, 3);
    306          	SendData_To_PC("\x00\x00\x00", 3);	//弹起
    307          	OSSchedUnlock();
    308          }
    309          
    310          /**
    311          * @brief	应用的初始化
    312          */
    313          void app_init(void)
    314          {
    315          	//创建一个消息队列，用于将事件捕获线程和蓝牙模块线程获取的异步事件通知给主状态机线程
    316          	pEvent_Queue = OSQCreate((void**)&event_pool,EVENT_CASH_NUM);
    317          	assert(pEvent_Queue != (OS_EVENT*)0);
    318          
    319          	//创建一个消息队列，用于将主状态机线程获取的条码传送到蓝牙模块线程.
    320          	pBarcode_Queue =OSQCreate((void**)&barcode_pool,BARCODE_CASH_NUM);
    321          	assert(pBarcode_Queue != (OS_EVENT*)0);
    322          	memset(barcode_cash,0,BARCODE_CASH_NUM*(MAX_BARCODE_LEN+2));
    323          
    324          	//创建一个信号量，用于IO中断通知事件捕获线程，有外部IO产生，需要事件捕获线程开始采取捕获事件的动作
    325          	pIOSem = OSSemCreate(0);
    326          	assert(pIOSem != (OS_EVENT*)0);
    327          
    328          	lowpower_state = 0;
    329          	lowpower_cnt = 0;
    330          }
    331          
    332          /**
    333          * @brief	维护主状态机的线程
    334          */
    335          void State_Machine_thread(void *p)
    336          {
    337          	unsigned int	i,cnt,event;
    338          	unsigned char	err;
    339          	unsigned char	barcode[MAX_BARCODE_LEN+1];
    340          	unsigned char   codetype[20];
    341          	unsigned int    codelen;
    342          	int				ret,index;
    343          	unsigned int	last_state;
    344          	unsigned char	*rec;
    345          
    346          	Jfree(p_init_thread_stk);	//退出初始化线程时，释放自己的任务栈
    347          
    348          	//hw_platform_led_blink_test();		//for test
    349          	//lowpower_tip();					//for test
    350          	//record_m_test();					//for test
    351          	
    352          	while(1)
    353          	{
    354          		event = (unsigned int)OSQPend(pEvent_Queue,25,&err);
    355          		if (event == 0)
    356          		{
    357          			if ((g_param.lower_power_timeout)&&(device_current_state != STATE_HID_Mode))
    358          			{
    359          				keypress_timeout++;
    360          				if (keypress_timeout == g_param.lower_power_timeout*4*60)
    361          				{
    362          					hw_platform_beep_ctrl(500,3000);
    363          					EnterLowPowerMode();
    364          					ExitLowPowerMode();
    365          					hw_platform_beep_ctrl(500,3000);
    366          				}
    367          			}
    368          			continue;
    369          		}
    370          #ifdef DEBUG_VER
    371          		printf("current state:%d\r\n",device_current_state);
    372          		printf("event:%d\r\n",event);
    373          #endif
    374          		if(device_current_state ==  STATE_BT_Mode_Disconnect)
    375          		{
    376          			switch(event)
    377          			{
    378          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    379          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    380          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    381          				hw_platform_stop_led_blink(LED_GREEN);
    382          				if (ret == 0)
    383          				{
    384          					scan_barcode_ok_tip();
    385          				}
    386          
    387          				if (lowpower_state)
    388          				{
    389          					lowpower_tip();
    390          				}
    391          				//只是扫描到条码而已，什么都不做
    392          				break;
    393          			case EVENT_SCAN_KEY_LONG_PRESS:
    394          				//切换到Memory Mode
    395          				hw_platform_stop_led_blink(LED_GREEN);
    396          				exit_from_BT_Mode(0);
    397          				device_current_state = STATE_Memory_Mode;
    398          				hw_platform_beep_ctrl(300,3000);
    399          				enter_into_Memory_Mode();
    400          				break;
    401          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    402          				break;
    403          			case EVENT_ERASE_KEY_LONG_PRESS:
    404          				//切换到配对模式
    405          				exit_from_BT_Mode(0);
    406          				device_current_state = STATE_BT_Mode_WaitPair;
    407          				enter_into_BT_Mode(2);
    408          				break;
    409          			case EVENT_RESET_KEY_PRESS:
    410          				break;
    411          			case EVENT_BT_CONNECTED:
    412          				//切换到蓝牙连接模式
    413          				exit_from_BT_Mode(0);
    414          				device_current_state = STATE_BT_Mode_Connect;
    415          				enter_into_BT_Mode(1);
    416          				break;
    417          			case EVENT_BT_DISCONNECTED:
    418          				break;
    419          			case EVENT_USB_CABLE_INSERT:
    420          				//切换到USB HID模式
    421          				exit_from_BT_Mode(0);
    422          				last_state = STATE_BT_Mode_Disconnect;
    423          				device_current_state = STATE_HID_Mode;
    424          				enter_into_USB_HID_Mode();
    425          				break;
    426          			case EVENT_USB_CABLE_REMOVE:
    427          				break;
    428          			case EVENT_LOW_POWER:
    429          				lowpower_tip();
    430          				break;
    431          			default:
    432          				break;
    433          			}
    434          		}
    435          		else if(device_current_state ==  STATE_BT_Mode_Connect)
    436          		{
    437          			switch(event)
    438          			{
    439          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    440          				//扫描条码
    441          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    442          				hw_platform_stop_led_blink(LED_GREEN);
    443          				if (ret != 0)
    444          				{
    445          					break;
    446          				}
    447          
    448          				scan_barcode_ok_tip();
    449          				if (lowpower_state)
    450          				{
    451          					lowpower_tip();
    452          				}
    453          				//扫描到条码了
    454          				//将获取到的条码先push到cash缓存起来，然后Post到系统的
    455          				//Queue，由蓝牙模块线程负责去发送到主机
    456          repost:
    457          				ret = OSQPost(pBarcode_Queue,(void*)push_barcode_into_cash((unsigned char*)barcode));
    458          				if(ret != OS_ERR_NONE)
    459          				{
    460          					if(ret == OS_ERR_Q_FULL || ret == OS_ERR_PEVENT_NULL)
    461          					{
    462          						//如果队列满了或者空事件时，那么需要延时重试
    463          						OSTimeDlyHMSM(0,0,0,100);
    464          						goto repost;
    465          					}
    466          					else
    467          					{
    468          						assert(0);	//系统错误
    469          					}
    470          				}
    471          				break;
    472          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    473          				if (g_param.ios_softkeypad_enable)
    474          				{
    475          #if(BT_MODULE == USE_WBTDS01)
    476          					WBTD_set_ioskeypad(1);
    477          #else
    478          					BT816_toggle_ioskeypad();
    479          #endif
    480          				}
    481          				break;
    482          			case EVENT_SCAN_KEY_LONG_PRESS:
    483          				hw_platform_stop_led_blink(LED_GREEN);
    484          				//切换到Memory mode
    485          				exit_from_BT_Mode(1);
    486          				device_current_state = STATE_Memory_Mode;
    487          				hw_platform_beep_ctrl(300,3000);
    488          				enter_into_Memory_Mode();
    489          				break;
    490          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    491          #if(BT_MODULE == USE_WBTDS01)
    492          				//WBTD_hid_send_test();
    493          #else
    494          				BT816_hid_send_test();
    495          #endif
    496          				break;
    497          			case EVENT_ERASE_KEY_LONG_PRESS:
    498          				//进入配对模式
    499          				exit_from_BT_Mode(1);
    500          				device_current_state = STATE_BT_Mode_WaitPair;
    501          				enter_into_BT_Mode(2);
    502          				break;
    503          			case EVENT_RESET_KEY_PRESS:
    504          				//@todo...
    505          				break;
    506          			case EVENT_BT_CONNECTED:
    507          				break;
    508          			case EVENT_BT_DISCONNECTED:
    509          				//切换到蓝牙断开状态
    510          				exit_from_BT_Mode(1);
    511          				device_current_state = STATE_BT_Mode_Disconnect;
    512          				enter_into_BT_Mode(0);
    513          				break;
    514          			case EVENT_USB_CABLE_INSERT:
    515          				//切换到USB HID模式
    516          				exit_from_BT_Mode(1);
    517          				last_state = STATE_BT_Mode_Disconnect;
    518          				device_current_state = STATE_HID_Mode;
    519          				enter_into_USB_HID_Mode();
    520          				break;
    521          			case EVENT_USB_CABLE_REMOVE:
    522          				break;
    523          			case EVENT_LOW_POWER:
    524          				lowpower_tip();
    525          				break;
    526          			default:
    527          				break;
    528          			}
    529          		}
    530          		else if(device_current_state ==  STATE_BT_Mode_WaitPair)
    531          		{
    532          			switch(event)
    533          			{
    534          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    535          			case EVENT_SCAN_KEY_DOUBLE_CLICK:
    536          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);	//扫描条码
    537          				hw_platform_stop_led_blink(LED_GREEN);
    538          				if (ret == 0)
    539          				{
    540          					scan_barcode_ok_tip();
    541          				}
    542          				if (lowpower_state)
    543          				{
    544          					lowpower_tip();
    545          				}
    546          				//只是扫描到条码而已，什么都不做
    547          				break;
    548          			case EVENT_SCAN_KEY_LONG_PRESS:
    549          				hw_platform_stop_led_blink(LED_GREEN);
    550          				//切换到Memory Mode
    551          				exit_from_BT_Mode(2);
    552          				device_current_state = STATE_Memory_Mode;
    553          				hw_platform_beep_ctrl(300,3000);
    554          				enter_into_Memory_Mode();
    555          				break;
    556          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    557          				break;
    558          			case EVENT_ERASE_KEY_LONG_PRESS:
    559          				//已经是配对模式，什么都不做
    560          				break;
    561          			case EVENT_RESET_KEY_PRESS:
    562          				//@todo...
    563          				break;
    564          			case EVENT_BT_CONNECTED:
    565          				//切换到蓝牙连接状态
    566          				exit_from_BT_Mode(2);
    567          				device_current_state = STATE_BT_Mode_Connect;
    568          				enter_into_BT_Mode(1);
    569          				break;
    570          			case EVENT_BT_DISCONNECTED:
    571          				break;
    572          			case EVENT_USB_CABLE_INSERT:
    573          				//切换到USB HID模式
    574          				exit_from_BT_Mode(2);
    575          				last_state = STATE_BT_Mode_WaitPair;
    576          				device_current_state = STATE_HID_Mode;
    577          				enter_into_USB_HID_Mode();
    578          				break;
    579          			case EVENT_USB_CABLE_REMOVE:
    580          				break;
    581          			case EVENT_LOW_POWER:
    582          				lowpower_tip();
    583          				break;
    584          			default:
    585          				break;
    586          			}
    587          		}
    588          		else if(device_current_state ==  STATE_Memory_Mode)
    589          		{
    590          			switch(event)
    591          			{
    592          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    593          				//扫描条码
    594          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    595          				hw_platform_stop_led_blink(LED_GREEN);
    596          				if (ret != 0)
    597          				{
    598          					break;
    599          				}
    600          
    601          				scan_barcode_ok_tip();
    602          				if (lowpower_state)
    603          				{
    604          					lowpower_tip();
    605          				}
    606          				//扫描到条码了
    607          				//将获取到的条码保存到memory
    608          				memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    609          				strcpy((char*)batch_node.barcode,(char const*)barcode);
    610          				ret = record_add((unsigned char*)&batch_node);
    611          				if (ret)
    612          				{
    613          					//记录保存失败，给出提示给用户
    614          					//@todo...
    615          
    616          				}
    617          				break;
    618          			case EVENT_SCAN_KEY_LONG_PRESS:
    619          				hw_platform_stop_led_blink(LED_GREEN);
    620          				//切换至蓝牙模式
    621          				exit_from_Memory_Mode();
    622          				device_current_state = STATE_BT_Mode_Disconnect;
    623          				enter_into_BT_Mode(0);
    624          				break;
    625          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    626          				//删除扫到的条码对应的最后一笔资料
    627          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    628          				if (ret != 0)
    629          				{
    630          					break;
    631          				}
    632          				scan_barcode_ok_tip();
    633          				if (lowpower_state)
    634          				{
    635          					lowpower_tip();
    636          				}
    637          				OSSchedLock();
    638          				rec = rec_searchby_tag(barcode,&index);
    639          				OSSchedUnlock();
    640          				if (rec)
    641          				{
    642          					ret = delete_one_node(index);
    643          					if (ret)
    644          					{
    645          						//提示用户，删除失败
    646          						//@todo...
    647          					}
    648          				}
    649          				break;
    650          			case EVENT_ERASE_KEY_LONG_PRESS:
    651          				//删除所有的条码记录
    652          				ret = record_clear();
    653          				if (ret)
    654          				{
    655          					//提示用户，删除失败
    656          					//@todo...
    657          				}
    658          				hw_platform_beep_ctrl(300,3000);
    659          				break;
    660          			case EVENT_RESET_KEY_PRESS:
    661          				//@todo...
    662          				break;
    663          			case EVENT_BT_CONNECTED:
    664          				break;
    665          			case EVENT_BT_DISCONNECTED:
    666          				break;
    667          			case EVENT_USB_CABLE_INSERT:
    668          				//切换到USB HID模式
    669          				exit_from_Memory_Mode();
    670          				last_state = STATE_Memory_Mode;
    671          				device_current_state = STATE_HID_Mode;
    672          				enter_into_USB_HID_Mode();
    673          				break;
    674          			case EVENT_USB_CABLE_REMOVE:
    675          				break;
    676          			case EVENT_LOW_POWER:
    677          				lowpower_tip();
    678          				break;
    679          			default:
    680          				break;
    681          			}
    682          		}
    683          		else if(device_current_state ==  STATE_HID_Mode)
    684          		{
    685          			switch(event)
    686          			{
    687          			case EVENT_SCAN_KEY_SINGLE_CLICK:
    688          				ret = scanner_get_barcode(barcode,MAX_BARCODE_LEN,codetype,&codelen);
    689          				hw_platform_stop_led_blink(LED_GREEN);
    690          				if(ret !=0)	//扫描条码
    691          				{
    692          					break;
    693          				}
    694          
    695          				scan_barcode_ok_tip();
    696          				//将扫描到的条码通过HID 接口发送出去
    697          				barcode_hid_send(barcode);
    698          				break;
    699          			case EVENT_SCAN_KEY_LONG_PRESS:
    700          				hw_platform_stop_led_blink(LED_GREEN);
    701          				break;
    702          			case EVENT_ERASE_KEY_SINGLE_CLICK:
    703          				break;
    704          			case EVENT_ERASE_KEY_LONG_PRESS:
    705          				//将所有保存在Memory中的条码，全部上传到PC
    706          				hw_platform_beep_ctrl(300,3000);
    707          				cnt = record_module_count();
    708          				for (i = 0; i < cnt;i++)
    709          				{
    710          					rec = get_node((i==0)?0:2,0);
    711          					if (rec)
    712          					{
    713          						barcode_hid_send(((TBATCH_NODE*)rec)->barcode);
    714          					}
    715          					else
    716          					{
    717          						//提示用户读取失败一次
    718          						//@todo...
    719          					}
    720          				}
    721          				hw_platform_beep_ctrl(300,3000);
    722          				break;
    723          			case EVENT_RESET_KEY_PRESS:
    724          				//@todo...
    725          				break;
    726          			case EVENT_BT_CONNECTED:
    727          				break;
    728          			case EVENT_BT_DISCONNECTED:
    729          				break;
    730          			case EVENT_USB_CABLE_INSERT:
    731          				break;
    732          			case EVENT_USB_CABLE_REMOVE:
    733          				//切换到之前的状态
    734          				exit_from_USB_HID_Mode();
    735          				device_current_state = last_state;
    736          				if (device_current_state == STATE_Memory_Mode)
    737          				{
    738          					enter_into_Memory_Mode();
    739          				}
    740          				else if (device_current_state == STATE_BT_Mode_WaitPair)
    741          				{
    742          					enter_into_BT_Mode(2);
    743          				}
    744          				else
    745          				{
    746          					enter_into_BT_Mode(0);
    747          				}
    748          				break;
    749          			case EVENT_LOW_POWER:
    750          				break;
    751          			default:
    752          				break;
    753          			}
    754          		}
    755          	}
    756          }
    757          
    758          /**
    759          * @brief	获取部分异步事件的线程
    760          * @note     另外一些异步事件的检测在中断服务程序中post或者另外的线程post出来
    761          *			比如：按键事件会在定时器中断的服务程序post出来
    762          *				  USB线的插入（实际上是USB HID device被枚举成功）会在USB的中断服务程序给出
    763          *				  蓝牙连接的状态变化会在蓝牙模块的维护线程给出
    764          *				  此线程只负责一些周期性的状态检查事件，电池电量低、USB线是否被拔出
    765          */
    766          void Event_capture_thread(void *p)
    767          {
    768          #ifdef DEBUG_VER
    769          	printf("Enter into Event_capture_thread!\r\n");
    770          #endif
    771          	while (1)
    772          	{
    773          		if (device_current_state == STATE_HID_Mode)
    774          		{
    775          			lowpower_state = 0;
    776          			lowpower_cnt = 0;
    777          			//判断USB线的拔出
    778          			if (bDeviceState == UNCONNECTED)
    779          			{
    780          #ifdef DEBUG_VER
    781          				printf("usb cable remove detected!\r\n");
    782          #endif
    783          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_REMOVE);
    784          			}
    785          
    786          			if (hw_platform_ChargeState_Detect())
    787          			{
    788          				//充电完成
    789          				hw_platform_led_ctrl(LED_RED,0);
    790          			}
    791          
    792          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    793          		}
    794          		else
    795          		{
    796          			//判断电池电量低
    797          			if (hw_platform_get_PowerClass() == 0)
    798          			{
    799          				lowpower_cnt++;
    800          				if (lowpower_cnt>10)
    801          				{
    802          #ifdef DEBUG_VER
    803          					printf("low power detected!\r\n");
    804          #endif
    805          					if (lowpower_state == 0)
    806          					{
    807          						OSQPost(pEvent_Queue,(void*)EVENT_LOW_POWER);
    808          						lowpower_state = 1;
    809          					}
    810          					
    811          				}
    812          			}
    813          			else
    814          			{
    815          				lowpower_cnt = 0;
    816          			}
    817          
    818          			if (bDeviceState == CONFIGURED)
    819          			{
    820          #ifdef DEBUG_VER
    821          				printf("USB HID Enum OK detected!\r\n");
    822          #endif
    823          				OSQPost(pEvent_Queue,(void*)EVENT_USB_CABLE_INSERT);
    824          			}
    825          			OSTimeDlyHMSM(0,0,0,50);	//50ms的频率运行此线程
    826          		}
    827          	}
    828          }
    829          
    830          
    831          /*
    832           * @brief 蓝牙模块维护线程
    833           * @note  此线程需要完成两个任务：
    834           *        1 : 监测蓝牙模块是否有返回连接状态变化的指示信号回来，如果监测到了，发出事件消息出来
    835           *        2 ：检测是否有数据需要通过蓝牙模块发送，如果有就发送出去
    836          */
    837          void BT_Daemon_thread(void *p)
    838          {
    839          #if(BT_MODULE == USE_BT816)
    840          	static unsigned int last_status;
    841          #endif
    842          	int ret;
    843              unsigned int len;
    844          	unsigned char	err;
    845          	unsigned char	*pbarcode;
    846          
    847          #if(BT_MODULE == USE_WBTDS01)
    848          	ret = WBTD_init();
    849          #else
    850          	ret = BT816_init();
    851          	last_status = BT_MODULE_STATUS_DISCONNECT;
    852          #endif
    853          	if (ret)
    854          	{
    855          #if(BT_MODULE == USE_WBTDS01)
    856          		WBTD_Reset();
    857          		ret = WBTD_init();
    858          #else
    859          		ret = BT816_init();
    860          #endif
    861          		assert(ret == 0);
    862          	}
    863          
    864          #ifdef DEBUG_VER
    865          	printf("BT Module init Success!\r\n");
    866          #endif
    867          
    868          	while (1)
    869          	{
    870          #if(BT_MODULE == USE_WBTDS01)
    871          		ret = WBTD_got_notify_type();
    872          		if ((ret == BT_MODULE_STATUS_CONNECTED) || (ret == BT_MODULE_STATUS_DISCONNECT))
    873          		{
    874          #ifdef DEBUG_VER
    875          			printf("BT Module Status = %s!\r\n",(ret==1)?"Connected":"Disconnect");
    876          #endif
    877          			OSQPost(pEvent_Queue,(void*)((ret == BT_MODULE_STATUS_CONNECTED)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    878          		}
    879          #else
    880          		ret = BT816_hid_status();
    881          		if ((ret == BT_MODULE_STATUS_CONNECTED)||(ret == BT_MODULE_STATUS_DISCONNECT))
    882          		{
    883          			if (ret != last_status)
    884          			{
    885          				last_status = ret;
    886          
    887          #ifdef DEBUG_VER
    888          				printf("BT Module Status = %s!\r\n",(ret==BT_MODULE_STATUS_CONNECTED)?"Connected":"Disconnect");
    889          #endif
    890          				OSQPost(pEvent_Queue,(void*)((ret == BT_MODULE_STATUS_CONNECTED)?EVENT_BT_CONNECTED:EVENT_BT_DISCONNECTED));
    891          			}
    892          		}
    893          #endif
    894          
    895          
    896          		pbarcode = (unsigned char*)OSQPend(pBarcode_Queue,20,&err);
    897          		if (pbarcode)
    898          		{
    899          #ifdef DEBUG_VER
    900          			printf("BT Module got data(%s) to send!\r\n",pbarcode);
    901          #endif
    902          #if(BT_MODULE == USE_WBTDS01)
    903          			if (WBTD_hid_send(pbarcode,strlen((char const*)pbarcode),&len))
    904          #else
    905          			if (BT816_hid_send(pbarcode,strlen((char const*)pbarcode)))
    906          #endif
    907          			{
    908          				//发送失败应该怎么处理，什么都不做了么????!!!!
    909          				//@todo...
    910          #ifdef DEBUG_VER
    911          				printf("BT Module send data Fail!\r\n");
    912          #endif
    913          			}
    914          			else
    915          			{
    916          				pull_barcode_from_cash(pbarcode);
    917          				//OSTimeDlyHMSM(0,0,0,50);
    918          
    919          #ifdef DEBUG_VER
    920          				printf("BT Module send data Success!\r\n");
    921          #endif
    922          			}
    923          		}
    924          	}
    925          }
    926          
    927          
    928          /*
    929           * @brief进入U盘模式
    930          */
    931          void u_disk_proc(void)
    932          {
    933          	//g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
    934          	//usb_device_init(USB_MASSSTORAGE);
    935          
    936          	OSSchedLock();
    937          
    938          	while(hw_platform_USBcable_Insert_Detect() == 1)
    939          	{	
    940          		if(bDeviceState != CONFIGURED)
    941          		{
    942          			break;
    943          		}
    944          
    945          		delay_ms(1);
    946          	}
    947          
    948          	OSSchedUnlock();
    949          }
    950          
    951          /*
    952           * @brief 低电量提示,红灯持续5S的闪烁
    953           * @return 0:提示期间没有USB线的插入		1:提示期间有USB线的插入
    954          */
    955          int lowpower_tip(void)
    956          {
    957          	int i;
    958          	OSSchedLock();
    959          	hw_platform_start_led_blink(LED_RED,5);
    960          	for (i = 0; i<20;i++)
    961          	{
    962          		hw_platform_beep_ctrl(50,1000);
    963          		if (hw_platform_USBcable_Insert_Detect())
    964          		{
    965          			hw_platform_stop_led_blink(LED_RED);
    966          			OSSchedUnlock();
    967          			return 1;
    968          		}
    969          	}
    970          	hw_platform_stop_led_blink(LED_RED);
    971          	OSSchedUnlock();
    972          	return 0;
    973          }
    974          
    975          /*
    976           * @brief 系统错误的提示
    977          */
    978          void system_err_tip(void)
    979          {
    980          	while(1)
    981          	{
    982          		//@todo...
    983          	}
    984          }
    985          
    986          
    987          // Cortex System Control register address
    988          #define SCB_SysCtrl					((u32)0xE000ED10)
    989          // SLEEPDEEP bit mask
    990          #define SysCtrl_SLEEPDEEP_Set		((u32)0x00000004)
    991          
    992          /*
    993           * @brief 初始化线程
    994           */
    995          void app_init_thread(void *p)
    996          {
    997          	int ret;
    998          #ifdef DEBUG_VER
    999          	printf("app init thread startup...\r\n");
   1000          #endif
   1001          
   1002          	OS_CPU_SysTickInit();
   1003          
   1004          	app_init();
   1005          
   1006          	Keypad_Init();
   1007          
   1008          	ret = record_module_init();
   1009          	if (ret != 0)
   1010          	{
   1011          		system_err_tip();
   1012          	}
   1013          
   1014          	if (recover_record_by_logfile())
   1015          	{
   1016          		system_err_tip();
   1017          	}
   1018          
   1019          	if (ReadTerminalPara())
   1020          	{
   1021          		if (DefaultTerminalPara())
   1022          		{
   1023          			system_err_tip();
   1024          		}
   1025          	}
   1026          
   1027          	if (g_param.last_state == 1)
   1028          	{
   1029          		device_current_state = STATE_Memory_Mode;	//脱机状态
   1030          		enter_into_Memory_Mode();
   1031          	}
   1032          	else
   1033          	{
   1034          		device_current_state = STATE_BT_Mode_Disconnect;	//蓝牙模式未连接状态
   1035          		enter_into_BT_Mode(0);
   1036          	}
   1037          
   1038          	scanner_mod_init();
   1039          
   1040          	usb_device_init(USB_KEYBOARD);
   1041          
   1042          	OSTaskCreateExt(State_Machine_thread,
   1043          		(void *)0,
   1044          		&thread_statemachine_stk[STACK_SIZE_TASKSM-1],
   1045          		8,
   1046          		8,
   1047          		&thread_statemachine_stk[0],
   1048          		STACK_SIZE_TASKSM,
   1049          		(void *)0,
   1050          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1051          
   1052          	OSTaskCreateExt(Event_capture_thread,
   1053          		(void *)0,
   1054          		&thread_eventcapture_stk[STACK_SIZE_TASKEC-1],
   1055          		7,
   1056          		7,
   1057          		&thread_eventcapture_stk[0],
   1058          		STACK_SIZE_TASKEC,
   1059          		(void *)0,
   1060          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1061          
   1062          	OSTaskCreateExt(BT_Daemon_thread,
   1063          		(void *)0,
   1064          		&thread_bt_stk[STACK_SIZE_TASKBT-1],
   1065          		6,
   1066          		6,
   1067          		&thread_bt_stk[0],
   1068          		STACK_SIZE_TASKBT,
   1069          		(void *)0,
   1070          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1071          
   1072          	OSTimeDlyHMSM(0,0,0,10);
   1073          	OSTaskDel(OS_PRIO_SELF);
   1074          }
   1075          
   1076          /*
   1077           * @brief 启动应用
   1078           */
   1079          void app_startup(void)
   1080          {
   1081          	memset((void*)thread_eventcapture_stk, 0xAA, sizeof(thread_eventcapture_stk));
   1082          	memset((void*)thread_statemachine_stk, 0xBB, sizeof(thread_statemachine_stk));
   1083          	memset((void*)thread_bt_stk, 0xCC, sizeof(thread_bt_stk));
   1084          
   1085          	OSInit();
   1086          
   1087          	OSDebugInit();
   1088          
   1089          	p_init_thread_stk = (OS_STK*)Jmalloc(STACK_SIZE_TASKINI*sizeof(OS_STK));
   1090          	assert(p_init_thread_stk != 0);
   1091          
   1092          	OSTaskCreateExt(app_init_thread,
   1093          		(void *)0,
   1094          		&p_init_thread_stk[STACK_SIZE_TASKINI-1],
   1095          		5,
   1096          		5,
   1097          		&p_init_thread_stk[0],
   1098          		STACK_SIZE_TASKINI,
   1099          		(void *)0,
   1100          		(INT16U)(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
   1101          
   1102          	OSStart();
   1103          }
   1104          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BT_Daemon_thread            16
     Event_capture_thread         8
     State_Machine_thread       136
     app_init                     8
     app_init_thread             32
     app_startup                 32
     barcode_hid_send            24
     enter_into_BT_Mode           8
     enter_into_Memory_Mode       8
     enter_into_USB_HID_Mode      8
     exit_from_BT_Mode            8
     exit_from_Memory_Mode        8
     exit_from_USB_HID_Mode       8
     lowpower_tip                 8
     memcpy                       8
     memset                       8
     pull_barcode_from_cash       8
     push_barcode_into_cash      16
     scan_barcode_ok_tip          8
     system_err_tip               0
     u_disk_proc                  8


   Section sizes:

     Function/Label                              Bytes
     --------------                              -----
     memcpy                                        14
     memset                                        20
     thread_eventcapture_stk                      512
     thread_statemachine_stk                     1424
     thread_bt_stk                                512
     p_init_thread_stk                              4
     barcode_pool                                  60
     barcode_cash                                1232
     lowpower_state                                 1
     lowpower_cnt                                   1
     batch_node                                    84
     pBarcode_Queue                                 4
     event_pool                                    32
     pEvent_Queue                                   4
     pIOSem                                         4
     device_current_state                           4
     keypress_timeout                               4
     scan_barcode_ok_tip                           64
     push_barcode_into_cash                       114
     pull_barcode_from_cash                       108
     enter_into_Memory_Mode                        28
     exit_from_Memory_Mode                         16
     enter_into_USB_HID_Mode                      104
     exit_from_USB_HID_Mode                        24
     enter_into_BT_Mode                            88
     exit_from_BT_Mode                             64
     barcode_hid_send                              92
     app_init                                     176
     State_Machine_thread                        1384
     Event_capture_thread                         200
     BT_Daemon_thread                             216
     last_status                                    4
     u_disk_proc                                   38
     lowpower_tip                                  70
     system_err_tip                                 2
     app_init_thread                              248
     app_startup                                  156
     ??DataTable20                                  4
     ??DataTable24                                  4
     ??DataTable69                                  4
     ??DataTable72                                  4
     ??DataTable73                                  4
     ??DataTable74                                  4
     ??DataTable75                                  4
     ??DataTable76                                  4
     ??DataTable77                                  4
     ??DataTable79                                  4
     ??DataTable80                                  4
     ??DataTable81                                  4
     ??DataTable82                                  4
     ?<Constant "(int)barcode_addr >= ...">        44
     ?<Constant "E:\\H520B\\FW\\src\\App\\a...">   28
     ?<Constant "(int)barcode_addr <= ...">        60
     ?<Constant "((int)barcode_addr - ...">        68
     ?<Constant "enter into Memory Mode\r\n">      28
     ?<Constant "exit from Memory Mode\r\n">       24
     ?<Constant "enter into USB HID Mo...">        28
     ?<Constant "exit from USB HID Mode\r\n">      28
     ?<Constant "enter into BT Mode:%d\r\n">       24
     ?<Constant "exit from BT Mode:%d\r\n">        24
     ?<Constant "\000\000\000">                     4
     ?<Constant "\000\000(">                        4
     ?<Constant "pEvent_Queue != (OS_E...">        32
     ?<Constant "pBarcode_Queue != (OS...">        32
     ?<Constant "pIOSem != (OS_EVENT*)0">          24
     ?<Constant "current state:%d\r\n">            20
     ?<Constant "event:%d\r\n">                    12
     ?<Constant "0">                                2
     ?<Constant "Enter into Event_capt...">        36
     ?<Constant "usb cable remove dete...">        32
     ?<Constant "low power detected!\r\n">         24
     ?<Constant "USB HID Enum OK detec...">        28
     ?<Constant "ret == 0">                        12
     ?<Constant "BT Module init Succes...">        28
     ?<Constant "BT Module Status = %s!\r\n">      28
     ?<Constant "Connected">                       12
     ?<Constant "Disconnect">                      12
     ?<Constant "BT Module got data(%s...">        36
     ?<Constant "BT Module send data F...">        28
     ?<Constant "BT Module send data S...">        32
     ?<Constant "app init thread start...">        32
     ?<Constant "p_init_thread_stk != 0">          24

 
 3 886 bytes in section .bss
   850 bytes in section .rodata
 3 278 bytes in section .text
 
 3 244 bytes of CODE  memory (+ 34 bytes shared)
   850 bytes of CONST memory
 3 886 bytes of DATA  memory

Errors: none
Warnings: 1
