###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     23/Sep/2015  15:47:12 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\Drivers\keypad.c                         #
#    Command line =  E:\H520B\FW\src\Drivers\keypad.c -D DEBUG_VER -lcN       #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\keypad.lst    #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\keypad.o       #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\Drivers\keypad.c
      1          /**
      2          * @file keypad.c
      3          * @brief 按键驱动程序
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月28日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "stm32f10x_lib.h"
     17          #include "ucos_ii.h"
     18          #include <stdio.h>
     19          #include "keypad.h"
     20          #include "cpu.h"
     21          #include "app.h"
     22          #include "TimeBase.h"
     23          #include "hw_platform.h"
     24          
     25          static  unsigned char		current_press_key;
     26          static  unsigned int		press_cnt;
     27          static  unsigned int		release_cnt; 
     28          static  unsigned char		keypad_state;
     29          
     30          
     31          extern	unsigned int	device_current_state;		//设备主状态机
     32          extern	OS_EVENT		*pEvent_Queue;			//事件消息队列
     33          extern unsigned int		keypress_timeout;
     34          /**
     35          * @brief   		Intialize the KeyBoard IO
     36          * @param[in]   none
     37          * @return      none
     38          * @note   
     39          *		按键的硬件连接如下图所示：
     40          *		ScanKey -- PA0
     41          *		EraseKey -- PB3
     42          *		ResetKey -- PB4
     43          */
     44          static void Keypad_Initport(void)
     45          {
     46          	GPIO_InitTypeDef  gpio_init;
     47          	EXTI_InitTypeDef EXTI_InitStructure;    
     48          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);
     49          
     50          	//ScanKey  PA.0
     51          	gpio_init.GPIO_Pin   = GPIO_Pin_0;
     52          	gpio_init.GPIO_Speed = GPIO_Speed_10MHz;
     53          	gpio_init.GPIO_Mode  = GPIO_Mode_IPU;
     54          	GPIO_Init(GPIOA, &gpio_init);		
     55          
     56          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
     57          	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
     58          
     59          	//EraseKey PB3		ResetKey  PB4
     60          	gpio_init.GPIO_Pin   = GPIO_Pin_3 | GPIO_Pin_4;
     61          	GPIO_Init(GPIOB, &gpio_init);
     62          
     63          	/* Connect EXTI Line0 to PA0 */
     64          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);
     65          	/* Connect EXTI Line3 to PB3 */
     66          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource3);
     67          	/* Connect EXTI Line4 to PB4 */
     68          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource4);
     69          
     70          	/* Configure EXTI LineX to generate an interrupt on falling edge */
     71          	EXTI_ClearITPendingBit(EXTI_Line0| EXTI_Line3 | EXTI_Line4);
     72          	EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line3 | EXTI_Line4;
     73          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
     74          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
     75          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
     76          	EXTI_Init(&EXTI_InitStructure);
     77          	EXTI_GenerateSWInterrupt(EXTI_Line0 | EXTI_Line3 | EXTI_Line4);
     78          }
     79          
     80          /**
     81          * @brief   	Enable the keypad interrupt
     82          * @return      none
     83          */
     84          void Keypad_Int_Enable(void)
     85          {
     86          	NVIC_InitTypeDef	NVIC_InitStructure;
     87          	EXTI_ClearITPendingBit(EXTI_Line0| EXTI_Line3 | EXTI_Line4);
     88          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);    // 抢占式优先级别
     89          
     90          	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel;
     91          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
     92          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     93          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     94          	NVIC_Init(&NVIC_InitStructure);
     95          
     96          	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQChannel;
     97          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     98          	NVIC_Init(&NVIC_InitStructure);
     99          
    100          
    101          	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQChannel;
    102              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    103          	NVIC_Init(&NVIC_InitStructure);
    104          }
    105          
    106          /**
    107          * @brief   	Disable the keypad interrupt
    108          * @return      none
    109          */
    110          void Keypad_Int_Disable(void)
    111          {
    112          	NVIC_InitTypeDef	NVIC_InitStructure;
    113          	EXTI_ClearITPendingBit(EXTI_Line0| EXTI_Line3 | EXTI_Line4);
    114          
    115          	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel;
    116          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    117          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    118          	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    119          	NVIC_Init(&NVIC_InitStructure);
    120          
    121          	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQChannel;
    122          	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    123          	NVIC_Init(&NVIC_InitStructure);
    124          
    125          	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQChannel;
    126          	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    127          	NVIC_Init(&NVIC_InitStructure);
    128          }
    129          
    130          
    131          /**
    132          * @brief 初始化按键检测需要使用到的定时器,20ms定时器，用以检测按键的按下时长
    133          */
    134          void Keypad_Timer_Init(void)
    135          {
    136          	TIM_TimeBaseInitTypeDef						TIM_TimeBaseStructure;
    137          	TIM_OCInitTypeDef							TIM_OCInitStructure;
    138          	NVIC_InitTypeDef							NVIC_InitStructure;
    139          
    140          	//初始化结构体变量
    141          	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    142          	TIM_OCStructInit(&TIM_OCInitStructure);
    143          
    144          	/*开启相应时钟 */
    145          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  
    146          
    147          
    148          	//定时计算公式：(（1+Prescaler）/72M ) *(Period+1) = ((1+39)/72M) * (72000/2-1+1) = 20ms
    149          	/* Time Base configuration */
    150          	TIM_TimeBaseStructure.TIM_Prescaler			= 39;      
    151          	TIM_TimeBaseStructure.TIM_CounterMode		= TIM_CounterMode_Up; //向上计数
    152          	TIM_TimeBaseStructure.TIM_Period			= (72000/2-1);      
    153          	TIM_TimeBaseStructure.TIM_ClockDivision		= TIM_CKD_DIV1;
    154          	//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    155          
    156          	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    157          
    158          	/* Channel 1, 2, 3 and 4 Configuration in Timing mode */
    159          	TIM_OCInitStructure.TIM_OCMode				= TIM_OCMode_Timing;
    160          	TIM_OCInitStructure.TIM_Pulse				= 0x0;
    161          
    162          	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
    163          
    164          	TIM_ClearFlag(TIM3,TIM_FLAG_Update);
    165          	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
    166          
    167          	/* Enable the TIM2 Interrupt */
    168          	NVIC_InitStructure.NVIC_IRQChannel			= TIM3_IRQChannel;
    169          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    170          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority	= 1;
    171          	NVIC_InitStructure.NVIC_IRQChannelCmd		= ENABLE;
    172          	NVIC_Init(&NVIC_InitStructure);
    173          }
    174          
    175          /**
    176          * @brief 使能按键检测需要使用到的定时器
    177          */
    178          void Keypad_Timer_Enable(void)
    179          {
    180          	TIM_ClearFlag(TIM3,TIM_FLAG_Update);
    181          	TIM_Cmd(TIM3, ENABLE);
    182          }
    183          
    184          /**
    185          * @brief 关闭按键检测需要使用到的定时器
    186          */
    187          void Keypad_Timer_Disable(void)
    188          {
    189          	TIM_Cmd(TIM3, DISABLE);
    190          }
    191          
    192          /**
    193          * @brief 初始化按键
    194          */
    195          void Keypad_Init(void)
    196          {
    197          	Keypad_Initport();
    198          	Keypad_Timer_Init();
    199          	Keypad_Int_Enable();
    200          }
    201          
    202          
    203          #define KEYPAD_STATE_INIT					0
    204          #define KEYPAD_STATE_AT_LEAST_CLICK			1
    205          #define KEYPAD_STATE_FIRST_CLICK_RELEASE	2
    206          #define KEYPAD_STATE_SECOND_CLICK			3
    207          #define KEYPAD_STATE_LONG_PRESS				4
    208          
    209          /**
    210           * @brief keypad 三个Key对应的IO外部中断ISR
    211           * @note  EXIT0、EXTI3、EXTI4的中断服务函数调用
    212          */
    213          void Keypad_EXTI_ISRHandler(unsigned char	exti_line)
    214          {
    215          	//一进入中断，表示检测到有按键被按下，此时需要先关闭所有按键的IO中断，直到此次判断结束再开启
    216          	Keypad_Int_Disable();
    217          
    218          	//再开启定时器及其中断，判断按键是单击还是长按
    219          	Keypad_Timer_Enable();
    220          
    221          	if (exti_line == SCAN_KEY_EXTI_INT)
    222          	{
    223          		current_press_key = SCAN_KEY;
    224          	}
    225          	else if (exti_line == ERASE_KEY_EXTI_INT)
    226          	{
    227          		current_press_key = ERASE_KEY;
    228          	}
    229          	else
    230          	{
    231          		current_press_key = RESET_KEY;
    232          	}
    233          	press_cnt = 0;
    234          	keypad_state = KEYPAD_STATE_INIT;
    235          }
    236          
    237          
    238          /**
    239           * @brief 读取keypad IO，返回IO状态
    240           * @param[in] unsigned char key		需要读取的是哪个Key对应的IO
    241           * @return  0: low  else: high  
    242          */
    243          static unsigned char Keypad_ReadIO(unsigned char key)
    244          {
    245          	unsigned char h1,h2;
    246          	unsigned int	i;
    247          reread:
    248          	if (key == SCAN_KEY)
    249          	{
    250          		h1 = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0);
    251          	}
    252          	else if (key == ERASE_KEY)
    253          	{
    254          		h1 = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_3);
    255          	}
    256          	else
    257          	{
    258          		h1 = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_4);
    259          	}
    260          
    261          	//hw_platform_trip_io();
    262          	for(i=0;i < 10000;i++);	//约1ms(在72M频率下，实测972us)
    263          	//hw_platform_trip_io();
    264          
    265          	if (key == SCAN_KEY)
    266          	{
    267          		h2 = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0);
    268          	}
    269          	else if (key == ERASE_KEY)
    270          	{
    271          		h2 = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_3);
    272          	}
    273          	else
    274          	{
    275          		h2 = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_4);
    276          	}
    277          
    278          	if(h1 == h2)
    279          	{
    280          		return h1;
    281          	}
    282          	else
    283          	{
    284          		goto  reread;
    285          	}
    286          }
    287          
    288          //按住超过2个按键低电平判断周期即认为至少是一次按键单击事件的发生，以20ms周期为例，就是只要按住超过40ms即认为至少发生了有效的按键单击事件
    289          #define SINGLE_CLICK_TH			2		
    290          #define LONG_PRESS_TH			250		//按住超过250个按键低电平判断周期即认为是一次按键长按事件的发生，按住超过5S即认为按键长按
    291          #define DOUBLE_CLICK_INTERVAL	4		//双击，连续两次按键之间的时间不超过80ms即认为是双击
    292          //定义一个回调函数指针，以供中断处理函数在获取到按键键值时post给其余模块使用时，可以提供不同的方法
    293          //typedef void (* post_key_method)(unsigned char key_value);
    294          
    295          //static void post_key(unsigned char key)
    296          //{
    297          //	OSQPost(pEvent_Queue,(void*)key);
    298          //}
    299          
    300          /**
    301           * @brief 定时器中断处理程序
    302           * @note 真正判断按键是在20ms定时器中断处理程序完成的
    303          */
    304          void Keypad_Timer_ISRHandler(void)
    305          {
    306          	if (Keypad_ReadIO(current_press_key) == 0)
    307          	{
    308          		if (keypad_state == KEYPAD_STATE_INIT)
    309          		{
    310          			press_cnt++;
    311          			if (press_cnt == SINGLE_CLICK_TH)
    312          			{
    313          				keypress_timeout = 0;
    314          				keypad_state = KEYPAD_STATE_AT_LEAST_CLICK;
    315          				if (current_press_key == RESET_KEY)
    316          				{
    317          					OSQPost(pEvent_Queue,(void*)EVENT_RESET_KEY_PRESS);
    318          					//keypad_state = KEYPAD_STATE_INIT;
    319          					Keypad_Timer_Disable();
    320          					Keypad_Int_Enable();
    321          				}
    322          				else if (current_press_key == SCAN_KEY)
    323          				{
    324          					hw_platform_start_led_blink(LED_GREEN,3);
    325          					if (device_current_state == STATE_HID_Mode)
    326          					{
    327          						OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_SINGLE_CLICK);
    328          						//keypad_state = KEYPAD_STATE_INIT;
    329          						Keypad_Timer_Disable();
    330          						Keypad_Int_Enable();
    331          					}
    332          				}
    333          			}
    334          		}
    335          		else if (keypad_state == KEYPAD_STATE_AT_LEAST_CLICK)
    336          		{
    337          			press_cnt++;
    338          			if (press_cnt == LONG_PRESS_TH)
    339          			{
    340          				if (current_press_key == SCAN_KEY)
    341          				{
    342          					OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_LONG_PRESS);
    343          				}
    344          				else if (current_press_key == ERASE_KEY)
    345          				{
    346          					OSQPost(pEvent_Queue,(void*)EVENT_ERASE_KEY_LONG_PRESS);
    347          				}
    348          				
    349          				//keypad_state = KEYPAD_STATE_INIT;
    350          				Keypad_Timer_Disable();
    351          				Keypad_Int_Enable();
    352          			}
    353          		}
    354          		else if (keypad_state == KEYPAD_STATE_FIRST_CLICK_RELEASE)
    355          		{
    356          			keypad_state = KEYPAD_STATE_SECOND_CLICK;
    357          			press_cnt = 0;
    358          		}
    359          		else if (keypad_state == KEYPAD_STATE_SECOND_CLICK)
    360          		{
    361          			press_cnt++;
    362          			if (press_cnt == LONG_PRESS_TH)
    363          			{
    364          				OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_LONG_PRESS);
    365          				Keypad_Timer_Disable();
    366          				Keypad_Int_Enable();
    367          			}
    368          		}
    369          	}
    370          	else
    371          	{
    372          		if (keypad_state == KEYPAD_STATE_INIT)
    373          		{
    374          			//keypad_state = KEYPAD_STATE_INIT;
    375          			Keypad_Timer_Disable();
    376          			Keypad_Int_Enable();
    377          		}
    378          		else if (keypad_state == KEYPAD_STATE_AT_LEAST_CLICK)
    379          		{
    380          			if (current_press_key == SCAN_KEY)
    381          			{
    382          				//OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_SINGLE_CLICK);
    383          				if (device_current_state == STATE_BT_Mode_Connect)
    384          				{
    385          					//只有在蓝牙连接状态下，才需要检测SCAN键的双击行为
    386          					keypad_state = 	KEYPAD_STATE_FIRST_CLICK_RELEASE;
    387          					release_cnt = 0;
    388          				}
    389          				else
    390          				{
    391          					//其余状态下没有必要检测SCAN键的双击行为
    392          					OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_SINGLE_CLICK);
    393          					Keypad_Timer_Disable();
    394          					Keypad_Int_Enable();
    395          				}
    396          				
    397          			}
    398          			else if (current_press_key == ERASE_KEY)
    399          			{
    400          				OSQPost(pEvent_Queue,(void*)EVENT_ERASE_KEY_SINGLE_CLICK);
    401          				//keypad_state = KEYPAD_STATE_INIT;
    402          				Keypad_Timer_Disable();
    403          				Keypad_Int_Enable();
    404          			}
    405          		}
    406          		else if (keypad_state == KEYPAD_STATE_FIRST_CLICK_RELEASE)
    407          		{
    408          			release_cnt++;
    409          			if (release_cnt == DOUBLE_CLICK_INTERVAL)
    410          			{
    411          				//单击后，在双击间隔时间内没有再次按下按键，及可以确认单击事件的发生
    412          				OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_SINGLE_CLICK);
    413          				//keypad_state = KEYPAD_STATE_INIT;
    414          				Keypad_Timer_Disable();
    415          				Keypad_Int_Enable();
    416          			}
    417          		}
    418          		else if (keypad_state == KEYPAD_STATE_SECOND_CLICK)
    419          		{
    420          			OSQPost(pEvent_Queue,(void*)EVENT_SCAN_KEY_DOUBLE_CLICK);
    421          			//keypad_state = KEYPAD_STATE_INIT;
    422          			Keypad_Timer_Disable();
    423          			Keypad_Int_Enable();
    424          			hw_platform_stop_led_blink();
    425          		}
    426          	}
    427          }
    428          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     Keypad_EXTI_ISRHandler       8
     Keypad_Init                  8
     Keypad_Initport             16
     Keypad_Int_Disable           8
     Keypad_Int_Enable            8
     Keypad_ReadIO               16
     Keypad_Timer_Disable         8
     Keypad_Timer_Enable          8
     Keypad_Timer_ISRHandler      8
     Keypad_Timer_Init           40


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     current_press_key          1
     press_cnt                  4
     release_cnt                4
     keypad_state               1
     Keypad_Initport          136
     Keypad_Int_Enable         84
     Keypad_Int_Disable        76
     Keypad_Timer_Init        124
     Keypad_Timer_Enable       20
     Keypad_Timer_Disable      12
     Keypad_Init               16
     Keypad_EXTI_ISRHandler    60
     Keypad_ReadIO            120
     Keypad_Timer_ISRHandler  464
     ??DataTable8               4
     ??DataTable17              4
     ??DataTable19              4
     ??DataTable40              4
     ??DataTable45              4
     ??DataTable47              4

 
    10 bytes in section .bss
 1 136 bytes in section .text
 
 1 136 bytes of CODE memory
    10 bytes of DATA memory

Errors: none
Warnings: none
