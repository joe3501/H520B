###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     26/Sep/2015  15:20:24 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\Drivers\WBTDS01.c                        #
#    Command line =  E:\H520B\FW\src\Drivers\WBTDS01.c -lcN                   #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\WBTDS01.lst   #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\WBTDS01.o      #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\Drivers\WBTDS01.c
      1          /**
      2          * @file WBTDS01.c
      3          * @brief WBTDS01 蓝牙模块的驱动
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note   根据模块的响应特点，串口驱动采用 DMA发送和接受 + 串口空闲中断判断响应数据接收完的机制。
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "WBTDS01.h"
     17          #include "ucos_ii.h"
     18          #include "stm32f10x_lib.h"
     19          #include "string.h"
     20          #include <assert.h>
     21          #include "basic_fun.h"
     22          
     23          //#define	WBTD_DEBUG
     24          
     25          #define WBTD_RESPONSE_INIT				0
     26          
     27          //通知类型的响应数据状态
     28          #define WBTD_RESPONSE_GOT_NOTIFY_CON		0x80
     29          #define WBTD_RESPONSE_GOT_NOTIFY_DISCON		0x40
     30          
     31          //应答类型的响应数据状态
     32          #define WBTD_RESPONSE_OK				0x01
     33          #define WBTD_RESPONSE_ERR				0x02
     34          
     35          #define WBTD_RESPONSE_UNKOWN			0x04
     36          
     37          //响应1: <CR><LF>+ERROR:<Space>3<CR><LF>
     38          //响应2: <CR><LF>+VER:Ver40(jul 14 2015)<CR><LF><CR><LF>OK<CR><LF>
     39          //响应3: 
     40          
     41          /**
     42          * @brief WBTDS01响应定义  WBTDS01->host
     43          */
     44          typedef struct {
     45          	unsigned short			DataPos;
     46          	unsigned short			DataLength;
     47          	unsigned char			status;
     48          	unsigned char			*DataBuffer;
     49          }TWBTDRes;
     50          
     51          TWBTDRes		wbtd_res;
     52          
     53          		
     54          #define     WBTD_NOTIFY_BUFFER_LEN		32		//
     55          
     56          static unsigned char	wbtd_send_buff[32];
     57          
     58          unsigned char	wbtd_recbuffer[WBTD_RES_BUFFER_LEN];
     59          
     60          /*
     61           * @brief: 初始化模块端口
     62           * @note 使用串口2
     63          */
     64          /*
     65           * @brief: 初始化模块端口
     66           * @note 使用串口2
     67          */
     68          static void WBTD_GPIO_config(unsigned int baudrate)
     69          {
     70          	GPIO_InitTypeDef				GPIO_InitStructure;
     71          	USART_InitTypeDef				USART_InitStructure;
     72          	DMA_InitTypeDef					DMA_InitStructure;
     73          
     74          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
     75          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
     76          
     77          	//B-Reset  PB.1
     78          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1;
     79              GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
     80          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
     81          	GPIO_Init(GPIOB, &GPIO_InitStructure);
     82          	GPIO_SetBits(GPIOB, GPIO_Pin_1);
     83          
     84          	// 使用UART2, PA2,PA3
     85          	/* Configure USART2 Tx (PA.2) as alternate function push-pull */
     86          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
     87          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
     88          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
     89          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     90          
     91          	/* Configure USART2 Rx (PA.3) as input floating				*/
     92          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
     93          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
     94          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     95          
     96          	USART_InitStructure.USART_BaudRate		= baudrate;					
     97          	USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
     98          	USART_InitStructure.USART_StopBits		= USART_StopBits_1;
     99          	USART_InitStructure.USART_Parity		= USART_Parity_No;
    100          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    101          	USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    102          
    103          	USART_Init(USART2, &USART_InitStructure);
    104          
    105          
    106          	/* DMA clock enable */
    107          	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    108          
    109          	/* fill init structure */
    110          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    111          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    112          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    113          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    114          	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    115          	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    116          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    117          
    118          	/* DMA1 Channel7 (triggered by USART2 Tx event) Config */
    119          	DMA_DeInit(DMA1_Channel7);
    120          	DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART2->DR);
    121          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    122          	/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    123          	 * and DMA_BufferSize are meaningless. So just set them to proper values
    124          	 * which could make DMA_Init happy.
    125          	 */
    126          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    127          	DMA_InitStructure.DMA_BufferSize = 1;
    128          	DMA_Init(DMA1_Channel7, &DMA_InitStructure);
    129          
    130          
    131          	//DMA1通道6配置  
    132          	DMA_DeInit(DMA1_Channel6);  
    133          	//外设地址  
    134          	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART2->DR);  
    135          	//内存地址  
    136          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)wbtd_recbuffer;  
    137          	//dma传输方向单向  
    138          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    139          	//设置DMA在传输时缓冲区的长度  
    140          	DMA_InitStructure.DMA_BufferSize = WBTD_RES_BUFFER_LEN;  
    141          	//设置DMA的外设递增模式，一个外设  
    142          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    143          	//设置DMA的内存递增模式  
    144          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    145          	//外设数据字长  
    146          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    147          	//内存数据字长  
    148          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    149          	//设置DMA的传输模式  
    150          	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    151          	//设置DMA的优先级别  
    152          	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    153          	//设置DMA的2个memory中的变量互相访问  
    154          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    155          	DMA_Init(DMA1_Channel6,&DMA_InitStructure);  
    156          
    157          	//使能通道6 
    158          	DMA_Cmd(DMA1_Channel6,ENABLE);  
    159          
    160          	//采用DMA方式接收  
    161          	USART_DMACmd(USART2,USART_DMAReq_Rx,ENABLE); 
    162          
    163          	/* Enable USART2 DMA Tx request */
    164          	USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    165          
    166          	USART_Cmd(USART2, ENABLE);
    167          }
    168          
    169          /*
    170           * @brief: 串口中断的初始化
    171          */
    172          static void WBTD_NVIC_config(void)
    173          {
    174          	NVIC_InitTypeDef				NVIC_InitStructure;
    175          	//中断配置  
    176          	USART_ITConfig(USART2,USART_IT_TC,DISABLE);  
    177          	USART_ITConfig(USART2,USART_IT_RXNE,DISABLE);  
    178          	USART_ITConfig(USART2,USART_IT_IDLE,ENABLE);    
    179          
    180          	//配置UART2中断  
    181          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    182          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;               //通道设置为串口2中断    
    183          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    184          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    185          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    186          	NVIC_Init(&NVIC_InitStructure);  
    187          
    188          	/* Enable the DMA1 Channel7 Interrupt */
    189          	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQChannel;
    190          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    191          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    192          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    193          	NVIC_Init(&NVIC_InitStructure);
    194          
    195          	DMA_ITConfig(DMA1_Channel7, DMA_IT_TC | DMA_IT_TE, ENABLE);
    196          	DMA_ClearFlag(DMA1_FLAG_TC7);
    197          }
    198          
    199          
    200          /**
    201          * @brief  发数据给蓝牙模块
    202          * @param[in] unsigned char *pData 要发送的数据
    203          * @param[in] int length 要发送数据的长度
    204          */
    205          static void send_data_to_WBTDS01(const unsigned char *pData, unsigned short length)
    206          {
    207          	//while(length--)
    208          	//{
    209          	//	USART_SendData(USART2, *pData++);
    210          	//	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    211          	//	{
    212          	//	}
    213          	//}
    214          	//while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    215          
    216          	/* disable DMA */
    217          	DMA_Cmd(DMA1_Channel7, DISABLE);
    218          
    219          	/* set buffer address */
    220          	memcpy(wbtd_send_buff,pData,length);
    221          
    222          	DMA1_Channel7->CMAR = (u32)&wbtd_send_buff[0];
    223          	/* set size */
    224          	DMA1_Channel7->CNDTR = length;
    225          
    226          	USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    227          	/* enable DMA */
    228          	DMA_Cmd(DMA1_Channel7, ENABLE);
    229          
    230          	while(DMA1_Channel7->CNDTR);
    231          	while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    232          }
    233          
    234          
    235          /*
    236           * @brief 清空接收蓝牙模块响应数据的buffer
    237          */
    238          static void WBTD_reset_resVar(void)
    239          {
    240          	wbtd_res.DataPos = 0;
    241          	wbtd_res.DataLength = 0;
    242          	wbtd_res.status	 = WBTD_RESPONSE_INIT;
    243          }
    244          
    245          
    246          /**
    247          * @brief 处理host收到WBTD的数据
    248          * @param[in] unsigned char c 读入的字符
    249          * @return 0:success put in buffer
    250          *        -1:fail
    251          */
    252          int WBTD_RxISRHandler(unsigned char *res, unsigned int res_len)
    253          {
    254          	if (res_len > 4)
    255          	{
    256          		if (memcmp(res,"\x0d\x0a+CON",6) == 0)
    257          		{
    258          			wbtd_res.status &= ~WBTD_RESPONSE_GOT_NOTIFY_DISCON;
    259          			wbtd_res.status |= WBTD_RESPONSE_GOT_NOTIFY_CON;
    260          		}
    261          		else if (memcmp(res,"\x0d\x0a+DISCON",9) == 0)
    262          		{
    263          			wbtd_res.status &= ~WBTD_RESPONSE_GOT_NOTIFY_CON;
    264          			wbtd_res.status |= WBTD_RESPONSE_GOT_NOTIFY_DISCON;
    265          		}
    266          		else if (memcmp(res,"\x0d\x0a+ERROR",8) == 0)
    267          		{
    268          			wbtd_res.DataLength = res_len;
    269          			wbtd_res.status |= WBTD_RESPONSE_ERR; 
    270          		}
    271          		else
    272          		{
    273          			wbtd_res.DataLength = res_len;
    274          			if ((res[res_len-1] == 0x0a)&&(res[res_len-2] == 0x0d)			\
    275          				&&(res[res_len-3] == 'K')&&(res[res_len-4] == 'O'))
    276          			{
    277          				if (wbtd_res.status == WBTD_RESPONSE_INIT)
    278          				{
    279          					wbtd_res.status |= WBTD_RESPONSE_OK;
    280          				}
    281          			}
    282          			else
    283          			{
    284          				wbtd_res.status |= WBTD_RESPONSE_UNKOWN;
    285          			}
    286          		}
    287          	}
    288          }
    289          
    290          
    291          /**
    292          * @brief  发命令给蓝牙模块WBTDS01,并等待响应结果
    293          * @param[in] unsigned char *pData 要发送的数据
    294          * @param[in] unsigned int	length 要发送数据的长度
    295          * @return		0: 成功
    296          *				-1: 失败
    297          *				-2: 未知响应，可能是响应解析函数有BUG，需要调试
    298          *				-3：响应超时
    299          */
    300          static int WBTD_write_cmd(const unsigned char *pData, unsigned int length)
    301          {
    302          	unsigned int	wait_cnt;
    303          	send_data_to_WBTDS01(pData, length);
    304          	WBTD_reset_resVar();
    305          	wait_cnt = 200;
    306          	while (wait_cnt)
    307          	{
    308          		if ((wbtd_res.status & WBTD_RESPONSE_OK) == WBTD_RESPONSE_OK)
    309          		{
    310          			return 0;
    311          		}
    312          		else if ((wbtd_res.status & WBTD_RESPONSE_ERR) == WBTD_RESPONSE_ERR)
    313          		{
    314          			return -1;
    315          		}
    316          		else if ((wbtd_res.status & WBTD_RESPONSE_UNKOWN) == WBTD_RESPONSE_UNKOWN)
    317          		{
    318          			return -2;
    319          		}
    320          
    321          		OSTimeDlyHMSM(0,0,0,20);
    322          		wait_cnt--;
    323          	}
    324          
    325          	return -3;
    326          }
    327          
    328          
    329          //const unsigned char	*query_version_cmd="AT+VER=?";
    330          //const unsigned char	*set_device_name_cmd="AT+DNAME=%s";
    331          
    332          /*
    333           * @brief 蓝牙模块WBTDS01的复位
    334          */
    335          void WBTD_Reset(void)
    336          {
    337          	//拉低复位信号100ms
    338          	GPIO_ResetBits(GPIOB, GPIO_Pin_1);
    339          	OSTimeDlyHMSM(0,0,0,100);
    340          	GPIO_SetBits(GPIOB, GPIO_Pin_1);
    341          
    342          	WBTD_reset_resVar();
    343          
    344          	//got_notify_flag = 0;
    345          	//memset(wbtd_notify_buffer,0,WBTD_NOTIFY_BUFFER_LEN);
    346          	OSTimeDlyHMSM(0,0,0,100);
    347          }
    348          
    349          /*
    350           * @brief 查询蓝牙模块WBTDS01的版本号
    351           * @param[out]  unsigned char *ver_buffer  返回查询到的版本号，如果为空表示查询失败
    352          */
    353          int WBTD_query_version(unsigned char *ver_buffer)
    354          {
    355          	unsigned char	buffer[21];
    356          	int		i,ret;
    357          
    358          	assert(ver_buffer != 0);
    359          	ver_buffer[0] = 0;
    360          	memcpy(buffer,"AT+VER?\x0d\x0a",9);
    361          	ret = WBTD_write_cmd((const unsigned char*)buffer,9);
    362          	if (ret)
    363          	{
    364          		return ret;
    365          	}
    366          
    367          	if (memcmp(&wbtd_res.DataBuffer[3],"VER:",4) == 0)
    368          	{
    369          		for (i = 0; i < ((wbtd_res.DataLength-15) > 20)?20:(wbtd_res.DataLength-15);i++)
    370          		{
    371          			if (wbtd_res.DataBuffer[7+i] == 0x0d)
    372          			{
    373          				break;
    374          			}
    375          
    376          			ver_buffer[i] = wbtd_res.DataBuffer[7+i];
    377          		}
    378          		ver_buffer[i] = 0;
    379          		return 0;
    380          	}
    381          
    382          	return -1;
    383          }
    384          
    385          
    386          /*
    387           * @brief 设置蓝牙模块的设备名称
    388           * @param[in]  unsigned char *name  设置的名称,字符串
    389           * @return 0: 设置成功		else：设置失败
    390           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
    391           *       在此接口中将设备名称限定为最长支持20个字节
    392          */
    393          int WBTD_set_name(unsigned char *name)
    394          {
    395          	unsigned char	buffer[31];
    396          	int		len;
    397          
    398          	assert(name != 0);
    399          	memcpy(buffer,"AT+DNAME=",9);
    400          	len = strlen((char const*)name);
    401          	if (len>20)
    402          	{
    403          		memcpy(buffer+9,name,20);
    404          		buffer[29] = 0x0d;
    405          		buffer[30] = 0x0a;
    406          		len = 31;
    407          	}
    408          	else
    409          	{
    410          		memcpy(buffer+9,name,len);
    411          		buffer[9+len] = 0x0d;
    412          		buffer[10+len] = 0x0a;
    413          		len = 11+len;
    414          	}
    415          
    416          	return WBTD_write_cmd((const unsigned char*)buffer,len); 
    417          }
    418          
    419          /*
    420           * @brief 设置蓝牙模块的设备名称
    421           * @param[in]  unsigned char *name  设置的名称,字符串
    422           * @return 0: 设置成功		else：设置失败
    423           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
    424           *       在此接口中将设备名称限定为最长支持20个字节
    425          */
    426          int WBTD_set_baudrate(WBTD_BAUDRATE baudrate)
    427          {
    428          	unsigned char	buffer[20];
    429          	int		len;
    430          
    431          	memcpy(buffer,"AT+URATE=",9);
    432          	len = 16;
    433          	switch(baudrate)
    434          	{
    435          	case BAUDRATE_9600:
    436          		memcpy(buffer+9,"9600",4);
    437          		buffer[13] = 0x0d;
    438          		buffer[14] = 0x0a;
    439          		len = 15;
    440          		break;
    441          	case BAUDRATE_19200:
    442          		memcpy(buffer+9,"19200",5);
    443          		buffer[14] = 0x0d;
    444          		buffer[15] = 0x0a;
    445          		break;
    446          	case BAUDRATE_38400:
    447          		memcpy(buffer+9,"38400",5);
    448          		buffer[14] = 0x0d;
    449          		buffer[15] = 0x0a;
    450          		break;
    451          	case BAUDRATE_43000:
    452          		memcpy(buffer+9,"43000",5);
    453          		buffer[14] = 0x0d;
    454          		buffer[15] = 0x0a;
    455          		break;
    456          	case BAUDRATE_57600:
    457          		memcpy(buffer+9,"57600",5);
    458          		buffer[14] = 0x0d;
    459          		buffer[15] = 0x0a;
    460          		break;
    461          	case BAUDRATE_115200:
    462          		memcpy(buffer+9,"115200",6);
    463          		buffer[15] = 0x0d;
    464          		buffer[16] = 0x0a;
    465          		len = 17;
    466          		break;
    467          	}
    468          	return WBTD_write_cmd((const unsigned char*)buffer,len);
    469          }
    470          
    471          /*
    472           * @brief 使蓝牙模块进入配对模式
    473           * @param[in]  unsigned char mode  配对模式  
    474           *			1: 蓝牙模块会试图重连之前的蓝牙主机   
    475           *			0：蓝牙模块不会试图重连之前的蓝牙主机   
    476           * @return 0: 设置成功		else：设置失败
    477          */
    478          int WBTD_set_autocon(unsigned char mode)
    479          {
    480          	unsigned char	buffer[15];
    481          
    482          	memcpy(buffer,"AT+AUTOCON=",11);
    483          	if (mode)
    484          	{
    485          		buffer[11] = '1';
    486          	}
    487          	else
    488          	{
    489          		buffer[11] = '0';
    490          	}
    491          	buffer[12] = 0x0d;
    492          	buffer[13] = 0x0a;
    493          	return WBTD_write_cmd((const unsigned char*)buffer,14);
    494          }
    495          
    496          /*
    497           * @brief 设置蓝牙模块的工作模式(profile = HID、SPP、BLE)
    498           * @param[in]  unsigned char mode  蓝牙模块的工作模式     
    499           * @return 0: 设置成功		else：设置失败
    500          */
    501          int WBTD_set_profile(BT_PROFILE mode)
    502          {
    503          	unsigned char	buffer[20];
    504          
    505          	memcpy(buffer,"AT+PROFILE=",11);
    506          	if (mode == BT_PROFILE_HID)
    507          	{
    508          		buffer[11] = '2';
    509          	}
    510          	else if (mode == BT_PROFILE_SPP)
    511          	{
    512          		buffer[11] = '1';
    513          	}
    514          	else
    515          	{
    516          		buffer[11] = '0';
    517          	}
    518          	buffer[12] = 0x0d;
    519          	buffer[13] = 0x0a;
    520          	return  WBTD_write_cmd((const unsigned char*)buffer,14);
    521          }
    522          
    523          /*
    524           * @brief 设置蓝牙模块是否使能IOS soft keyboard
    525           * @param[in]  unsigned char enable  1:Enable   0:Disable
    526           * @return 0: 设置成功		else：设置失败
    527          */
    528          int WBTD_set_ioskeypad(unsigned char enable)
    529          {
    530          	unsigned char	buffer[15];
    531          
    532          	memcpy(buffer,"AT+IOSKB=",9);
    533          	if (enable)
    534          	{
    535          		buffer[9] = '1';
    536          	}
    537          	else
    538          	{
    539          		buffer[9] = '0';
    540          	}
    541          	buffer[10] = 0x0d;
    542          	buffer[11] = 0x0a;
    543          	return WBTD_write_cmd((const unsigned char*)buffer,12);
    544          }
    545          
    546          /*
    547           * @brief 通过蓝牙模块的HID模式发送ASCII字符串
    548           * @param[in]  unsigned char *str		需要发送的ASCII字符缓冲
    549           * @param[in]  unsigned int  len	    待发送字符数
    550           * @param[out]  unsigned int *send_len  实际发送的字符数
    551           * @return 0: 发送成功		else：发送失败
    552          */
    553          int WBTD_hid_send(unsigned char *str,unsigned int len,unsigned int *send_len)
    554          {
    555          	int	ret,i;
    556          	unsigned char	buffer[16];
    557          	unsigned char	tmp[3];
    558          
    559          	memcpy(buffer,"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",16);
    560          	*send_len = 0;
    561          	for (i = 0; i < len;i++)
    562          	{
    563          		ascii_to_keyreport(str[i],tmp);
    564          		buffer[0] = tmp[0];
    565          		buffer[2] = tmp[2];
    566          		send_data_to_WBTDS01(buffer, 16);
    567          		*send_len++;
    568          
    569          		delay_us(300);
    570          	}
    571          
    572          	send_data_to_WBTDS01("\x00\x00\x28\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
    573          	return 0;
    574          }
    575          
    576          
    577          /*
    578           * @brief 蓝牙模块WBTDS01的初始化
    579          */
    580          int WBTD_init(void)
    581          {
    582          	unsigned char	str[21];
    583          
    584          	wbtd_res.DataBuffer = wbtd_recbuffer;
    585          	WBTD_reset_resVar();
    586          	//got_notify_flag = 0;
    587          	//memset(wbtd_notify_buffer,0,WBTD_NOTIFY_BUFFER_LEN);
    588          
    589          	WBTD_GPIO_config(115200);		//default波特率
    590          	WBTD_NVIC_config();
    591          
    592          	if(WBTD_query_version(str))
    593          	{
    594          		return -1;
    595          	}
    596          
    597          #ifdef DEBUG_VER
    598          	printf("BlueTooth Module Ver:%s\r\n",str);
    599          #endif
    600          
    601          	//if (WBTD_set_name("H520B Device"))
    602          	if (WBTD_set_name("WBTDS01"))
    603          	{
    604          		return -3;
    605          	}
    606          
    607          	if (WBTD_set_profile(BT_PROFILE_HID))
    608          	{
    609          		return -4;
    610          	}
    611          
    612          	return 0;
    613          }
    614          
    615          /*
    616           * @brief 蓝牙模块是否获取一个通知消息
    617           * @return 0:  没有获取到通知消息
    618           *         1： 获取到连接成功的通知消息
    619           *         2： 获取到连接断开的通知消息
    620           *		   3:  unknown message
    621          */
    622          int WBTD_got_notify_type(void)
    623          {
    624          	if (wbtd_res.status & (WBTD_RESPONSE_GOT_NOTIFY_CON | WBTD_RESPONSE_GOT_NOTIFY_DISCON))
    625          	{
    626          		if (wbtd_res.status & WBTD_RESPONSE_GOT_NOTIFY_CON)
    627          		{
    628          			wbtd_res.status &= 	~WBTD_RESPONSE_GOT_NOTIFY_CON;
    629          			return 1;
    630          		}
    631          		else
    632          		{
    633          			wbtd_res.status &= 	~WBTD_RESPONSE_GOT_NOTIFY_DISCON;
    634          			return 2;
    635          		}
    636          	}
    637          
    638          	return 0;
    639          }
    640          

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     WBTD_GPIO_config         72
     WBTD_NVIC_config          8
     WBTD_Reset                8
     WBTD_RxISRHandler        16
     WBTD_got_notify_type      0
     WBTD_hid_send            40
     WBTD_init                32
     WBTD_query_version       32
     WBTD_reset_resVar         0
     WBTD_set_autocon         24
     WBTD_set_baudrate        32
     WBTD_set_ioskeypad       24
     WBTD_set_name            48
     WBTD_set_profile         32
     WBTD_write_cmd            8
     memcpy                    8
     send_data_to_WBTDS01     16


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     memcpy                                           14
     wbtd_res                                         12
     wbtd_send_buff                                   32
     wbtd_recbuffer                                  128
     WBTD_GPIO_config                                332
     WBTD_NVIC_config                                114
     send_data_to_WBTDS01                             92
     WBTD_reset_resVar                                26
     WBTD_RxISRHandler                               248
     WBTD_write_cmd                                   92
     WBTD_Reset                                       48
     WBTD_query_version                              176
     WBTD_set_name                                   128
     WBTD_set_baudrate                               240
     WBTD_set_autocon                                 64
     WBTD_set_profile                                 80
     WBTD_set_ioskeypad                               64
     WBTD_hid_send                                   100
     WBTD_init                                        84
     WBTD_got_notify_type                             56
     ??DataTable15                                     4
     ??DataTable16                                     4
     ??DataTable41                                     4
     ??DataTable48                                     4
     ??DataTable50                                     4
     ??DataTable56                                     4
     ?<Constant "\r\n+ERROR">                         12
     ?<Constant "\r\n+DISCON">                        12
     ?<Constant "\r\n+CON">                            8
     ?<Constant "ver_buffer != 0">                    16
     ?<Constant "E:\\H520B\\FW\\src\\Drive...">       36
     ?<Constant "AT+VER?\r\n">                        12
     ?<Constant "VER:">                                8
     ?<Constant "name != 0">                          12
     ?<Constant "AT+DNAME=">                          12
     ?<Constant "AT+URATE=">                          12
     ?<Constant "9600">                                8
     ?<Constant "19200">                               8
     ?<Constant "38400">                               8
     ?<Constant "43000">                               8
     ?<Constant "57600">                               8
     ?<Constant "115200">                              8
     ?<Constant "AT+AUTOCON=">                        12
     ?<Constant "AT+PROFILE=">                        12
     ?<Constant "AT+IOSKB=">                          12
     ?<Constant "\000\000\000\000\000\000\000\000\0   20
     ?<Constant "\000\000(\000\000\000\000\000\000\   20
     ?<Constant "WBTDS01">                             8

 
   172 bytes in section .bss
   272 bytes in section .rodata
 1 982 bytes in section .text
 
 1 968 bytes of CODE  memory (+ 14 bytes shared)
   272 bytes of CONST memory
   172 bytes of DATA  memory

Errors: none
Warnings: 3
