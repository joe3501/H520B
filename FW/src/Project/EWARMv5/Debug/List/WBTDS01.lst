###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     12/Sep/2015  15:35:08 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\Drivers\WBTDS01.c                        #
#    Command line =  E:\H520B\FW\src\Drivers\WBTDS01.c -D DEBUG_VER -lcN      #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\WBTDS01.lst   #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\WBTDS01.o      #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\Drivers\WBTDS01.c
      1          /**
      2          * @file WBTDS01.c
      3          * @brief WBTDS01 蓝牙模块的驱动
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年08月31日
      7          * @note
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "WBTDS01.h"
     17          #include "ucos_ii.h"
     18          #include "stm32f10x_lib.h"
     19          #include "string.h"
     20          #include <assert.h>
     21          
     22          //#define	WBTD_DEBUG
     23          
     24          #define WBTD_RESPONSE_INIT				0
     25          
     26          //通知类型的响应数据状态
     27          #define WBTD_RESPONSE_NOTIFY_BEGIN		1
     28          #define WBTD_RESPONSE_NOTIFY_COMPLETE	2
     29          
     30          //应答类型的响应数据状态
     31          #define WBTD_RESPONSE_ANS_BEGIN			3
     32          #define WBTD_RESPONSE_ANS_COMPLETE		4
     33          
     34          #define WBTD_RESPONSE_FULL				5
     35          
     36          /**
     37          * @brief WBTDS01响应定义  WBTDS01->host
     38          */
     39          typedef struct {
     40          	unsigned short			DataPos;
     41          	unsigned short			DataLength;
     42          	unsigned char			status;
     43          	unsigned char			*DataBuffer;
     44          }TWBTDRes;
     45          
     46          TWBTDRes		wbtd_res;
     47          
     48          #define		WBTD_RES_BUFFER_LEN			64		//从WBTDS01的数据手册上看，没有超过64字节的响应数据		
     49          #define     WBTD_NOTIFY_BUFFER_LEN		32		//
     50          
     51          static unsigned char	wbtd_recbuffer[WBTD_RES_BUFFER_LEN];
     52          static unsigned char	wbtd_notify_buffer[WBTD_NOTIFY_BUFFER_LEN];	
     53          static unsigned int		got_notify_flag;
     54          //static unsigned int		cmd_send_flag;
     55          /*
     56           * @brief: 初始化模块端口
     57           * @note 使用串口2
     58          */
     59          static void WBTD_GPIO_config(unsigned int baudrate)
     60          {
     61          	GPIO_InitTypeDef				GPIO_InitStructure;
     62          	USART_InitTypeDef				USART_InitStructure;
     63          
     64          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
     65          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
     66          
     67          	//B-Reset  PB.1
     68          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1;
     69              GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
     70          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
     71          	GPIO_Init(GPIOB, &GPIO_InitStructure);
     72          	GPIO_SetBits(GPIOB, GPIO_Pin_1);
     73          
     74          	// 使用UART2, PA2,PA3
     75          	/* Configure USART2 Tx (PA.2) as alternate function push-pull */
     76          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
     77          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
     78          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
     79          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     80          
     81          	/* Configure USART2 Rx (PA.3) as input floating				*/
     82          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
     83          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
     84          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     85          
     86          	USART_InitStructure.USART_BaudRate		= baudrate;					
     87          	USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
     88          	USART_InitStructure.USART_StopBits		= USART_StopBits_1;
     89          	USART_InitStructure.USART_Parity		= USART_Parity_No;
     90          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     91          	USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
     92          
     93          	USART_Init(USART2, &USART_InitStructure);
     94          	USART_Cmd(USART2, ENABLE);
     95          }
     96          
     97          /*
     98           * @brief: 串口中断的初始化
     99          */
    100          static void WBTD_NVIC_config(void)
    101          {
    102          	NVIC_InitTypeDef NVIC_InitStructure;
    103          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    104          
    105          	/* Enable the USART2 Interrupt */
    106          	NVIC_InitStructure.NVIC_IRQChannel				=USART2_IRQChannel;
    107          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority	= 0;
    108          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority	= 1;
    109          	NVIC_InitStructure.NVIC_IRQChannelCmd			= ENABLE;
    110          	NVIC_Init(&NVIC_InitStructure);
    111          
    112          	USART_ClearITPendingBit(USART2, USART_IT_RXNE); 
    113          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    114          }
    115          
    116          
    117          /**
    118          * @brief  发数据给蓝牙模块
    119          * @param[in] unsigned char *pData 要发送的数据
    120          * @param[in] int length 要发送数据的长度
    121          */
    122          static void send_data_to_WBTDS01(const unsigned char *pData, unsigned short length)
    123          {
    124          	while(length--)
    125          	{
    126          		USART_SendData(USART2, *pData++);
    127          		while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    128          		{
    129          		}
    130          	}
    131          	while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    132          }
    133          
    134          
    135          /*
    136           * @brief 清空接收蓝牙模块响应数据的buffer
    137          */
    138          static void WBTD_reset_resVar(void)
    139          {
    140          	wbtd_res.DataPos = 0;
    141          	wbtd_res.DataLength = 0;
    142          	wbtd_res.status	 = WBTD_RESPONSE_INIT;
    143          }
    144          
    145          
    146          /**
    147          * @brief 处理host收到WBTD的数据
    148          * @param[in] unsigned char c 读入的字符
    149          * @return 0:success put in buffer
    150          *        -1:fail
    151          */
    152          int WBTD_RxISRHandler(unsigned char c)
    153          {
    154          #ifdef WBTD_DEBUG
    155          	wbtd_res.DataBuffer[wbtd_res.DataPos++] = c;
    156          
    157          	if (wbtd_res.DataPos == 20)
    158          	{
    159          		wbtd_res.DataPos = 0;
    160          		wbtd_res.status	= WBTD_RESPONSE_ANS_COMPLETE;
    161          	}
    162          #else
    163          	if (wbtd_res.DataPos == WBTD_RES_BUFFER_LEN)
    164          	{
    165          		wbtd_res.status = WBTD_RESPONSE_FULL;
    166          	}
    167          
    168          	if(wbtd_res.status == WBTD_RESPONSE_FULL)
    169          	{
    170          		return -1;
    171          	}
    172          
    173          	if (wbtd_res.status == WBTD_RESPONSE_INIT || wbtd_res.status == WBTD_RESPONSE_NOTIFY_COMPLETE \
    174          		|| wbtd_res.status == WBTD_RESPONSE_ANS_COMPLETE)
    175          	{
    176          		wbtd_res.DataPos = 0;
    177          		wbtd_res.DataBuffer[wbtd_res.DataPos++] = c;
    178          		if(c == '+')
    179          		{
    180          			got_notify_flag = 0;
    181          			wbtd_res.status = WBTD_RESPONSE_NOTIFY_BEGIN;
    182          		}
    183          		else if ((c == 0x0d)&&(c==0x0a))
    184          		{
    185          			wbtd_res.DataPos--;		//第一个字节就是0x0d或者0x0a，丢弃
    186          		}
    187          		else
    188          		{
    189          			wbtd_res.status = WBTD_RESPONSE_ANS_BEGIN;
    190          		}
    191          	}
    192          	else
    193          	{
    194          		wbtd_res.DataBuffer[wbtd_res.DataPos++] = c;
    195          		if (c == 0x0d || c == 0x0a)
    196          		{
    197          			if (wbtd_res.status == WBTD_RESPONSE_NOTIFY_BEGIN)
    198          			{
    199          				wbtd_res.status = WBTD_RESPONSE_NOTIFY_COMPLETE;
    200          				got_notify_flag = 1;
    201          				memcpy(wbtd_notify_buffer,wbtd_res.DataBuffer,wbtd_res.DataPos-1);
    202          				wbtd_notify_buffer[wbtd_res.DataPos-1] = 0;
    203          			}
    204          			else
    205          			{
    206          				wbtd_res.status = WBTD_RESPONSE_ANS_COMPLETE;
    207          			}
    208          		}
    209          	}
    210          #endif
    211          	return 0;
    212          }
    213          
    214          
    215          /**
    216          * @brief  发命令给蓝牙模块WBTDS01,并等待响应结果
    217          * @param[in] unsigned char *pData 要发送的数据
    218          * @param[in] unsigned int	length 要发送数据的长度
    219          * @return		0: 成功
    220          *				-1: 失败
    221          */
    222          static int WBTD_write_cmd(const unsigned char *pData, unsigned int length)
    223          {
    224          	unsigned int	wait_cnt;
    225          	send_data_to_WBTDS01(pData, length);
    226          	WBTD_reset_resVar();
    227          	//cmd_send_flag = 1;
    228          	wait_cnt = 50;
    229          	while (wait_cnt)
    230          	{
    231          		if (wbtd_res.status == WBTD_RESPONSE_ANS_COMPLETE)
    232          		{
    233          			//cmd_send_flag = 0;
    234          			return 0;
    235          		}
    236          		else if (wbtd_res.status == WBTD_RESPONSE_FULL)
    237          		{
    238          			//cmd_send_flag = 0;
    239          			return -1;
    240          		}
    241          
    242          		OSTimeDlyHMSM(0,0,0,20);
    243          		wait_cnt--;
    244          	}
    245          
    246          	return -1;
    247          }
    248          
    249          
    250          //const unsigned char	*query_version_cmd="AT+VER=?";
    251          //const unsigned char	*set_device_name_cmd="AT+DNAME=%s";
    252          
    253          /*
    254           * @brief 蓝牙模块WBTDS01的复位
    255          */
    256          void WBTD_Reset(void)
    257          {
    258          	//拉低复位信号100ms
    259          	GPIO_ResetBits(GPIOB, GPIO_Pin_1);
    260          	OSTimeDlyHMSM(0,0,0,100);
    261          	GPIO_SetBits(GPIOB, GPIO_Pin_1);
    262          
    263          	WBTD_reset_resVar();
    264          
    265          	got_notify_flag = 0;
    266          	memset(wbtd_notify_buffer,0,WBTD_NOTIFY_BUFFER_LEN);
    267          	OSTimeDlyHMSM(0,0,0,100);
    268          }
    269          
    270          /*
    271           * @brief 查询蓝牙模块WBTDS01的版本号
    272           * @param[out]  unsigned char *ver_buffer  返回查询到的版本号，如果为空表示查询失败
    273          */
    274          int WBTD_query_version(unsigned char *ver_buffer)
    275          {
    276          	unsigned char	buffer[21];
    277          	int		ret;
    278          
    279          	assert(ver_buffer != 0);
    280          	ver_buffer[0] = 0;
    281          	memcpy(buffer,"AT+VER=?\x0d\x0a",10);
    282          	ret = WBTD_write_cmd((const unsigned char*)buffer,10);
    283          	if (ret)
    284          	{
    285          		return -1;
    286          	}
    287          
    288          	if ((wbtd_res.DataLength > 1)&&((wbtd_res.DataBuffer[0] == 'V')||(wbtd_res.DataBuffer[0] == 'v')))
    289          	{
    290          		if (wbtd_res.DataLength < 22)
    291          		{
    292          			memcpy(ver_buffer,wbtd_res.DataBuffer,wbtd_res.DataLength-1);
    293          			ver_buffer[wbtd_res.DataLength-1] = 0;
    294          		}
    295          		else
    296          		{
    297          			memcpy(ver_buffer,wbtd_res.DataBuffer,20);
    298          			ver_buffer[20] = 0;
    299          		}
    300          
    301          		return 0;
    302          	}
    303          
    304          	return -1;
    305          }
    306          
    307          
    308          /*
    309           * @brief 设置蓝牙模块的设备名称
    310           * @param[in]  unsigned char *name  设置的名称,字符串
    311           * @return 0: 设置成功		else：设置失败
    312           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
    313           *       在此接口中将设备名称限定为最长支持20个字节
    314          */
    315          int WBTD_set_name(unsigned char *name)
    316          {
    317          	unsigned char	buffer[31];
    318          	int		ret,len;
    319          
    320          	assert(name != 0);
    321          	memcpy(buffer,"AT+DNAME=",9);
    322          	len = strlen((char const*)name);
    323          	if (len>20)
    324          	{
    325          		memcpy(buffer+9,name,20);
    326          		buffer[29] = 0x0d;
    327          		buffer[30] = 0x0a;
    328          		len = 31;
    329          	}
    330          	else
    331          	{
    332          		memcpy(buffer+9,name,len);
    333          		buffer[9+len] = 0x0d;
    334          		buffer[10+len] = 0x0a;
    335          		len = 11+len;
    336          	}
    337          	ret = WBTD_write_cmd((const unsigned char*)buffer,len);
    338          	if (ret)
    339          	{
    340          		return -1;
    341          	}
    342          
    343          	if ((wbtd_res.DataLength == 3)&&(memcmp(wbtd_res.DataBuffer,"OK\x0d",3) == 0))
    344          	{
    345          		return 0;
    346          	}
    347          
    348          	return -1;
    349          }
    350          
    351          /*
    352           * @brief 设置蓝牙模块的设备名称
    353           * @param[in]  unsigned char *name  设置的名称,字符串
    354           * @return 0: 设置成功		else：设置失败
    355           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
    356           *       在此接口中将设备名称限定为最长支持20个字节
    357          */
    358          int WBTD_set_baudrate(WBTD_BAUDRATE baudrate)
    359          {
    360          	unsigned char	buffer[20];
    361          	int		ret,len;
    362          
    363          	memcpy(buffer,"AT+URATE=",9);
    364          	len = 16;
    365          	switch(baudrate)
    366          	{
    367          	case BAUDRATE_9600:
    368          		memcpy(buffer+9,"9600",4);
    369          		buffer[13] = 0x0d;
    370          		buffer[14] = 0x0a;
    371          		len = 15;
    372          		break;
    373          	case BAUDRATE_19200:
    374          		memcpy(buffer+9,"19200",5);
    375          		buffer[14] = 0x0d;
    376          		buffer[15] = 0x0a;
    377          		break;
    378          	case BAUDRATE_38400:
    379          		memcpy(buffer+9,"38400",5);
    380          		buffer[14] = 0x0d;
    381          		buffer[15] = 0x0a;
    382          		break;
    383          	case BAUDRATE_43000:
    384          		memcpy(buffer+9,"43000",5);
    385          		buffer[14] = 0x0d;
    386          		buffer[15] = 0x0a;
    387          		break;
    388          	case BAUDRATE_57600:
    389          		memcpy(buffer+9,"57600",5);
    390          		buffer[14] = 0x0d;
    391          		buffer[15] = 0x0a;
    392          		break;
    393          	case BAUDRATE_115200:
    394          		memcpy(buffer+9,"115200",6);
    395          		buffer[15] = 0x0d;
    396          		buffer[16] = 0x0a;
    397          		len = 17;
    398          		break;
    399          	}
    400          	ret = WBTD_write_cmd((const unsigned char*)buffer,len);
    401          	if (ret)
    402          	{
    403          		return -1;
    404          	}
    405          
    406          	if ((wbtd_res.DataLength == 3)&&(memcmp(wbtd_res.DataBuffer,"OK\x0d",3) == 0))
    407          	{
    408          		return 0;
    409          	}
    410          
    411          	return -1;
    412          }
    413          
    414          /*
    415           * @brief 使蓝牙模块进入配对模式
    416           * @param[in]  unsigned char mode  配对模式  
    417           *			1: 蓝牙模块会试图重连之前的蓝牙主机   
    418           *			0：蓝牙模块不会试图重连之前的蓝牙主机   
    419           * @return 0: 设置成功		else：设置失败
    420          */
    421          int WBTD_set_autocon(unsigned char mode)
    422          {
    423          	unsigned char	buffer[15];
    424          	int		ret;
    425          
    426          	memcpy(buffer,"AT+AUTOCON=",11);
    427          	if (mode)
    428          	{
    429          		buffer[11] = '1';
    430          	}
    431          	else
    432          	{
    433          		buffer[11] = '0';
    434          	}
    435          	buffer[12] = 0x0d;
    436          	buffer[13] = 0x0a;
    437          	ret = WBTD_write_cmd((const unsigned char*)buffer,14);
    438          	if (ret)
    439          	{
    440          		return -1;
    441          	}
    442          
    443          	if ((wbtd_res.DataLength == 3)&&(memcmp(wbtd_res.DataBuffer,"OK\x0d",3) == 0))
    444          	{
    445          		return 0;
    446          	}
    447          
    448          	return -1;
    449          }
    450          
    451          /*
    452           * @brief 设置蓝牙模块的工作模式(profile = HID、SPP、BLE)
    453           * @param[in]  unsigned char mode  蓝牙模块的工作模式     
    454           * @return 0: 设置成功		else：设置失败
    455          */
    456          int WBTD_set_profile(BT_PROFILE mode)
    457          {
    458          	unsigned char	buffer[20];
    459          	int		ret;
    460          
    461          	memcpy(buffer,"AT+PROFILE=",11);
    462          	if (mode == BT_PROFILE_HID)
    463          	{
    464          		buffer[11] = '2';
    465          	}
    466          	else if (mode == BT_PROFILE_SPP)
    467          	{
    468          		buffer[11] = '1';
    469          	}
    470          	else
    471          	{
    472          		buffer[11] = '0';
    473          	}
    474          	buffer[12] = 0x0d;
    475          	buffer[13] = 0x0a;
    476          	ret = WBTD_write_cmd((const unsigned char*)buffer,14);
    477          	if (ret)
    478          	{
    479          		return -1;
    480          	}
    481          
    482          	if ((wbtd_res.DataLength == 3)&&(memcmp(wbtd_res.DataBuffer,"OK\x0d",3) == 0))
    483          	{
    484          		return 0;
    485          	}
    486          
    487          	return -1;
    488          }
    489          
    490          /*
    491           * @brief 设置蓝牙模块是否使能IOS soft keyboard
    492           * @param[in]  unsigned char enable  1:Enable   0:Disable
    493           * @return 0: 设置成功		else：设置失败
    494          */
    495          int WBTD_set_ioskeypad(unsigned char enable)
    496          {
    497          	unsigned char	buffer[15];
    498          	int		ret;
    499          
    500          	memcpy(buffer,"AT+IOSKB=",9);
    501          	if (enable)
    502          	{
    503          		buffer[9] = '1';
    504          	}
    505          	else
    506          	{
    507          		buffer[9] = '0';
    508          	}
    509          	buffer[10] = 0x0d;
    510          	buffer[11] = 0x0a;
    511          	ret = WBTD_write_cmd((const unsigned char*)buffer,12);
    512          	if (ret)
    513          	{
    514          		return -1;
    515          	}
    516          
    517          	if ((wbtd_res.DataLength == 3)&&(memcmp(wbtd_res.DataBuffer,"OK\x0d",3) == 0))
    518          	{
    519          		return 0;
    520          	}
    521          
    522          	return -1;
    523          }
    524          
    525          /*
    526           * @brief 通过蓝牙模块的HID模式发送ASCII字符串
    527           * @param[in]  unsigned char *str		需要发送的ASCII字符缓冲
    528           * @param[in]  unsigned int  len	    待发送字符数
    529           * @param[out]  unsigned int *send_len  实际发送的字符数
    530           * @return 0: 发送成功		else：发送失败
    531          */
    532          int WBTD_hid_send(unsigned char *str,unsigned int len,unsigned int *send_len)
    533          {
    534          	//@todo...
    535          	OSTimeDlyHMSM(0,0,0,20);
    536                  return 0;
    537          }
    538          
    539          /*
    540           * @brief 蓝牙模块WBTDS01的初始化
    541          */
    542          int WBTD_init(void)
    543          {
    544          	unsigned char	str[21];
    545          	WBTD_GPIO_config(115200);		//default波特率
    546          	WBTD_NVIC_config();
    547          
    548          	wbtd_res.DataBuffer = wbtd_recbuffer;
    549          	WBTD_reset_resVar();
    550          	
    551          	got_notify_flag = 0;
    552          	memset(wbtd_notify_buffer,0,WBTD_NOTIFY_BUFFER_LEN);
    553          
    554          	if(WBTD_query_version(str))
    555          	{
    556          		return -1;
    557          	}
    558          
    559          	if (strcmp((char const*)str,"VER02A")!=0)
    560          	{
    561          		return -2;
    562          	}
    563          
    564          	if (WBTD_set_name("H520B Device"))
    565          	{
    566          		return -3;
    567          	}
    568          
    569          	if (WBTD_set_profile(BT_PROFILE_HID))
    570          	{
    571          		return -4;
    572          	}
    573          
    574          	return 0;
    575          }
    576          
    577          /*
    578           * @brief 蓝牙模块是否获取一个通知消息
    579           * @return 0:  没有获取到通知消息
    580           *         1： 获取到连接成功的通知消息
    581           *         2： 获取到连接断开的通知消息
    582           *		   3:  unknown message
    583          */
    584          int WBTD_got_notify_type(void)
    585          {
    586          	if (got_notify_flag)
    587          	{
    588          		got_notify_flag = 0;
    589          		if (strcmp((char const*)wbtd_notify_buffer,"+CON") == 0)
    590          		{
    591          			return 1;
    592          		}
    593          		else if (strcmp((char const*)wbtd_notify_buffer,"+DISCON") == 0)
    594          		{
    595          			return 2;
    596          		}
    597          		else
    598          		{
    599          			return 3;
    600          		}
    601          	}
    602          
    603          	return 0;
    604          }
    605          

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     WBTD_GPIO_config         32
     WBTD_NVIC_config          8
     WBTD_Reset                8
     WBTD_RxISRHandler         8
     WBTD_got_notify_type      8
     WBTD_hid_send             8
     WBTD_init                32
     WBTD_query_version       32
     WBTD_reset_resVar         0
     WBTD_set_autocon         24
     WBTD_set_baudrate        32
     WBTD_set_ioskeypad       24
     WBTD_set_name            48
     WBTD_set_profile         32
     WBTD_write_cmd            8
     memcpy                    8
     memset                    8
     send_data_to_WBTDS01     16


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     memcpy                                       14
     memset                                       20
     wbtd_res                                     12
     wbtd_recbuffer                               64
     wbtd_notify_buffer                           32
     got_notify_flag                               4
     WBTD_GPIO_config                            160
     WBTD_NVIC_config                             58
     send_data_to_WBTDS01                         56
     WBTD_reset_resVar                            26
     WBTD_RxISRHandler                           284
     WBTD_write_cmd                               70
     WBTD_Reset                                   68
     WBTD_query_version                          176
     WBTD_set_name                               176
     WBTD_set_baudrate                           288
     WBTD_set_autocon                            108
     WBTD_set_profile                            124
     WBTD_set_ioskeypad                          108
     WBTD_hid_send                                18
     WBTD_init                                   128
     WBTD_got_notify_type                         64
     ??DataTable8                                  4
     ??DataTable44                                 4
     ??DataTable56                                 4
     ??DataTable67                                 4
     ??DataTable71                                 4
     ??DataTable73                                 4
     ?<Constant "ver_buffer != 0">                16
     ?<Constant "E:\\H520B\\FW\\src\\Drive...">   36
     ?<Constant "AT+VER=?\r\n">                   12
     ?<Constant "name != 0">                      12
     ?<Constant "AT+DNAME=">                      12
     ?<Constant "OK\r">                            4
     ?<Constant "AT+URATE=">                      12
     ?<Constant "9600">                            8
     ?<Constant "19200">                           8
     ?<Constant "38400">                           8
     ?<Constant "43000">                           8
     ?<Constant "57600">                           8
     ?<Constant "115200">                          8
     ?<Constant "AT+AUTOCON=">                    12
     ?<Constant "AT+PROFILE=">                    12
     ?<Constant "AT+IOSKB=">                      12
     ?<Constant "VER02A">                          8
     ?<Constant "H520B Device">                   16
     ?<Constant "+DISCON">                         8
     ?<Constant "+CON">                            8

 
   112 bytes in section .bss
   228 bytes in section .rodata
 1 970 bytes in section .text
 
 1 936 bytes of CODE  memory (+ 34 bytes shared)
   228 bytes of CONST memory
   112 bytes of DATA  memory

Errors: none
Warnings: none
