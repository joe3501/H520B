###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     27/Jan/2016  10:53:45 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\Drivers\HJ5000_scanner.c                 #
#    Command line =  E:\H520B\FW\src\Drivers\HJ5000_scanner.c -lcN            #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\HJ5000_scanne #
#                    r.lst                                                    #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\HJ5000_scanner #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\Drivers\HJ5000_scanner.c
      1          /**
      2          * @file  HJ5000_scanner.c
      3          * @brief HJ5000红光CCD条码扫描引擎的驱动模块
      4          * @version 1.0
      5          * @author joe.zhou
      6          * @date 2015年08月22日
      7          * @note
      8          * 
      9          */
     10          #include <string.h>
     11          #include "ucos_ii.h"
     12          #include "HJ5000_scanner.h"
     13          #include "TimeBase.h"
     14          #include "keypad.h"
     15          #include "PCUsart.h"
     16          #include "hw_platform.h"
     17          #include "app.h"
     18          #include "record_m.h"
     19          #define HJ5000_FRAME_MAX_LEN		257
     20          
     21          #define USART_RX_DMA_MODE		1
     22          #define USART_RX_ISR_MODE		2
     23          
     24          //#define USART_RX_MODE		USART_RX_DMA_MODE
     25          #define USART_RX_MODE		USART_RX_ISR_MODE
     26          
     27          
     28          #define HJ5000_START_DECODE		1
     29          #define HJ5000_STOP_DECODE		2
     30          #define HJ5000_READ_CFG			3
     31          #define HJ5000_SET_ALL_DEFAULT	4
     32          
     33          
     34          #define ENABLE		1
     35          #define DISABLE		0
     36          
     37          #define HJ5000_START_DECODE		1
     38          #define HJ5000_STOP_DECODE		2
     39          #define HJ5000_READ_CFG			3
     40          #define HJ5000_SET_ALL_DEFAULT	4
     41          
     42          
     43          #define ENABLE		1
     44          #define DISABLE		0
     45          
     46          	
     47          #define InterfaceType	0x00	//00H KB  01H RS232   02H USB_KB  03H   USB_RS232 
     48          #define KBType			0x01	//00H	键盘类型
     49          #define KBLanguage		0x02	//00H 	键盘语言
     50          #define DspCodeMark		0x03	//00H	显示所有条形码代码
     51          #define KBWedge			0x04	//00H	键盘功能设置		
     52          #define KBEmulation		0x05	//00H	仿真键盘响应(for notebook)		
     53          #define KBCLKSpeed		0x06	//10H	Clock(实际频率)=20+KBCLKSpeed. Default=0x10.		
     54          #define InterCharDel	0x07	//00H	0 ~ 99mS (输入值乘  1mS)		
     55          #define InterMessDel	0x08	//00H	0 ~  5 S (输入值乘100mS)		
     56          #define KBTerminator	0x09	//01H	00H=NONE, 01H=0DH, 02H=09H.		
     57          #define RSFlowCtrl		0x0A	//00H	00H=NONE, 01H=CTS/RTS,02H=Xon/Xoff.		
     58          #define RSHshakingDel	0x0B	//00H	Handshaking Delay		0x0C				
     59          #define RSACKDel		0x0D	//00H			
     60          #define RSParity		0x0E	//00H	(00H=None, 01H=Even, 02H=Odd) 01H Without odd		
     61          #define RSStop			0x0F	//00H	(00H=1 Stop Bit, 01H=2 Stop Bit)		
     62          #define RSData			0x10	//01H	(00H=7 Data Bits, 01H=8 Data Bits)		
     63          #define RSBaudRate		0x11	//04H	(00H=9600, 01H=9600, 02H=2400, 03H=4800, 04H=9600 , 05H=19200, 06H=57600, 07H=38400, 08H=115200)		
     64          #define RSTerminator	0x12	//01H	(00H=NONE, 01H=0DH&0AH, 02H=0DH, 03H=0AH, 04H=09H, 05H=03H, 06H=04H)		
     65          #define FlashSW			0x13	//00H	00H=长亮模式时不闪烁, 01H=长亮模式时闪烁		
     66          		
     67          #define GoodReadBeep	0x17	//01H	读取声, 00H=Disable, 01H=Enable		
     68          #define PowerUpTone		0x18	//01H	开机声, 00H=Disable, 01H=Enable		
     69          #define ScanMode		0x19	//01H	00H=Trigger On/Off, 01H=Trigger On/Good read off, 02H=Continuous/Trigger off, 04H=continuous/LED always ON, 05H=Continuous/timeout off, 06=Flash ON, 07=Continuous/No Trigger, 08=Software trigger and trigger pin=Low,0A=Software trigger		
     70          #define SoundFre		0x1A	//09H	0~15音频对应(1.5KHz~3KHz)		
     71          #define SoundLeng		0x1B	//04H	0~99 mS		
     72          #define PrefixChar_L	0x1C	//00H	 Prefix目前输入字数		
     73          #define PrefixChar		0x1D	//00H	1DH~26H位置数据		
     74          
     75          #define PostfixChar_L	0x27	//00H	Postfix目前输入字数		
     76          #define PostfixChar		0x28	//00H	28H~31H位置数据		
     77          					
     78          #define UAEnable		0x32	//01H	// UPC-A     ON/OFF ( 00H=Disable, 01H=Enable)		
     79          #define UAIdent			0x33	//46H	// UPC-A     ID code		
     80          #define UAInsertCode	0x34	//00H	// UPA-A     insert G1 or G2 code ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
     81          #define UAtoE13			0x35	//00H	// UPC-A     convert to EAN13  ( 00H=Disable, 01H=Enable)		
     82          #define UATranCheck		0x36	//01H	// UPC-A     transmit CC(check character)  ( 00H=Disable, 01H=Enable)		
     83          #define UACut0			0x37	//00H	// UPC-A     cut first Zero  ( 00H=Disable, 01H=Enable)		
     84          #define UACutFNum		0x38	//00H	// UPC-A     cut front number		
     85          #define UACutBNum		0x39	//00H	// UPC-A     cut back number		
     86          #define UAAddendum		0x3A	//00H	// UPC-A     Add on 2/5		
     87          #define UAAddForce		0x3B	//00H	// UPC-A     enforce Add on 2/5		
     88          					
     89          #define UEEnable		0x3C	//01H	// UPC-E     ON/OFF ( 00H=Disable, 01H=Enable)		
     90          #define UEIdent			0x3D	//47H	// UPC-E     ID code		
     91          #define UEInsertCode	0x3E	//00H	// UPA-E     insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
     92          #define UEtoUA			0x3F	//00H	// UPC-E     convert to UPC-A ( 00H=Disable, 01H=Enable)		
     93          #define UETranCheck		0x40	//01H	// UPC-E     transmit CC ( 00H=Disable, 01H=Enable)		
     94          #define UECut0			0x41	//00H	// UPC-E     cut first Zero ( 00H=Disable, 01H=Enable)		
     95          #define UECutFNum		0x42	//00H	// UPC-E     cut front number		
     96          #define UECutBNum		0x43	//00H	// UPC-E     cut back number		
     97          #define UEAddendum		0x44	//00H	// UPC-E     Add on 2/5		
     98          #define UEAddForce		0x45	//00H	// UPC-E     enforce Add on 2/5		
     99          					
    100          #define E13Enable		0x46	//01H	// EAN13     ON/OFF ( 00H=Disable, 01H=Enable)		
    101          #define E13Ident		0x47	//48H	// EAN13     ID code		
    102          #define E13InsertCode	0x48	//00H	// EAN13     insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    103          #define E13TranCheck	0x49	//01H	// EAN13     transmit CC ( 00H=Disable, 01H=Enable)		
    104          #define E13CutFNum		0x4A	//00H	// EAN13     cut front number		
    105          #define E13CutBNum		0x4B	//00H	// EAN13     cut back number		
    106          #define E13Addendum		0x4C	//00H	// EAN13     Add on 2/5		
    107          #define E13AddForce		0x4D	//00H	// EAN13     enforce Add on 2/5		
    108          #define E13ISEnable		0x4E	//00H	// ISBNISSN  exchange ( 00H=Disable, 01H=Enable)		
    109          #define E13ISBNAdd		0x4F	//00H	// ISBN      insert 间隔符号 ( 00H=Disable, 01H=Enable)		
    110          					
    111          #define E8Enable		0x50	//01H	// EAN-8     ON/OFF ( 00H=Disable, 01H=Enable)		
    112          #define E8Ident			0x51	//49H	// EAN-8     ID code		
    113          #define E8InsertCode	0x52	//00H	// EAN-8     insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    114          #define E8TranCheck		0x53	//01H	// EAN-8     transmit CC ( 00H=Disable, 01H=Enable)		
    115          #define E8CutFNum		0x54	//00H	// EAN-8     cut front number		
    116          #define E8CutBNum		0x55	//00H	// EAN-8     cut back number		
    117          #define E8Addendum		0x56	//00H	// EAN-8     Add on 2/5		
    118          #define E8AddForce		0x57	//00H	// EAN-8     enforce Add on 2/5		
    119          					
    120          #define Addendum		0x58	//00H	// UPC_EAN   Add on 2/5  (same time open UPC/EAN all add on 2/5)		
    121          #define AddendForce		0x59	//00H	// UPC_EAN   enforce Add on 2/5 (同时强制UPC/EAN所有附加码)		
    122          					
    123          #define C39Enable		0x5A	//01H	// Code39    ON/OFF ( 00H=Disable, 01H=Enable)		
    124          #define C39Ident		0x5B	//4AH	// Code39    ID code		
    125          #define C39InsertCode	0x5C	//00H	// Code39    insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    126          #define C39Check		0x5D	//00H	// Code39    Check CS ( 00H=Disable, 01H=Enable)		
    127          #define C39TranCheck	0x5E	//00H	// Code39    transmit CC ( 00H=Disable, 01H=Enable)		
    128          #define C39Concat		0x5F	//00H	// Code39    当C39第一字符是"space"时,close message terminator transmit ( 00H=Disable, 01H=Enable)		
    129          #define C39Format		0x60	//00H	// Code39    格式(standard or Full code) ( 00H=Standard C39, 01H=Full C39)		
    130          #define C39TranOEChar	0x61	//00H	// Code39    传送起始&结束符号 ( 00H=Disable, 01H=Enable)		
    131          #define C39CutFNum		0x62	//00H	// Code39    cut front number		
    132          #define C39CutBNum		0x63	//00H	// Code39    cut back number		
    133          #define C39SLeng		0x64	//00H	// Code39    min length		
    134          #define C39DLeng		0x65	//50H	// Code39    max length		
    135          					
    136          #define CdaEnable		0x66	//01H	// Codabar   ON/OFF ( 00H=Disable, 01H=Enable)		
    137          #define CdaIdent		0x67	//4BH	// Codabar   ID code		
    138          #define CdaInsertCode	0x68	//00H	// Codabar   insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    139          #define CdaCheck		0x69	//00H	// Codabar   Check CS ( 00H=Disable, 01H=Enable)		
    140          #define CdaTranCheck	0x6A	//01H	// Codabar   transmit CC ( 00H=Disable, 01H=Enable)		
    141          #define CdaConcat		0x6B	//00H	//		
    142          #define CdaOECharType	0x6C	//00H	// Codabar   传送起始&结束类型(00H=ABCD/ABCD,01H=abcd/abcd,02H=abcd/tn*e)		
    143          #define CdaTranOEChar	0x6D	//01H	// Codabar   传送起始&结束符号 ( 00H=Disable, 01H=Enable)		
    144          #define CdaCutFNum		0x6E	//00H	// Codabar   cut front number		
    145          #define CdaCutBNum		0x6F	//00H	// Codabar   cut back number		
    146          #define CdaSLeng		0x70	//06H	// Codabar   min length		
    147          #define CdaDLeng		0x71	//50H	// Codabar   max length		
    148          					
    149          #define C93Enable		0x72	//01H	// Code93    ON/OFF ( 00H=Disable, 01H=Enable)		
    150          #define C93Ident		0x73	//4CH	// Code93    ID code		
    151          #define C93InsertCode	0x74	//00H	// Code93    insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    152          #define C93Check		0x75	//01H	// Code93    Check CS ( 00H=Disable, 01H=Enable)		
    153          #define C93TranCheck	0x76	//00H	// Code93    transmit CC ( 00H=Disable, 01H=Enable)		
    154          #define C93CutFNum		0x77	//00H	// Code93    cut front number		
    155          #define C93CutBNum		0x78	//00H	// Code93    cut back number		
    156          #define C93SLeng		0x79	//03H	// Code93    min length		
    157          #define C93DLeng		0x7A	//50H	// Code93    max length		
    158          					
    159          #define C128Enable		0x7B	//01H	// Code128   ON/OFF ( 00H=Disable, 01H=Enable)		
    160          #define C128Ident		0x7C	//4DH	// Code128   ID code		
    161          #define C128InsertCode	0x7D	//00H	// Code128   insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    162          #define C128Check		0x7E	//01H	// Code128   Check CS ( 00H=Disable, 01H=Enable)		
    163          #define C128TranCheck	0x7F	//00H	// Code128   transmit CC ( 00H=Disable, 01H=Enable)		
    164          #define C128Fuc1		0x80	//00H	// Code128    当C128第一字符是"FUC1"时,结合下一组条形码 message ( 00H=Disable, 01H=Enable)		
    165          #define C128Fuc2		0x81	//00H	// Code128    当C128中有"FUC2"时, FUC2转换为"1DH" ( 00H=Disable, 01H=Enable)		
    166          #define EAN128En		0x82	//00H	// Code128 转换为EAN128 ( 00H=Disable, 01H=Enable)		
    167          #define C128CutFNum		0x83	//00H	// Code128   cut front number		
    168          #define C128CutBNum		0x84	//00H	// Code128   cut back number		
    169          #define C128SLeng		0x85	//03H	// Code128   min length		
    170          #define C128DLeng		0x86	//50H	// Code128   max length		
    171          					
    172          #define It25Enable		0x87	//01H	// It25      ON/OFF ( 00H=Disable, 01H=Enable)		
    173          #define It25Ident		0x88	//4EH	// It25      ID code		
    174          #define It25InsertCode	0x89	//00H	// It25      insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    175          #define It25Check		0x8A	//00H	// It25      Check CS ( 00H=Disable, 01H=Enable)		
    176          #define It25TranCheck	0x8B	//00H	// It25      transmit CC ( 00H=Disable, 01H=Enable)		
    177          #define It25CutFNum		0x8C	//00H	// It25      cut front number		
    178          #define It25CutBNum		0x8D	//00H	// It25      cut back number		
    179          #define It25SLeng		0x8E	//04H	// It25      min length		
    180          #define It25DLeng		0x8F	//50H	// It25      max length		
    181          					
    182          #define Id25Enable		0x90	//00H	// Id25      ON/OFF ( 00H=Disable, 01H=Enable)		
    183          #define Id25Ident		0x91	//4FH	// Id25      ID code		
    184          #define Id25InsertCode	0x92	//00H	// Id25      insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    185          #define Id25Check		0x93	//00H	// Id25      Check CS ( 00H=Disable, 01H=Enable)		
    186          #define Id25TranCheck	0x94	//00H	// Id25      transmit CC ( 00H=Disable, 01H=Enable)		
    187          #define Id25CutFNum		0x95	//00H	// ID25      cut front number		
    188          #define Id25CutBNum		0x96	//00H	// ID25      cut back number		
    189          #define Id25SLeng		0x97	//06H	// Id25      min length		
    190          #define Id25DLeng		0x98	//50H	// Id25      max length		
    191          					
    192          #define S25Enable		0x99	//00H	// S25       ON/OFF ( 00H=Disable, 01H=Enable)		
    193          #define S25Ident		0x9A	//57H	// S25       ID code		
    194          #define S25InsertCode	0x9B	//00H	// S25       insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    195          #define S25CutFNum		0x9C	//00H	// S25       cut front number		
    196          #define S25CutBNum		0x9D	//00H	// S25       cut back number		
    197          #define S25SLeng		0x9E	//06H	// S25       min length		
    198          #define S25DLeng		0x9F	//50H	// S25       max length		
    199          					
    200          #define M25Enable		0xA0	//00H	// M25       ON/OFF ( 00H=Disable, 01H=Enable)		
    201          #define M25Ident		0xA1	//50H	// M25       ID code		
    202          #define M25InsertCode	0xA2	//00H	// M25       insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    203          #define M25Check		0xA3	//00H	// M25       Check CS ( 00H=Disable, 01H=Enable)		
    204          #define M25TranCheck	0xA4	//01H	// M25       transmit CC ( 00H=Disable, 01H=Enable)		
    205          #define M25CutFNum		0xA5	//00H	// M25       cut front number		
    206          #define M25CutBNum		0xA6	//00H	// M25       cut back number		
    207          #define M25SLeng		0xA7	//06H	// M25       min length		
    208          #define M25DLeng		0xA8	//50H	// M25       max length		
    209          					
    210          #define CPEnable		0xA9	//00H	// CPC       ON/OFF ( 00H=Disable, 01H=Enable)		
    211          #define CPIdent			0xAA	//51H	// CPC       ID code		
    212          #define CPInsertCode	0xAB	//00H	// CPC       insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    213          #define CPCheck			0xAC	//00H	// CPC       Check CS ( 00H=Disable, 01H=Enable)		
    214          #define CPTranCheck		0xAD	//00H	// CPC       transmit CC ( 00H=Disable, 01H=Enable)		
    215          #define CPCutFNum		0xAE	//00H	// CPC       cut front number		
    216          #define CPCutBNum		0xAF	//00H	// CPC       cut back number		
    217          #define CPSLeng			0xB0	//06H	// CPC       min length		
    218          #define CPDLeng			0xB1	//50H	// CPC       max length		
    219          					
    220          #define C11Enable		0xB2	//00H	// Code11    ON/OFF ( 00H=Disable, 01H=Enable)		
    221          #define C11Ident		0xB3	//54H	// Code11    ID code		
    222          #define C11InsertCode	0xB4	//00H	// Code11    insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    223          #define C11Check		0xB5	//00H	// Code11    Check CS ( 00H=Disable, 01H=Enable)		
    224          #define C11TranCheck	0xB6	//00H	// Code11    transmit CC ( 00H=Disable, 01H=Enable)		
    225          #define C11CutFNum		0xB7	//00H	// Code11    cut front number		
    226          #define C11CutBNum		0xB8	//00H	// Code11    cut back number		
    227          #define C11SLeng		0xB9	//06H	// Code11    min length		
    228          #define C11DLeng		0xBA	//50H	// Code11    max length		
    229          					
    230          #define MSEnable		0xBB	//00H	// MSI       ON/OFF ( 00H=Disable, 01H=Enable)		
    231          #define MSIdent			0xBC	//52H	// MSI       ID code		
    232          #define MSInsertCode	0xBD	//00H	// MSI       insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    233          #define MSCheck			0xBE	//00H	// MSI       Check CS ( 00H=Disable, 01H=Enable)		
    234          #define MSTranCheck		0xBF	//01H	// MSI       transmit CC ( 00H=Disable, 01H=Enable)		
    235          #define MSCutFNum		0xC0	//00H	// MSI       cut front number		
    236          #define MSCutBNum		0xC1	//00H	// MSI       cut back number		
    237          #define MSSLeng			0xC2	//06H	// MSI       min length		
    238          #define MSDLeng			0xC3	//50H	// MSI       max length		
    239          					
    240          #define C32Enable		0xC4	//00H	// Code32    ON/OFF ( 00H=Disable, 01H=Enable)		
    241          #define C32Ident		0xC5	//53H	// Code32    ID code		
    242          #define C32InsertCode	0xC6	//00H	// Code32    insert G1 or G2 code  ( 00H=Disable, 01H=G1 code, 02H=G2 code)		
    243          #define C32Check		0xC7	//00H	// Code32    Check CS ( 00H=Disable, 01H=Enable)		
    244          #define C32TranCheck	0xC8	//00H	// Code32    transmit CC ( 00H=Disable, 01H=Enable)		
    245          #define C32CutFNum		0xC9	//00H	// Code32    cut front number		
    246          #define C32CutBNum		0xCA	//00H	// Code32    cut back number		
    247          					
    248          #define G1InsertPosit	0xDA	//00H	//  G1插入位置		
    249          #define G1InsertCode	0xDB	//00H	// DAH~E3H   G1插入码		
    250          #define G1InsertCode_L	0xE4	//00H	目前输入字数		
    251          #define G2InsertPosit	0xE5	//00H	//  G2插入位置		
    252          #define G2InsertCode	0xE6	//00H	// E5H~EEH   G2插入码		
    253          #define G2InsertCode_L	0xEF	//00H	目前输入字数	
    254          
    255          /**
    256          * @brief uE988 命令定义  decoder->host
    257          */
    258          typedef struct {
    259          	unsigned short			CmdPos;
    260          	unsigned short			DataLength;
    261          	unsigned char			status;
    262          	unsigned char			*CmdBuffer;
    263          }THJ5000Command;
    264          
    265          #define		RES_CHECKFAILURE			1
    266          #define		RES_UNKOWN_MSG				2
    267          #define		RESPONSE_SUCCESS			3
    268          #define		RESPONSE_ACK				4
    269          #define		RESPONSE_NAK				5
    270          
    271          
    272          
    273          //static unsigned char	g_ack_enable;							//indicate whether ack/nck handshaking is enabled  1: enable; 0: disable
    274          #define MAX_DECODE_DATA		50
    275          
    276          THJ5000Command	g_resCmd;		//scan decoder -> host
    277          unsigned char	*g_pReqCmd;		//host -> scan decoder
    278          static	unsigned int	wait_time_out;			//get_barcode命令的等待超时设置
    279          
    280          extern unsigned char	scan_key_trig;
    281          extern	OS_EVENT		*pEvent_Queue;			//事件消息队列
    282          extern unsigned char	barcode[MAX_BARCODE_LEN+1];
    283          
    284          #define G_SEND_BUF_LENGTH     32
    285          #define G_RECEIV_BUF_LENGTH   128
    286          
    287          unsigned char		g_send_buff[G_SEND_BUF_LENGTH];
    288          unsigned char		g_receive_buff[G_RECEIV_BUF_LENGTH];
    289          
    290          static int write_cmd_to_scanner(const unsigned char *pData, unsigned short length);
    291          static int pack_set_command(unsigned char param_offset, unsigned char param_value);
    292          static int pack_ctrl_command(unsigned char cmd_type);
    293          int HJ5000_RxISRHandler(unsigned char c);
    294          
    295          
    296          /*
    297           * @brief: 初始化模块端口
    298          */
    299          static void HJ5000_GPIO_config(void)
    300          {
    301          	GPIO_InitTypeDef				GPIO_InitStructure;
    302          	USART_InitTypeDef				USART_InitStructure;
    303          
    304          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOA |
    305          		RCC_APB2Periph_AFIO, ENABLE);
    306          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    307          
    308          
    309          	/* PWRDWN PA.5 WAKE	PA.6 TRIG PA.7 */
    310          	//GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_5;
    311          	//GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    312          	//GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    313          	//GPIO_Init(GPIOA, &GPIO_InitStructure);
    314          
    315          	//GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_6 | GPIO_Pin_7;
    316          	//GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    317          	//GPIO_Init(GPIOA, &GPIO_InitStructure);
    318          	//GPIO_SetBits(GPIOA, GPIO_Pin_6 | GPIO_Pin_7);
    319          
    320          	//trig io
    321          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    322          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_10MHz;
    323          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    324          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    325          	GPIO_SetBits(GPIOA,GPIO_Pin_10);
    326          
    327          
    328          	// 使用UART3, PB10,PB11
    329          	/* Configure USART3 Tx (PB.10) as alternate function push-pull */
    330          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    331          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    332          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    333          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    334          	//GPIO_SetBits(GPIOB,GPIO_Pin_10);
    335          
    336          	/* Configure USART3 Rx (PB.11) as input floating				*/
    337          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    338          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    339          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    340          
    341          #if(USART_RX_MODE == USART_RX_DMA_MODE)
    342          	DMA_InitTypeDef DMA_InitStructure;
    343                  NVIC_InitTypeDef NVIC_InitStructure;
    344          
    345          	/* DMA clock enable */
    346          	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    347          
    348          
    349          	/* fill init structure */
    350          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    351          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    352          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    353          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    354          	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    355          	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    356          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    357          
    358          	/* DMA1 Channel2 (triggered by USART3 Tx event) Config */
    359          	DMA_DeInit(DMA1_Channel2);
    360          	DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART3->DR);
    361          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    362          	/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    363          	 * and DMA_BufferSize are meaningless. So just set them to proper values
    364          	 * which could make DMA_Init happy.
    365          	 */
    366          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    367          	DMA_InitStructure.DMA_BufferSize = 1;
    368          	DMA_Init(DMA1_Channel2, &DMA_InitStructure);
    369          
    370          
    371          	//DMA1通道3配置  
    372          	DMA_DeInit(DMA1_Channel3);  
    373          	//外设地址  
    374          	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART3->DR);  
    375          	//内存地址  
    376          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)g_receive_buff;  
    377          	//dma传输方向单向  
    378          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    379          	//设置DMA在传输时缓冲区的长度  
    380          	DMA_InitStructure.DMA_BufferSize = G_RECEIV_BUF_LENGTH;  
    381          	//设置DMA的外设递增模式，一个外设  
    382          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    383          	//设置DMA的内存递增模式  
    384          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    385          	//外设数据字长  
    386          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    387          	//内存数据字长  
    388          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    389          	//设置DMA的传输模式  
    390          	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    391          	//设置DMA的优先级别  
    392          	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    393          	//设置DMA的2个memory中的变量互相访问  
    394          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    395          	DMA_Init(DMA1_Channel3,&DMA_InitStructure);  
    396          
    397          	//使能通道3 
    398          	DMA_Cmd(DMA1_Channel3,ENABLE);  
    399          
    400          #endif
    401          
    402          	//初始化参数    
    403          	//USART_InitStructure.USART_BaudRate = DEFAULT_BAUD;    
    404          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;    
    405          	USART_InitStructure.USART_StopBits = USART_StopBits_1;    
    406          	USART_InitStructure.USART_Parity = USART_Parity_No;    
    407          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;    
    408          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;         
    409          	USART_InitStructure.USART_BaudRate = 9600;   
    410          	//初始化串口   
    411          	USART_Init(USART3,&USART_InitStructure); 
    412          
    413          
    414          #if(USART_RX_MODE == USART_RX_DMA_MODE)
    415          	//中断配置  
    416          	USART_ITConfig(USART3,USART_IT_TC,DISABLE);  
    417          	USART_ITConfig(USART3,USART_IT_RXNE,DISABLE);  
    418          	USART_ITConfig(USART3,USART_IT_IDLE,ENABLE);    
    419          
    420          	//配置UART3中断  
    421          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    422          	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;               //通道设置为串口1中断    
    423          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    424          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    425          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    426          	NVIC_Init(&NVIC_InitStructure);  
    427          
    428          	/* Enable the DMA1 Channel2 Interrupt */
    429          	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQChannel;
    430          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    431          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    432          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    433          	NVIC_Init(&NVIC_InitStructure);
    434          
    435          	DMA_ITConfig(DMA1_Channel2, DMA_IT_TC | DMA_IT_TE, ENABLE);
    436          	DMA_ClearFlag(DMA1_FLAG_TC2);
    437          
    438          	//采用DMA方式接收  
    439          	USART_DMACmd(USART3,USART_DMAReq_Rx,ENABLE); 
    440          
    441          	/* Enable USART3 DMA Tx request */
    442          	USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    443          
    444          #endif
    445          	//启动串口    
    446          	USART_Cmd(USART3, ENABLE);
    447          }
    448          
    449          static void HJ5000_NVIC_config(void)
    450          {
    451          #if(USART_RX_MODE == USART_RX_ISR_MODE)
    452          	NVIC_InitTypeDef NVIC_InitStructure;
    453          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    454          
    455          	/* Enable the USART1 Interrupt */
    456          	NVIC_InitStructure.NVIC_IRQChannel				=USART3_IRQChannel;
    457          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority	= 0;
    458          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority	= 5;
    459          	NVIC_InitStructure.NVIC_IRQChannelCmd			= ENABLE;
    460          	NVIC_Init(&NVIC_InitStructure);
    461          
    462          	USART_ClearITPendingBit(USART3, USART_IT_RXNE); 
    463          	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    464          #endif
    465          }
    466          
    467          void reset_resVar(void)
    468          {
    469          	g_resCmd.CmdPos = 0;
    470          	g_resCmd.DataLength = 0;
    471          	g_resCmd.status	 = 0;
    472          }
    473          
    474          
    475          /**
    476          * @brief  发数据给条形码扫描仪
    477          * @param[in] unsigned char *pData 要发送的数据
    478          * @param[in] int length 要发送数据的长度
    479          */
    480          static void send_data_to_scanner(const unsigned char *pData, unsigned short length)
    481          {
    482          #if (USART_RX_MODE == USART_RX_ISR_MODE)
    483          	while(length--)
    484          	{
    485          		USART_SendData(USART3, *pData++);
    486          		while(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET)
    487          		{
    488          		}
    489          	}
    490          	while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    491          #else
    492          	/* disable DMA */
    493          	DMA_Cmd(DMA1_Channel2, DISABLE);
    494          
    495          	/* set buffer address */
    496          	memcpy(g_send_buff,pData,length);
    497          
    498          	DMA1_Channel2->CMAR = (u32)&g_send_buff[0];
    499          	/* set size */
    500          	DMA1_Channel2->CNDTR = length;
    501          
    502          	USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    503          	/* enable DMA */
    504          	DMA_Cmd(DMA1_Channel2, ENABLE);
    505          
    506          	 while(DMA1_Channel2->CNDTR);
    507                   while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    508          #endif
    509          }
    510          
    511          /**
    512          * @brief  发命令给条形码扫描仪
    513          * @param[in] unsigned char *pData 要发送的数据
    514          * @param[in] int length 要发送数据的长度
    515          * @param[out]	0: 成功
    516          *				-1: 失败
    517          */
    518          static int write_cmd_to_scanner(const unsigned char *pData, unsigned short length)
    519          {
    520          
    521          	//HJ5000_wakeup();		//先唤醒模块
    522          
    523          	send_data_to_scanner(pData, length);
    524          
    525          	//if (g_ack_enable == 0)	//ack/nak handshaking disabled
    526          	//{
    527          	//	return 0;
    528          	//}
    529          	
    530          	return 0;
    531          }
    532          
    533          
    534          /**
    535          * @brief  打包命令(host->scanner)
    536          * @param[in] unsigned char cmd_code 命令代码
    537          * @param[in] unsigned char cmd_status 
    538          * @param[in] unsigned char *pCmddata 命令数据
    539          * @param[in] unsigned char data_len 命令数据长度
    540          * @note: 共4种命令格式（都是9Bytes）
    541          *     1. 设置命令:0xff 0x55 0x55 0x98 (参数位置)(1byte) (参数值)(1byte) 0x11 0x22 0x33
    542          *	  2. Trig命令：0xff 0x55 0x55 0xaf 0x11 0x22 0x33 0x44 0x55
    543          *	  3. Read CFG命令：0xff 0x55 0x55 0x92 0x11 0x22 0x33 0x44 0x55
    544          *     4. Set ALL Default命令：0xff 0x55 0x55 0xa1 0x11 0x22 0x33 0x44 0x55 		//reponse : 0x79 0x00 0x11 0x22 0x33 0x44
    545          */
    546          static int pack_set_command(unsigned char param_offset, unsigned char param_value)
    547          {       
    548              memset(g_pReqCmd,0,10);
    549          
    550          	g_pReqCmd[0] = 0xff;
    551          	g_pReqCmd[1] = 0x55;	
    552          	g_pReqCmd[2] = 0x55;	
    553          	g_pReqCmd[3] = 0x98;
    554          	g_pReqCmd[4] = param_offset;
    555          	g_pReqCmd[5] = param_value;
    556          	g_pReqCmd[6] = 0x11;
    557          	g_pReqCmd[7] = 0x22;
    558          	g_pReqCmd[8] = 0x33;
    559          	
    560          	return 9;
    561          }
    562          
    563          static int pack_ctrl_command(unsigned char cmd_type)
    564          {       
    565              memset(g_pReqCmd,0,10);
    566          
    567          	g_pReqCmd[0] = 0xff;
    568          	g_pReqCmd[1] = 0x55;	
    569          	g_pReqCmd[2] = 0x55;
    570          	switch(cmd_type)
    571          	{
    572          		case HJ5000_START_DECODE:
    573          			g_pReqCmd[3] = 0xaf;
    574          			break;
    575          		case HJ5000_READ_CFG:
    576          			g_pReqCmd[3] = 0x92;
    577          			break;
    578          		case HJ5000_SET_ALL_DEFAULT:
    579          			g_pReqCmd[3] = 0xA1;
    580          			break;
    581          		default:
    582          			return 0;
    583          	}
    584          	g_pReqCmd[4] = 0x11;
    585          	g_pReqCmd[5] = 0x22;
    586          	g_pReqCmd[6] = 0x33;
    587          	g_pReqCmd[7] = 0x44;
    588          	g_pReqCmd[8] = 0x55;
    589          	
    590          	return 9;
    591          }
    592          
    593          
    594          void scanner_mod_reset(void)
    595          {
    596          	//GPIO_ResetBits(GPIOA,GPIO_Pin_3);
    597          	g_resCmd.CmdPos = 0;
    598          	g_resCmd.DataLength = 0;
    599          	g_resCmd.status	 = 0;
    600          }
    601          /*
    602          * @breif:  恢复出厂
    603          */
    604          void HJ5000_set_default(void)
    605          {
    606          	int ret;
    607          
    608          	ret = pack_ctrl_command(HJ5000_SET_ALL_DEFAULT);
    609          	if(ret)
    610          	{
    611          		ret = write_cmd_to_scanner(g_pReqCmd, ret);
    612          	}
    613          
    614          	return;
    615          }
    616          /*
    617          * @brief: 模块初始化
    618          */
    619          void scanner_mod_init(void)
    620          {
    621          	int	ret;
    622          	HJ5000_GPIO_config();
    623          	HJ5000_NVIC_config();
    624          	
    625          	g_pReqCmd	= g_send_buff;
    626          	g_resCmd.CmdBuffer	= g_receive_buff;
    627          
    628          	reset_resVar();
    629          	//初始化串口配置
    630          	//Comm_SetReceiveProc(COMM3, (CommIsrInByte)HJ5000_RxISRHandler);						//设置串口回调函数
    631          	//HJ5000_set_default();
    632          #ifdef SCANNER_TRIG_HW
    633          	ret = pack_set_command(ScanMode,0x00);
    634          #else
    635          	ret = pack_set_command(ScanMode,0x0a);
    636          #endif
    637          	write_cmd_to_scanner(g_pReqCmd, ret);
    638          	OSTimeDlyHMSM(0, 0, 0, 100);
    639          	ret = pack_set_command(RSTerminator,0x02);
    640          	write_cmd_to_scanner(g_pReqCmd, ret);
    641          	OSTimeDlyHMSM(0, 0, 0, 100);
    642          	wait_time_out = 28;
    643          	//scan_start = 0;
    644          }
    645          
    646          
    647          /**
    648          * @brief 处理host收到scanner的数据
    649          * @param[in] unsigned char c 读入的字符
    650          * @return 0:success put in buffer
    651          *        -1:fail
    652          */
    653          int HJ5000_RxISRHandler(unsigned char c)
    654          {
    655          	//unsigned short checksum = 0;
    656          	unsigned int i;
    657          	if(g_resCmd.status == 0)
    658          	{
    659          		g_resCmd.CmdBuffer[g_resCmd.CmdPos++] = c;
    660          	}
    661          	
    662          
    663          	//if (g_resCmd.CmdPos == 1)
    664          	//{
    665          	//	if (g_resCmd.CmdBuffer[0] == 0x06)
    666          	//	{
    667          	//		g_resCmd.status = RESPONSE_ACK;
    668          	//	}
    669          	//	else if (g_resCmd.CmdBuffer[0] == 0x15)
    670          	//	{
    671          	//		g_resCmd.status = RESPONSE_NAK;
    672          	//	}
    673          	//}
    674          
    675          	//if ((g_resCmd.CmdBuffer[g_resCmd.CmdPos-1] == 0x0a)&&(g_resCmd.CmdBuffer[g_resCmd.CmdPos-2] == 0x0d))
    676          	if (g_resCmd.CmdBuffer[g_resCmd.CmdPos-1] == 0x0d)
    677          	{
    678          		g_resCmd.status = RESPONSE_SUCCESS;
    679          		SCANNER_TRIG_OFF();
    680          		hw_platform_stop_led_blink(LED_GREEN);
    681          
    682          		if (scan_key_trig)
    683          		{
    684          			
    685          			OSQPost(pEvent_Queue,(scan_key_trig == 1)?(void*)EVENT_SCAN_GOT_BARCODE:(void*)EVENT_ERASE_GOT_BARCODE);
    686          			i = (((g_resCmd.CmdPos-1) > MAX_BARCODE_LEN)?MAX_BARCODE_LEN:(g_resCmd.CmdPos-1));
    687          			memcpy(barcode, &g_resCmd.CmdBuffer[0], i);
    688          			barcode[i] = 0;
    689                                  scan_key_trig = 0;
    690          		}
    691          	}
    692          
    693          	if (g_resCmd.CmdPos >= G_RECEIV_BUF_LENGTH)
    694          	{
    695          		reset_resVar();
    696          		g_resCmd.status = RES_UNKOWN_MSG;
    697          		return -1;
    698          	}
    699          
    700          	return 0;
    701          }
    702          
    703          
    704          /*
    705          * @breif:  开始 或 停止扫描条码
    706          * @param[in]: ctrl_type: UE988_START_DECODE  UE988_STOP_DECODE
    707          */
    708          void HJ5000_start_stop_decode(unsigned char ctrl_type)
    709          {
    710          	int ret;
    711          	if (ctrl_type == HJ5000_START_DECODE)
    712          	{
    713          		//ret = pack_ctrl_command(HJ5000_START_DECODE);
    714          		SCANNER_TRIG_ON();
    715          	}
    716          	else
    717          	{
    718          		//ret = pack_ctrl_command(HJ5000_STOP_DECODE);
    719          		SCANNER_TRIG_OFF();
    720          	}
    721          	//if(ret)
    722          	//{
    723          	//	//g_ack_enable = 0;
    724          	//	ret = write_cmd_to_scanner(g_pReqCmd, ret);
    725          	//	//g_ack_enable = 1;
    726          	//}
    727          
    728          	return;
    729          }
    730          
    731          /*
    732          * @breif:  获取条形码
    733          * @param[out]: unsigned char *code_type: 条形码类型		10个字节
    734          * @param[out]: unsigned char *code_buf: 存储条形码的缓存, code Type + decode data
    735          * @param[in]:  unsigned char inbuf_size: 传进来用来存放decode_data的buf大小
    736          * @param[out]  unsigned char *code_len:	 实际获取的条形码的长度，如果实际获取的长度比传进来的buf大，那么只返回传进来的buf大小的数据
    737          */
    738          int scanner_get_barcode(unsigned char *barcode,unsigned int max_num,unsigned char *barcode_type,unsigned int *barcode_len)
    739          {
    740          	int		i = 0;
    741          
    742          	//start decode
    743          	HJ5000_start_stop_decode(HJ5000_START_DECODE);
    744          	reset_resVar();
    745              for(i = 0; i < wait_time_out; i++)   //新扫描头的超时只有3S左右
    746          	{
    747          		if (g_resCmd.status == RESPONSE_SUCCESS) //成功收到响应
    748          		{
    749          			HJ5000_start_stop_decode(HJ5000_STOP_DECODE);
    750          			*barcode_len	= g_resCmd.CmdPos-1;
    751          			i = ((*barcode_len > max_num)?max_num:*barcode_len);
    752          			memcpy(barcode, &g_resCmd.CmdBuffer[0], i);
    753          			barcode[i] = 0;
    754          			strcpy((char*)barcode_type, "");
    755          			//Beep(400);
    756          			return 0;
    757          		}//成功收到响应
    758          		//else if (g_resCmd.status == RESPONSE_NAK)	//响应失败
    759          		//{
    760          		//	lineccd_start_stop_decode(LINECCD_STOP_DECODE);
    761          		//	return -1;
    762          		//}
    763          		//else if (g_resCmd.status == RES_CHECKFAILURE)
    764          		//{
    765          		//	send_nak_to_sanner(RES_CHECKFAILURE);	
    766          		//	lineccd_start_stop_decode(LINECCD_STOP_DECODE);
    767          		//	return -1;
    768          		//}
    769          		else if (g_resCmd.status == RES_UNKOWN_MSG)
    770          		{
    771          			HJ5000_start_stop_decode(HJ5000_STOP_DECODE);
    772          			return -1;
    773          		}
    774          
    775          		OSTimeDlyHMSM(0, 0, 0, 100);
    776          	}//延时
    777          
    778          	HJ5000_start_stop_decode(HJ5000_STOP_DECODE);
    779          	return -1;
    780          }
    781          
    782          
    783          void scanner_power_off(void)
    784          {
    785          	//GPIO_SetBits(SCANNER_POWER_EN_GPIO_PORT,SCANNER_POWER_EN_PIN);
    786          }

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     HJ5000_GPIO_config           24
     HJ5000_NVIC_config            8
     HJ5000_RxISRHandler           8
     HJ5000_set_default            8
     HJ5000_start_stop_decode      8
     memcpy                        8
     memset                        8
     pack_ctrl_command             8
     pack_set_command             16
     reset_resVar                  0
     scanner_get_barcode          24
     scanner_mod_init              8
     scanner_mod_reset             0
     scanner_power_off             0
     send_data_to_scanner         16
     write_cmd_to_scanner          8


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     memcpy                     14
     memset                     20
     g_resCmd                   12
     g_pReqCmd                   4
     wait_time_out               4
     g_send_buff                32
     g_receive_buff            128
     HJ5000_GPIO_config        176
     HJ5000_NVIC_config         58
     reset_resVar               26
     send_data_to_scanner       56
     write_cmd_to_scanner       12
     pack_set_command           90
     pack_ctrl_command         132
     scanner_mod_reset          20
     HJ5000_set_default         26
     scanner_mod_init          108
     HJ5000_RxISRHandler       184
     HJ5000_start_stop_decode   32
     scanner_get_barcode       152
     scanner_power_off           2
     ??DataTable11               4
     ??DataTable41               4
     ??DataTable58               4
     ??DataTable59               4
     ??DataTable63               4
     ?<Constant "">              1

 
   180 bytes in section .bss
     1 byte  in section .rodata
 1 128 bytes in section .text
 
 1 094 bytes of CODE  memory (+ 34 bytes shared)
     1 byte  of CONST memory
   180 bytes of DATA  memory

Errors: none
Warnings: 6
